<!DOCTYPE html>
<html>
<head>
<title>Mobilefish.com - Cryptocurrency address generator and validator (v1.1)</title>
<!-- Do not cache web page across all browsers -->
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="0" />
<meta name="keywords" content="Cryptocurrency, bitcoin, address, generator, private, public, wif, compressed, uncompressed, qr code, vanity, alternative cryptocurrencies" />
<meta name="description" content="Cryptocurrency address generator and validator (v1.1)" />

<style type="text/css">
body {margin-left: 10; margin-right: 10; margin-top: 10; font-size: 12px; font-family: arial, sans-serif; color: #000000; background-color: #ffffff;}
form {margin-top: 0; padding-top: 0; margin-bottom: 0;}
hr {color: #6e85bb; background: #6e85bb; border: 0; height: 1px;}
input {border:1px solid #000000; border-radius: 3px; margin: 0 2px 2px 0;}
input:focus {outline:none; border-color:#000000; box-shadow:0 0 10px #9ecaed;}
select {-webkit-border-radius: 3px; -moz-border-radius: 3px; border-radius: 3px;}
textarea {border:1px solid #000000; border-radius:3px;}
textarea:focus {outline:none; border:1px solid #000000;box-shadow:0 0 10px #9ecaed;}
td {font-size: 12px; font-family: arial, sans-serif; text-decoration: none;}
a {font-size: 12px; font-family: arial, sans-serif; font-weight: normal; text-decoration : none; color: #003399;}
.css-Button {background-color:#003366; font:12px arial; color:#ffffff; font-weight:bold; cursor:pointer; cursor: hand; width: 80px}
.css-Data {font-size: 14px; font-family: arial, sans-serif; color: #000000; font-weight: bold; font-style:normal; text-decoration : none; }
.css-Data2 {font-size: 14px; font-family: arial, sans-serif; color: #ff0000; font-weight: bold; font-style:italic; text-decoration : none;}
.css-Data3 {font-size: 12px; font-family: arial, sans-serif; font-weight: normal; color: #000000; text-decoration: none; background-color: #ffffff;}
.cssxGreen {background-color: #6bf88f;}
.cssxGrey {background-color: #cccccc;}
.css-Note {font-size: 12px; font-family: arial, sans-serif; font-weight: normal; font-style: normal; color: #000000; text-decoration: none;}
.cssxRed {background-color: #ffa500;}
.cssxDiceBlock{border:1px solid #000000; border-radius: 3px; background-color: #ffffff; margin: 10px 10px 0 0; padding: 2px 2px 2px 2px; display:inline-block}
.cssxDiceBlockRow0{background-color: #2766c2; color: #ffffff;} /* blue */
.cssxDiceBlockRow1{background-color: #0ca056; color: #ffffff;} /* green */
.cssxDiceBlockRow2{background-color: #f9ef34; color: #000000;} /* yellow */
.cssxDiceBlockRow3{background-color: #343530; color: #ffffff;} /* black */
.cssxEquation {background-color: #ffa500; font-weight: bold; padding: 2px}
#cssxShowMoreDetailsText {font-size: 16px; font-family: arial, sans-serif; font-weight: bold; font-style: normal; color: #0000ff; text-decoration: none; display:inline; vertical-align: -1px}
.css-Table {border:1px solid #6e85bb; background-color: #ffffcc; width:100%}
.css-Table3 {border:0; background-color: #6e85bb; width:600px}
.css-TableHeader {font-size: 12px; font-family: arial, sans-serif; font-weight: bold; color: #000000; text-decoration: none; background-color: #eeeeee;}
.cssxBlock {border:1px; background-color: #6e85bb; width:300px; padding: 2px; font-weight: bold; }
#cssxAddressNetwork1, #cssxAddressNetwork2, #cssxAddressNetwork3, #cssxAddressNetwork4, #cssxAddressNetwork5, #cssxAddressNetwork6, #cssxAddressNetwork7, #cssxAddressNetwork8, #cssxAddressNetwork9{display: inline; font-size: 12px; font-family: arial, sans-serif; font-weight: bold; color: #ffffff; background-color: #000000; padding: 2px 5px}

/* Display QR code */
#cssxAddressNetworkQRCode1, #cssxAddressNetworkQRCode2, #cssxAddressNetworkQRCode3, #cssxAddressNetworkQRCode4  {color: #ffffff; background-color: #000000; display: inline; padding: 0 10px;}
.cssxQRCodeTable {border:0; background-color: #6e85bb; width:100%}
.cssxQRTableHeader {font-size: 14px; font-family: arial, sans-serif; font-weight: bold; color: #000000; text-decoration: none; background-color: #eeeeee; padding: 10px;}
.cssxQRTableData {font-size: 16px; font-family: arial, sans-serif; font-weight: bold; color: #000000; text-decoration : none; background-color: #ffffff; padding: 10px;}
.cssxQRTableFooter {font-size: 16px; font-family: monospace, arial, sans-serif; font-weight: bold; color: #000000; text-decoration : none; background-color: #ffffff; padding: 10px;}
</style>


<style type="text/css" media="print">
h1 {display: none;}
.css-Data {display: none;}
.css-Table {border:0px; background-color: #ffffff; width:100%}
.cssxNoPrint {display:none;}
.cssxHideTr {display: none;}
.cssxHideDiv {display: none;}

/* Display QR code */
#cssxAddressNetworkQRCode1, #cssxAddressNetworkQRCode2, #cssxAddressNetworkQRCode3, #cssxAddressNetworkQRCode4 {color: #ffffff; background-color: #000000; display: inline; padding: 0 10px;}
.cssxQRCodeTable {border:0; background-color: #6e85bb; width:100%}
.cssxQRTableHeader {font-size: 14px; font-family: arial, sans-serif; font-weight: bold; color: #000000; text-decoration: none; background-color: #eeeeee; padding: 10px;}
.cssxQRTableData {font-size: 16px; font-family: arial, sans-serif; font-weight: bold; color: #000000; text-decoration : none; background-color: #ffffff; padding: 10px;}
.cssxQRTableFooter {font-size: 16px; font-family: monospace, arial, sans-serif; font-weight: bold; color: #000000; text-decoration : none; background-color: #ffffff; padding: 10px;}
</style>

<!-- Crypto.util.bytesToHex -->
<!-- script type="text/javascript" src="http://crypto-js.googlecode.com/svn/tags/2.5.4/build/crypto/crypto-min.js"></script -->

<!-- Crypto.SHA256 -->
<!-- script type="text/javascript" src="http://crypto-js.googlecode.com/svn/tags/2.5.4/build/crypto-sha256/crypto-sha256.js"></script -->

<!-- Bitcoin.Base58.encode -->
<!-- script type="text/javascript" src="http://cdn.bitcoinjs.org/libs/bitcoinjs-lib/0.1.0/bitcoinjs-min.js"></script -->

<!-- Source: http://coinb.in/multisig/js/bitcoinjs-min.js -->
<!-- <script type="text/javascript" src="../../scripts/bitcoin/bitcoinjs-min.js"></script> -->
<!-- Copy the content of bitcoinjs-min.js on this page -->
<script language="JavaScript" type="text/javascript">
/**
 * BitcoinJS-lib v0.1.3-default (Patched by OutCast3k for better multisig support)
 * Copyright (c) 2011 BitcoinJS Project
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the MIT license.
 */
(function(){var e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",t=window.Crypto={},n=t.util={rotl:function(e,t){return e<<t|e>>>32-t},rotr:function(e,t){return e<<32-t|e>>>t},endian:function(e){if(e.constructor==Number)return n.rotl(e,8)&16711935|n.rotl(e,24)&4278255360;for(var t=0;t<e.length;t++)e[t]=n.endian(e[t]);return e},randomBytes:function(e){for(var t=[];e>0;e--)t.push(Math.floor(Math.random()*256));return t},bytesToWords:function(e){for(var t=[],n=0,r=0;n<e.length;n++,r+=8)t[r>>>5]|=e[n]<<24-r%32;return t},wordsToBytes:function(e){for(var t=[],n=0;n<e.length*32;n+=8)t.push(e[n>>>5]>>>24-n%32&255);return t},bytesToHex:function(e){for(var t=[],n=0;n<e.length;n++)t.push((e[n]>>>4).toString(16)),t.push((e[n]&15).toString(16));return t.join("")},hexToBytes:function(e){for(var t=[],n=0;n<e.length;n+=2)t.push(parseInt(e.substr(n,2),16));return t},bytesToBase64:function(t){if(typeof btoa=="function")return btoa(s.bytesToString(t));for(var n=[],r=0;r<t.length;r+=3){var i=t[r]<<16|t[r+1]<<8|t[r+2];for(var o=0;o<4;o++)r*8+o*6<=t.length*8?n.push(e.charAt(i>>>6*(3-o)&63)):n.push("=")}return n.join("")},base64ToBytes:function(t){if(typeof atob=="function")return s.stringToBytes(atob(t));t=t.replace(/[^A-Z0-9+\/]/ig,"");for(var n=[],r=0,i=0;r<t.length;i=++r%4){if(i==0)continue;n.push((e.indexOf(t.charAt(r-1))&Math.pow(2,-2*i+8)-1)<<i*2|e.indexOf(t.charAt(r))>>>6-i*2)}return n}};t.mode={};var r=t.charenc={},i=r.UTF8={stringToBytes:function(e){return s.stringToBytes(unescape(encodeURIComponent(e)))},bytesToString:function(e){return decodeURIComponent(escape(s.bytesToString(e)))}},s=r.Binary={stringToBytes:function(e){for(var t=[],n=0;n<e.length;n++)t.push(e.charCodeAt(n));return t},bytesToString:function(e){for(var t=[],n=0;n<e.length;n++)t.push(String.fromCharCode(e[n]));return t.join("")}}})();
(function(){var e=Crypto,t=e.util,n=e.charenc,r=n.UTF8,i=n.Binary,s=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298],o=e.SHA256=function(e,n){var r=t.wordsToBytes(o._sha256(e));return n&&n.asBytes?r:n&&n.asString?i.bytesToString(r):t.bytesToHex(r)};o._sha256=function(e){e.constructor==String&&(e=r.stringToBytes(e));var n=t.bytesToWords(e),i=e.length*8,o=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225],u=[],a,f,l,c,h,p,d,v,m,g,y,b;n[i>>5]|=128<<24-i%32,n[(i+64>>9<<4)+15]=i;for(var m=0;m<n.length;m+=16){a=o[0],f=o[1],l=o[2],c=o[3],h=o[4],p=o[5],d=o[6],v=o[7];for(var g=0;g<64;g++){if(g<16)u[g]=n[g+m];else{var w=u[g-15],E=u[g-2],S=(w<<25|w>>>7)^(w<<14|w>>>18)^w>>>3,x=(E<<15|E>>>17)^(E<<13|E>>>19)^E>>>10;u[g]=S+(u[g-7]>>>0)+x+(u[g-16]>>>0)}var T=h&p^~h&d,N=a&f^a&l^f&l,C=(a<<30|a>>>2)^(a<<19|a>>>13)^(a<<10|a>>>22),k=(h<<26|h>>>6)^(h<<21|h>>>11)^(h<<7|h>>>25);y=(v>>>0)+k+T+s[g]+(u[g]>>>0),b=C+N,v=d,d=p,p=h,h=c+y,c=l,l=f,f=a,a=y+b}o[0]+=a,o[1]+=f,o[2]+=l,o[3]+=c,o[4]+=h,o[5]+=p,o[6]+=d,o[7]+=v}return o},o._blocksize=16})();
(function(){function o(e,t,n,r){return 0<=e&&e<=15?t^n^r:16<=e&&e<=31?t&n|~t&r:32<=e&&e<=47?(t|~n)^r:48<=e&&e<=63?t&r|n&~r:64<=e&&e<=79?t^(n|~r):"rmd160_f: j out of range"}function u(e){return 0<=e&&e<=15?0:16<=e&&e<=31?1518500249:32<=e&&e<=47?1859775393:48<=e&&e<=63?2400959708:64<=e&&e<=79?2840853838:"rmd160_K1: j out of range"}function a(e){return 0<=e&&e<=15?1352829926:16<=e&&e<=31?1548603684:32<=e&&e<=47?1836072691:48<=e&&e<=63?2053994217:64<=e&&e<=79?0:"rmd160_K2: j out of range"}function p(e,t){var n=(e&65535)+(t&65535),r=(e>>16)+(t>>16)+(n>>16);return r<<16|n&65535}function d(e,t){return e<<t|e>>>32-t}var e=Crypto,t=e.util,n=e.charenc,r=n.UTF8,i=n.Binary;t.bytesToLWords=function(e){var t=Array(e.length>>2);for(var n=0;n<t.length;n++)t[n]=0;for(var n=0;n<e.length*8;n+=8)t[n>>5]|=(e[n/8]&255)<<n%32;return t},t.lWordsToBytes=function(e){var t=[];for(var n=0;n<e.length*32;n+=8)t.push(e[n>>5]>>>n%32&255);return t};var s=e.RIPEMD160=function(e,n){var r=t.lWordsToBytes(s._rmd160(e));return n&&n.asBytes?r:n&&n.asString?i.bytesToString(r):t.bytesToHex(r)};s._rmd160=function(e){e.constructor==String&&(e=r.stringToBytes(e));var n=t.bytesToLWords(e),i=e.length*8;n[i>>5]|=128<<i%32,n[(i+64>>>9<<4)+14]=i;var s=1732584193,v=4023233417,m=2562383102,g=271733878,y=3285377520;for(var b=0;b<n.length;b+=16){var w,E=s,S=v,x=m,T=g,N=y,C=s,k=v,L=m,A=g,O=y;for(var M=0;M<=79;++M)w=p(E,o(M,S,x,T)),w=p(w,n[b+f[M]]),w=p(w,u(M)),w=p(d(w,c[M]),N),E=N,N=T,T=d(x,10),x=S,S=w,w=p(C,o(79-M,k,L,A)),w=p(w,n[b+l[M]]),w=p(w,a(M)),w=p(d(w,h[M]),O),C=O,O=A,A=d(L,10),L=k,k=w;w=p(v,p(x,A)),v=p(m,p(T,O)),m=p(g,p(N,C)),g=p(y,p(E,k)),y=p(s,p(S,L)),s=w}return[s,v,m,g,y]};var f=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13],l=[5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11],c=[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6],h=[8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11]})();
function Arcfour(){this.i=0,this.j=0,this.S=new Array}function ARC4init(e){var t,n,r;for(t=0;t<256;++t)this.S[t]=t;n=0;for(t=0;t<256;++t)n=n+this.S[t]+e[t%e.length]&255,r=this.S[t],this.S[t]=this.S[n],this.S[n]=r;this.i=0,this.j=0}function ARC4next(){var e;return this.i=this.i+1&255,this.j=this.j+this.S[this.i]&255,e=this.S[this.i],this.S[this.i]=this.S[this.j],this.S[this.j]=e,this.S[e+this.S[this.i]&255]}function prng_newstate(){return new Arcfour}Arcfour.prototype.init=ARC4init,Arcfour.prototype.next=ARC4next;var rng_psize=256;
function rng_seed_int(e){rng_pool[rng_pptr++]^=e&255,rng_pool[rng_pptr++]^=e>>8&255,rng_pool[rng_pptr++]^=e>>16&255,rng_pool[rng_pptr++]^=e>>24&255,rng_pptr>=rng_psize&&(rng_pptr-=rng_psize)}function rng_seed_time(){rng_seed_int((new Date).getTime())}function rng_get_byte(){if(rng_state==null){rng_seed_time(),rng_state=prng_newstate(),rng_state.init(rng_pool);for(rng_pptr=0;rng_pptr<rng_pool.length;++rng_pptr)rng_pool[rng_pptr]=0;rng_pptr=0}return rng_state.next()}function rng_get_bytes(e){var t;for(t=0;t<e.length;++t)e[t]=rng_get_byte()}function SecureRandom(){}var rng_state,rng_pool,rng_pptr;if(rng_pool==null){rng_pool=new Array,rng_pptr=0;var t;if(navigator.appName=="Netscape"&&navigator.appVersion<"5"&&window.crypto){var z=window.crypto.random(32);for(t=0;t<z.length;++t)rng_pool[rng_pptr++]=z.charCodeAt(t)&255}while(rng_pptr<rng_psize)t=Math.floor(65536*Math.random()),rng_pool[rng_pptr++]=t>>>8,rng_pool[rng_pptr++]=t&255;rng_pptr=0,rng_seed_time()}SecureRandom.prototype.nextBytes=rng_get_bytes;
function BigInteger(e,t,n){e!=null&&("number"==typeof e?this.fromNumber(e,t,n):t==null&&"string"!=typeof e?this.fromString(e,256):this.fromString(e,t))}function nbi(){return new BigInteger(null)}function am1(e,t,n,r,i,s){while(--s>=0){var o=t*this[e++]+n[r]+i;i=Math.floor(o/67108864),n[r++]=o&67108863}return i}function am2(e,t,n,r,i,s){var o=t&32767,u=t>>15;while(--s>=0){var a=this[e]&32767,f=this[e++]>>15,l=u*a+f*o;a=o*a+((l&32767)<<15)+n[r]+(i&1073741823),i=(a>>>30)+(l>>>15)+u*f+(i>>>30),n[r++]=a&1073741823}return i}function am3(e,t,n,r,i,s){var o=t&16383,u=t>>14;while(--s>=0){var a=this[e]&16383,f=this[e++]>>14,l=u*a+f*o;a=o*a+((l&16383)<<14)+n[r]+i,i=(a>>28)+(l>>14)+u*f,n[r++]=a&268435455}return i}function int2char(e){return BI_RM.charAt(e)}function intAt(e,t){var n=BI_RC[e.charCodeAt(t)];return n==null?-1:n}function bnpCopyTo(e){for(var t=this.t-1;t>=0;--t)e[t]=this[t];e.t=this.t,e.s=this.s}function bnpFromInt(e){this.t=1,this.s=e<0?-1:0,e>0?this[0]=e:e<-1?this[0]=e+DV:this.t=0}function nbv(e){var t=nbi();return t.fromInt(e),t}function bnpFromString(e,t){var n;if(t==16)n=4;else if(t==8)n=3;else if(t==256)n=8;else if(t==2)n=1;else if(t==32)n=5;else{if(t!=4){this.fromRadix(e,t);return}n=2}this.t=0,this.s=0;var r=e.length,i=!1,s=0;while(--r>=0){var o=n==8?e[r]&255:intAt(e,r);if(o<0){e.charAt(r)=="-"&&(i=!0);continue}i=!1,s==0?this[this.t++]=o:s+n>this.DB?(this[this.t-1]|=(o&(1<<this.DB-s)-1)<<s,this[this.t++]=o>>this.DB-s):this[this.t-1]|=o<<s,s+=n,s>=this.DB&&(s-=this.DB)}n==8&&(e[0]&128)!=0&&(this.s=-1,s>0&&(this[this.t-1]|=(1<<this.DB-s)-1<<s)),this.clamp(),i&&BigInteger.ZERO.subTo(this,this)}function bnpClamp(){var e=this.s&this.DM;while(this.t>0&&this[this.t-1]==e)--this.t}function bnToString(e){if(this.s<0)return"-"+this.negate().toString(e);var t;if(e==16)t=4;else if(e==8)t=3;else if(e==2)t=1;else if(e==32)t=5;else{if(e!=4)return this.toRadix(e);t=2}var n=(1<<t)-1,r,i=!1,s="",o=this.t,u=this.DB-o*this.DB%t;if(o-->0){u<this.DB&&(r=this[o]>>u)>0&&(i=!0,s=int2char(r));while(o>=0)u<t?(r=(this[o]&(1<<u)-1)<<t-u,r|=this[--o]>>(u+=this.DB-t)):(r=this[o]>>(u-=t)&n,u<=0&&(u+=this.DB,--o)),r>0&&(i=!0),i&&(s+=int2char(r))}return i?s:"0"}function bnNegate(){var e=nbi();return BigInteger.ZERO.subTo(this,e),e}function bnAbs(){return this.s<0?this.negate():this}function bnCompareTo(e){var t=this.s-e.s;if(t!=0)return t;var n=this.t;t=n-e.t;if(t!=0)return this.s<0?-t:t;while(--n>=0)if((t=this[n]-e[n])!=0)return t;return 0}function nbits(e){var t=1,n;return(n=e>>>16)!=0&&(e=n,t+=16),(n=e>>8)!=0&&(e=n,t+=8),(n=e>>4)!=0&&(e=n,t+=4),(n=e>>2)!=0&&(e=n,t+=2),(n=e>>1)!=0&&(e=n,t+=1),t}function bnBitLength(){return this.t<=0?0:this.DB*(this.t-1)+nbits(this[this.t-1]^this.s&this.DM)}function bnpDLShiftTo(e,t){var n;for(n=this.t-1;n>=0;--n)t[n+e]=this[n];for(n=e-1;n>=0;--n)t[n]=0;t.t=this.t+e,t.s=this.s}function bnpDRShiftTo(e,t){for(var n=e;n<this.t;++n)t[n-e]=this[n];t.t=Math.max(this.t-e,0),t.s=this.s}function bnpLShiftTo(e,t){var n=e%this.DB,r=this.DB-n,i=(1<<r)-1,s=Math.floor(e/this.DB),o=this.s<<n&this.DM,u;for(u=this.t-1;u>=0;--u)t[u+s+1]=this[u]>>r|o,o=(this[u]&i)<<n;for(u=s-1;u>=0;--u)t[u]=0;t[s]=o,t.t=this.t+s+1,t.s=this.s,t.clamp()}function bnpRShiftTo(e,t){t.s=this.s;var n=Math.floor(e/this.DB);if(n>=this.t){t.t=0;return}var r=e%this.DB,i=this.DB-r,s=(1<<r)-1;t[0]=this[n]>>r;for(var o=n+1;o<this.t;++o)t[o-n-1]|=(this[o]&s)<<i,t[o-n]=this[o]>>r;r>0&&(t[this.t-n-1]|=(this.s&s)<<i),t.t=this.t-n,t.clamp()}function bnpSubTo(e,t){var n=0,r=0,i=Math.min(e.t,this.t);while(n<i)r+=this[n]-e[n],t[n++]=r&this.DM,r>>=this.DB;if(e.t<this.t){r-=e.s;while(n<this.t)r+=this[n],t[n++]=r&this.DM,r>>=this.DB;r+=this.s}else{r+=this.s;while(n<e.t)r-=e[n],t[n++]=r&this.DM,r>>=this.DB;r-=e.s}t.s=r<0?-1:0,r<-1?t[n++]=this.DV+r:r>0&&(t[n++]=r),t.t=n,t.clamp()}function bnpMultiplyTo(e,t){var n=this.abs(),r=e.abs(),i=n.t;t.t=i+r.t;while(--i>=0)t[i]=0;for(i=0;i<r.t;++i)t[i+n.t]=n.am(0,r[i],t,i,0,n.t);t.s=0,t.clamp(),this.s!=e.s&&BigInteger.ZERO.subTo(t,t)}function bnpSquareTo(e){var t=this.abs(),n=e.t=2*t.t;while(--n>=0)e[n]=0;for(n=0;n<t.t-1;++n){var r=t.am(n,t[n],e,2*n,0,1);(e[n+t.t]+=t.am(n+1,2*t[n],e,2*n+1,r,t.t-n-1))>=t.DV&&(e[n+t.t]-=t.DV,e[n+t.t+1]=1)}e.t>0&&(e[e.t-1]+=t.am(n,t[n],e,2*n,0,1)),e.s=0,e.clamp()}function bnpDivRemTo(e,t,n){var r=e.abs();if(r.t<=0)return;var i=this.abs();if(i.t<r.t){t!=null&&t.fromInt(0),n!=null&&this.copyTo(n);return}n==null&&(n=nbi());var s=nbi(),o=this.s,u=e.s,a=this.DB-nbits(r[r.t-1]);a>0?(r.lShiftTo(a,s),i.lShiftTo(a,n)):(r.copyTo(s),i.copyTo(n));var f=s.t,l=s[f-1];if(l==0)return;var c=l*(1<<this.F1)+(f>1?s[f-2]>>this.F2:0),h=this.FV/c,p=(1<<this.F1)/c,d=1<<this.F2,v=n.t,m=v-f,g=t==null?nbi():t;s.dlShiftTo(m,g),n.compareTo(g)>=0&&(n[n.t++]=1,n.subTo(g,n)),BigInteger.ONE.dlShiftTo(f,g),g.subTo(s,s);while(s.t<f)s[s.t++]=0;while(--m>=0){var y=n[--v]==l?this.DM:Math.floor(n[v]*h+(n[v-1]+d)*p);if((n[v]+=s.am(0,y,n,m,0,f))<y){s.dlShiftTo(m,g),n.subTo(g,n);while(n[v]<--y)n.subTo(g,n)}}t!=null&&(n.drShiftTo(f,t),o!=u&&BigInteger.ZERO.subTo(t,t)),n.t=f,n.clamp(),a>0&&n.rShiftTo(a,n),o<0&&BigInteger.ZERO.subTo(n,n)}function bnMod(e){var t=nbi();return this.abs().divRemTo(e,null,t),this.s<0&&t.compareTo(BigInteger.ZERO)>0&&e.subTo(t,t),t}function Classic(e){this.m=e}function cConvert(e){return e.s<0||e.compareTo(this.m)>=0?e.mod(this.m):e}function cRevert(e){return e}function cReduce(e){e.divRemTo(this.m,null,e)}function cMulTo(e,t,n){e.multiplyTo(t,n),this.reduce(n)}function cSqrTo(e,t){e.squareTo(t),this.reduce(t)}function bnpInvDigit(){if(this.t<1)return 0;var e=this[0];if((e&1)==0)return 0;var t=e&3;return t=t*(2-(e&15)*t)&15,t=t*(2-(e&255)*t)&255,t=t*(2-((e&65535)*t&65535))&65535,t=t*(2-e*t%this.DV)%this.DV,t>0?this.DV-t:-t}function Montgomery(e){this.m=e,this.mp=e.invDigit(),this.mpl=this.mp&32767,this.mph=this.mp>>15,this.um=(1<<e.DB-15)-1,this.mt2=2*e.t}function montConvert(e){var t=nbi();return e.abs().dlShiftTo(this.m.t,t),t.divRemTo(this.m,null,t),e.s<0&&t.compareTo(BigInteger.ZERO)>0&&this.m.subTo(t,t),t}function montRevert(e){var t=nbi();return e.copyTo(t),this.reduce(t),t}function montReduce(e){while(e.t<=this.mt2)e[e.t++]=0;for(var t=0;t<this.m.t;++t){var n=e[t]&32767,r=n*this.mpl+((n*this.mph+(e[t]>>15)*this.mpl&this.um)<<15)&e.DM;n=t+this.m.t,e[n]+=this.m.am(0,r,e,t,0,this.m.t);while(e[n]>=e.DV)e[n]-=e.DV,e[++n]++}e.clamp(),e.drShiftTo(this.m.t,e),e.compareTo(this.m)>=0&&e.subTo(this.m,e)}function montSqrTo(e,t){e.squareTo(t),this.reduce(t)}function montMulTo(e,t,n){e.multiplyTo(t,n),this.reduce(n)}function bnpIsEven(){return(this.t>0?this[0]&1:this.s)==0}function bnpExp(e,t){if(e>4294967295||e<1)return BigInteger.ONE;var n=nbi(),r=nbi(),i=t.convert(this),s=nbits(e)-1;i.copyTo(n);while(--s>=0){t.sqrTo(n,r);if((e&1<<s)>0)t.mulTo(r,i,n);else{var o=n;n=r,r=o}}return t.revert(n)}function bnModPowInt(e,t){var n;return e<256||t.isEven()?n=new Classic(t):n=new Montgomery(t),this.exp(e,n)}var dbits,canary=0xdeadbeefcafe,j_lm=(canary&16777215)==15715070;j_lm&&navigator.appName=="Microsoft Internet Explorer"?(BigInteger.prototype.am=am2,dbits=30):j_lm&&navigator.appName!="Netscape"?(BigInteger.prototype.am=am1,dbits=26):(BigInteger.prototype.am=am3,dbits=28),BigInteger.prototype.DB=dbits,BigInteger.prototype.DM=(1<<dbits)-1,BigInteger.prototype.DV=1<<dbits;var BI_FP=52;BigInteger.prototype.FV=Math.pow(2,BI_FP),BigInteger.prototype.F1=BI_FP-dbits,BigInteger.prototype.F2=2*dbits-BI_FP;var BI_RM="0123456789abcdefghijklmnopqrstuvwxyz",BI_RC=new Array,rr,vv;rr="0".charCodeAt(0);for(vv=0;vv<=9;++vv)BI_RC[rr++]=vv;rr="a".charCodeAt(0);for(vv=10;vv<36;++vv)BI_RC[rr++]=vv;rr="A".charCodeAt(0);for(vv=10;vv<36;++vv)BI_RC[rr++]=vv;Classic.prototype.convert=cConvert,Classic.prototype.revert=cRevert,Classic.prototype.reduce=cReduce,Classic.prototype.mulTo=cMulTo,Classic.prototype.sqrTo=cSqrTo,Montgomery.prototype.convert=montConvert,Montgomery.prototype.revert=montRevert,Montgomery.prototype.reduce=montReduce,Montgomery.prototype.mulTo=montMulTo,Montgomery.prototype.sqrTo=montSqrTo,BigInteger.prototype.copyTo=bnpCopyTo,BigInteger.prototype.fromInt=bnpFromInt,BigInteger.prototype.fromString=bnpFromString,BigInteger.prototype.clamp=bnpClamp,BigInteger.prototype.dlShiftTo=bnpDLShiftTo,BigInteger.prototype.drShiftTo=bnpDRShiftTo,BigInteger.prototype.lShiftTo=bnpLShiftTo,BigInteger.prototype.rShiftTo=bnpRShiftTo,BigInteger.prototype.subTo=bnpSubTo,BigInteger.prototype.multiplyTo=bnpMultiplyTo,BigInteger.prototype.squareTo=bnpSquareTo,BigInteger.prototype.divRemTo=bnpDivRemTo,BigInteger.prototype.invDigit=bnpInvDigit,BigInteger.prototype.isEven=bnpIsEven,BigInteger.prototype.exp=bnpExp,BigInteger.prototype.toString=bnToString,BigInteger.prototype.negate=bnNegate,BigInteger.prototype.abs=bnAbs,BigInteger.prototype.compareTo=bnCompareTo,BigInteger.prototype.bitLength=bnBitLength,BigInteger.prototype.mod=bnMod,BigInteger.prototype.modPowInt=bnModPowInt,BigInteger.ZERO=nbv(0),BigInteger.ONE=nbv(1);
function bnClone(){var e=nbi();return this.copyTo(e),e}function bnIntValue(){if(this.s<0){if(this.t==1)return this[0]-this.DV;if(this.t==0)return-1}else{if(this.t==1)return this[0];if(this.t==0)return 0}return(this[1]&(1<<32-this.DB)-1)<<this.DB|this[0]}function bnByteValue(){return this.t==0?this.s:this[0]<<24>>24}function bnShortValue(){return this.t==0?this.s:this[0]<<16>>16}function bnpChunkSize(e){return Math.floor(Math.LN2*this.DB/Math.log(e))}function bnSigNum(){return this.s<0?-1:this.t<=0||this.t==1&&this[0]<=0?0:1}function bnpToRadix(e){e==null&&(e=10);if(this.signum()==0||e<2||e>36)return"0";var t=this.chunkSize(e),n=Math.pow(e,t),r=nbv(n),i=nbi(),s=nbi(),o="";this.divRemTo(r,i,s);while(i.signum()>0)o=(n+s.intValue()).toString(e).substr(1)+o,i.divRemTo(r,i,s);return s.intValue().toString(e)+o}function bnpFromRadix(e,t){this.fromInt(0),t==null&&(t=10);var n=this.chunkSize(t),r=Math.pow(t,n),i=!1,s=0,o=0;for(var u=0;u<e.length;++u){var a=intAt(e,u);if(a<0){e.charAt(u)=="-"&&this.signum()==0&&(i=!0);continue}o=t*o+a,++s>=n&&(this.dMultiply(r),this.dAddOffset(o,0),s=0,o=0)}s>0&&(this.dMultiply(Math.pow(t,s)),this.dAddOffset(o,0)),i&&BigInteger.ZERO.subTo(this,this)}function bnpFromNumber(e,t,n){if("number"==typeof t)if(e<2)this.fromInt(1);else{this.fromNumber(e,n),this.testBit(e-1)||this.bitwiseTo(BigInteger.ONE.shiftLeft(e-1),op_or,this),this.isEven()&&this.dAddOffset(1,0);while(!this.isProbablePrime(t))this.dAddOffset(2,0),this.bitLength()>e&&this.subTo(BigInteger.ONE.shiftLeft(e-1),this)}else{var r=new Array,i=e&7;r.length=(e>>3)+1,t.nextBytes(r),i>0?r[0]&=(1<<i)-1:r[0]=0,this.fromString(r,256)}}function bnToByteArray(){var e=this.t,t=new Array;t[0]=this.s;var n=this.DB-e*this.DB%8,r,i=0;if(e-->0){n<this.DB&&(r=this[e]>>n)!=(this.s&this.DM)>>n&&(t[i++]=r|this.s<<this.DB-n);while(e>=0){n<8?(r=(this[e]&(1<<n)-1)<<8-n,r|=this[--e]>>(n+=this.DB-8)):(r=this[e]>>(n-=8)&255,n<=0&&(n+=this.DB,--e)),(r&128)!=0&&(r|=-256),i==0&&(this.s&128)!=(r&128)&&++i;if(i>0||r!=this.s)t[i++]=r}}return t}function bnEquals(e){return this.compareTo(e)==0}function bnMin(e){return this.compareTo(e)<0?this:e}function bnMax(e){return this.compareTo(e)>0?this:e}function bnpBitwiseTo(e,t,n){var r,i,s=Math.min(e.t,this.t);for(r=0;r<s;++r)n[r]=t(this[r],e[r]);if(e.t<this.t){i=e.s&this.DM;for(r=s;r<this.t;++r)n[r]=t(this[r],i);n.t=this.t}else{i=this.s&this.DM;for(r=s;r<e.t;++r)n[r]=t(i,e[r]);n.t=e.t}n.s=t(this.s,e.s),n.clamp()}function op_and(e,t){return e&t}function bnAnd(e){var t=nbi();return this.bitwiseTo(e,op_and,t),t}function op_or(e,t){return e|t}function bnOr(e){var t=nbi();return this.bitwiseTo(e,op_or,t),t}function op_xor(e,t){return e^t}function bnXor(e){var t=nbi();return this.bitwiseTo(e,op_xor,t),t}function op_andnot(e,t){return e&~t}function bnAndNot(e){var t=nbi();return this.bitwiseTo(e,op_andnot,t),t}function bnNot(){var e=nbi();for(var t=0;t<this.t;++t)e[t]=this.DM&~this[t];return e.t=this.t,e.s=~this.s,e}function bnShiftLeft(e){var t=nbi();return e<0?this.rShiftTo(-e,t):this.lShiftTo(e,t),t}function bnShiftRight(e){var t=nbi();return e<0?this.lShiftTo(-e,t):this.rShiftTo(e,t),t}function lbit(e){if(e==0)return-1;var t=0;return(e&65535)==0&&(e>>=16,t+=16),(e&255)==0&&(e>>=8,t+=8),(e&15)==0&&(e>>=4,t+=4),(e&3)==0&&(e>>=2,t+=2),(e&1)==0&&++t,t}function bnGetLowestSetBit(){for(var e=0;e<this.t;++e)if(this[e]!=0)return e*this.DB+lbit(this[e]);return this.s<0?this.t*this.DB:-1}function cbit(e){var t=0;while(e!=0)e&=e-1,++t;return t}function bnBitCount(){var e=0,t=this.s&this.DM;for(var n=0;n<this.t;++n)e+=cbit(this[n]^t);return e}function bnTestBit(e){var t=Math.floor(e/this.DB);return t>=this.t?this.s!=0:(this[t]&1<<e%this.DB)!=0}function bnpChangeBit(e,t){var n=BigInteger.ONE.shiftLeft(e);return this.bitwiseTo(n,t,n),n}function bnSetBit(e){return this.changeBit(e,op_or)}function bnClearBit(e){return this.changeBit(e,op_andnot)}function bnFlipBit(e){return this.changeBit(e,op_xor)}function bnpAddTo(e,t){var n=0,r=0,i=Math.min(e.t,this.t);while(n<i)r+=this[n]+e[n],t[n++]=r&this.DM,r>>=this.DB;if(e.t<this.t){r+=e.s;while(n<this.t)r+=this[n],t[n++]=r&this.DM,r>>=this.DB;r+=this.s}else{r+=this.s;while(n<e.t)r+=e[n],t[n++]=r&this.DM,r>>=this.DB;r+=e.s}t.s=r<0?-1:0,r>0?t[n++]=r:r<-1&&(t[n++]=this.DV+r),t.t=n,t.clamp()}function bnAdd(e){var t=nbi();return this.addTo(e,t),t}function bnSubtract(e){var t=nbi();return this.subTo(e,t),t}function bnMultiply(e){var t=nbi();return this.multiplyTo(e,t),t}function bnSquare(){var e=nbi();return this.squareTo(e),e}function bnDivide(e){var t=nbi();return this.divRemTo(e,t,null),t}function bnRemainder(e){var t=nbi();return this.divRemTo(e,null,t),t}function bnDivideAndRemainder(e){var t=nbi(),n=nbi();return this.divRemTo(e,t,n),new Array(t,n)}function bnpDMultiply(e){this[this.t]=this.am(0,e-1,this,0,0,this.t),++this.t,this.clamp()}function bnpDAddOffset(e,t){if(e==0)return;while(this.t<=t)this[this.t++]=0;this[t]+=e;while(this[t]>=this.DV)this[t]-=this.DV,++t>=this.t&&(this[this.t++]=0),++this[t]}function NullExp(){}function nNop(e){return e}function nMulTo(e,t,n){e.multiplyTo(t,n)}function nSqrTo(e,t){e.squareTo(t)}function bnPow(e){return this.exp(e,new NullExp)}function bnpMultiplyLowerTo(e,t,n){var r=Math.min(this.t+e.t,t);n.s=0,n.t=r;while(r>0)n[--r]=0;var i;for(i=n.t-this.t;r<i;++r)n[r+this.t]=this.am(0,e[r],n,r,0,this.t);for(i=Math.min(e.t,t);r<i;++r)this.am(0,e[r],n,r,0,t-r);n.clamp()}function bnpMultiplyUpperTo(e,t,n){--t;var r=n.t=this.t+e.t-t;n.s=0;while(--r>=0)n[r]=0;for(r=Math.max(t-this.t,0);r<e.t;++r)n[this.t+r-t]=this.am(t-r,e[r],n,0,0,this.t+r-t);n.clamp(),n.drShiftTo(1,n)}function Barrett(e){this.r2=nbi(),this.q3=nbi(),BigInteger.ONE.dlShiftTo(2*e.t,this.r2),this.mu=this.r2.divide(e),this.m=e}function barrettConvert(e){if(e.s<0||e.t>2*this.m.t)return e.mod(this.m);if(e.compareTo(this.m)<0)return e;var t=nbi();return e.copyTo(t),this.reduce(t),t}function barrettRevert(e){return e}function barrettReduce(e){e.drShiftTo(this.m.t-1,this.r2),e.t>this.m.t+1&&(e.t=this.m.t+1,e.clamp()),this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3),this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);while(e.compareTo(this.r2)<0)e.dAddOffset(1,this.m.t+1);e.subTo(this.r2,e);while(e.compareTo(this.m)>=0)e.subTo(this.m,e)}function barrettSqrTo(e,t){e.squareTo(t),this.reduce(t)}function barrettMulTo(e,t,n){e.multiplyTo(t,n),this.reduce(n)}function bnModPow(e,t){var n=e.bitLength(),r,i=nbv(1),s;if(n<=0)return i;n<18?r=1:n<48?r=3:n<144?r=4:n<768?r=5:r=6,n<8?s=new Classic(t):t.isEven()?s=new Barrett(t):s=new Montgomery(t);var o=new Array,u=3,a=r-1,f=(1<<r)-1;o[1]=s.convert(this);if(r>1){var l=nbi();s.sqrTo(o[1],l);while(u<=f)o[u]=nbi(),s.mulTo(l,o[u-2],o[u]),u+=2}var c=e.t-1,h,p=!0,d=nbi(),v;n=nbits(e[c])-1;while(c>=0){n>=a?h=e[c]>>n-a&f:(h=(e[c]&(1<<n+1)-1)<<a-n,c>0&&(h|=e[c-1]>>this.DB+n-a)),u=r;while((h&1)==0)h>>=1,--u;(n-=u)<0&&(n+=this.DB,--c);if(p)o[h].copyTo(i),p=!1;else{while(u>1)s.sqrTo(i,d),s.sqrTo(d,i),u-=2;u>0?s.sqrTo(i,d):(v=i,i=d,d=v),s.mulTo(d,o[h],i)}while(c>=0&&(e[c]&1<<n)==0)s.sqrTo(i,d),v=i,i=d,d=v,--n<0&&(n=this.DB-1,--c)}return s.revert(i)}function bnGCD(e){var t=this.s<0?this.negate():this.clone(),n=e.s<0?e.negate():e.clone();if(t.compareTo(n)<0){var r=t;t=n,n=r}var i=t.getLowestSetBit(),s=n.getLowestSetBit();if(s<0)return t;i<s&&(s=i),s>0&&(t.rShiftTo(s,t),n.rShiftTo(s,n));while(t.signum()>0)(i=t.getLowestSetBit())>0&&t.rShiftTo(i,t),(i=n.getLowestSetBit())>0&&n.rShiftTo(i,n),t.compareTo(n)>=0?(t.subTo(n,t),t.rShiftTo(1,t)):(n.subTo(t,n),n.rShiftTo(1,n));return s>0&&n.lShiftTo(s,n),n}function bnpModInt(e){if(e<=0)return 0;var t=this.DV%e,n=this.s<0?e-1:0;if(this.t>0)if(t==0)n=this[0]%e;else for(var r=this.t-1;r>=0;--r)n=(t*n+this[r])%e;return n}function bnModInverse(e){var t=e.isEven();if(this.isEven()&&t||e.signum()==0)return BigInteger.ZERO;var n=e.clone(),r=this.clone(),i=nbv(1),s=nbv(0),o=nbv(0),u=nbv(1);while(n.signum()!=0){while(n.isEven()){n.rShiftTo(1,n);if(t){if(!i.isEven()||!s.isEven())i.addTo(this,i),s.subTo(e,s);i.rShiftTo(1,i)}else s.isEven()||s.subTo(e,s);s.rShiftTo(1,s)}while(r.isEven()){r.rShiftTo(1,r);if(t){if(!o.isEven()||!u.isEven())o.addTo(this,o),u.subTo(e,u);o.rShiftTo(1,o)}else u.isEven()||u.subTo(e,u);u.rShiftTo(1,u)}n.compareTo(r)>=0?(n.subTo(r,n),t&&i.subTo(o,i),s.subTo(u,s)):(r.subTo(n,r),t&&o.subTo(i,o),u.subTo(s,u))}return r.compareTo(BigInteger.ONE)!=0?BigInteger.ZERO:u.compareTo(e)>=0?u.subtract(e):u.signum()<0?(u.addTo(e,u),u.signum()<0?u.add(e):u):u}function bnIsProbablePrime(e){var t,n=this.abs();if(n.t==1&&n[0]<=lowprimes[lowprimes.length-1]){for(t=0;t<lowprimes.length;++t)if(n[0]==lowprimes[t])return!0;return!1}if(n.isEven())return!1;t=1;while(t<lowprimes.length){var r=lowprimes[t],i=t+1;while(i<lowprimes.length&&r<lplim)r*=lowprimes[i++];r=n.modInt(r);while(t<i)if(r%lowprimes[t++]==0)return!1}return n.millerRabin(e)}function bnpMillerRabin(e){var t=this.subtract(BigInteger.ONE),n=t.getLowestSetBit();if(n<=0)return!1;var r=t.shiftRight(n);e=e+1>>1,e>lowprimes.length&&(e=lowprimes.length);var i=nbi();for(var s=0;s<e;++s){i.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);var o=i.modPow(r,this);if(o.compareTo(BigInteger.ONE)!=0&&o.compareTo(t)!=0){var u=1;while(u++<n&&o.compareTo(t)!=0){o=o.modPowInt(2,this);if(o.compareTo(BigInteger.ONE)==0)return!1}if(o.compareTo(t)!=0)return!1}}return!0}NullExp.prototype.convert=nNop,NullExp.prototype.revert=nNop,NullExp.prototype.mulTo=nMulTo,NullExp.prototype.sqrTo=nSqrTo,Barrett.prototype.convert=barrettConvert,Barrett.prototype.revert=barrettRevert,Barrett.prototype.reduce=barrettReduce,Barrett.prototype.mulTo=barrettMulTo,Barrett.prototype.sqrTo=barrettSqrTo;var lowprimes=[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997],lplim=(1<<26)/lowprimes[lowprimes.length-1];BigInteger.prototype.chunkSize=bnpChunkSize,BigInteger.prototype.toRadix=bnpToRadix,BigInteger.prototype.fromRadix=bnpFromRadix,BigInteger.prototype.fromNumber=bnpFromNumber,BigInteger.prototype.bitwiseTo=bnpBitwiseTo,BigInteger.prototype.changeBit=bnpChangeBit,BigInteger.prototype.addTo=bnpAddTo,BigInteger.prototype.dMultiply=bnpDMultiply,BigInteger.prototype.dAddOffset=bnpDAddOffset,BigInteger.prototype.multiplyLowerTo=bnpMultiplyLowerTo,BigInteger.prototype.multiplyUpperTo=bnpMultiplyUpperTo,BigInteger.prototype.modInt=bnpModInt,BigInteger.prototype.millerRabin=bnpMillerRabin,BigInteger.prototype.clone=bnClone,BigInteger.prototype.intValue=bnIntValue,BigInteger.prototype.byteValue=bnByteValue,BigInteger.prototype.shortValue=bnShortValue,BigInteger.prototype.signum=bnSigNum,BigInteger.prototype.toByteArray=bnToByteArray,BigInteger.prototype.equals=bnEquals,BigInteger.prototype.min=bnMin,BigInteger.prototype.max=bnMax,BigInteger.prototype.and=bnAnd,BigInteger.prototype.or=bnOr,BigInteger.prototype.xor=bnXor,BigInteger.prototype.andNot=bnAndNot,BigInteger.prototype.not=bnNot,BigInteger.prototype.shiftLeft=bnShiftLeft,BigInteger.prototype.shiftRight=bnShiftRight,BigInteger.prototype.getLowestSetBit=bnGetLowestSetBit,BigInteger.prototype.bitCount=bnBitCount,BigInteger.prototype.testBit=bnTestBit,BigInteger.prototype.setBit=bnSetBit,BigInteger.prototype.clearBit=bnClearBit,BigInteger.prototype.flipBit=bnFlipBit,BigInteger.prototype.add=bnAdd,BigInteger.prototype.subtract=bnSubtract,BigInteger.prototype.multiply=bnMultiply,BigInteger.prototype.divide=bnDivide,BigInteger.prototype.remainder=bnRemainder,BigInteger.prototype.divideAndRemainder=bnDivideAndRemainder,BigInteger.prototype.modPow=bnModPow,BigInteger.prototype.modInverse=bnModInverse,BigInteger.prototype.pow=bnPow,BigInteger.prototype.gcd=bnGCD,BigInteger.prototype.isProbablePrime=bnIsProbablePrime,BigInteger.prototype.square=bnSquare;
function ECFieldElementFp(e,t){this.x=t,this.q=e}function feFpEquals(e){return e==this?!0:this.q.equals(e.q)&&this.x.equals(e.x)}function feFpToBigInteger(){return this.x}function feFpNegate(){return new ECFieldElementFp(this.q,this.x.negate().mod(this.q))}function feFpAdd(e){return new ECFieldElementFp(this.q,this.x.add(e.toBigInteger()).mod(this.q))}function feFpSubtract(e){return new ECFieldElementFp(this.q,this.x.subtract(e.toBigInteger()).mod(this.q))}function feFpMultiply(e){return new ECFieldElementFp(this.q,this.x.multiply(e.toBigInteger()).mod(this.q))}function feFpSquare(){return new ECFieldElementFp(this.q,this.x.square().mod(this.q))}function feFpDivide(e){return new ECFieldElementFp(this.q,this.x.multiply(e.toBigInteger().modInverse(this.q)).mod(this.q))}function ECPointFp(e,t,n,r){this.curve=e,this.x=t,this.y=n,r==null?this.z=BigInteger.ONE:this.z=r,this.zinv=null}function pointFpGetX(){return this.zinv==null&&(this.zinv=this.z.modInverse(this.curve.q)),this.curve.fromBigInteger(this.x.toBigInteger().multiply(this.zinv).mod(this.curve.q))}function pointFpGetY(){return this.zinv==null&&(this.zinv=this.z.modInverse(this.curve.q)),this.curve.fromBigInteger(this.y.toBigInteger().multiply(this.zinv).mod(this.curve.q))}function pointFpEquals(e){if(e==this)return!0;if(this.isInfinity())return e.isInfinity();if(e.isInfinity())return this.isInfinity();var t,n;return t=e.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(e.z)).mod(this.curve.q),t.equals(BigInteger.ZERO)?(n=e.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(e.z)).mod(this.curve.q),n.equals(BigInteger.ZERO)):!1}function pointFpIsInfinity(){return this.x==null&&this.y==null?!0:this.z.equals(BigInteger.ZERO)&&!this.y.toBigInteger().equals(BigInteger.ZERO)}function pointFpNegate(){return new ECPointFp(this.curve,this.x,this.y.negate(),this.z)}function pointFpAdd(e){if(this.isInfinity())return e;if(e.isInfinity())return this;var t=e.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(e.z)).mod(this.curve.q),n=e.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(e.z)).mod(this.curve.q);if(BigInteger.ZERO.equals(n))return BigInteger.ZERO.equals(t)?this.twice():this.curve.getInfinity();var r=new BigInteger("3"),i=this.x.toBigInteger(),s=this.y.toBigInteger(),o=e.x.toBigInteger(),u=e.y.toBigInteger(),a=n.square(),f=a.multiply(n),l=i.multiply(a),c=t.square().multiply(this.z),h=c.subtract(l.shiftLeft(1)).multiply(e.z).subtract(f).multiply(n).mod(this.curve.q),p=l.multiply(r).multiply(t).subtract(s.multiply(f)).subtract(c.multiply(t)).multiply(e.z).add(t.multiply(f)).mod(this.curve.q),d=f.multiply(this.z).multiply(e.z).mod(this.curve.q);return new ECPointFp(this.curve,this.curve.fromBigInteger(h),this.curve.fromBigInteger(p),d)}function pointFpTwice(){if(this.isInfinity())return this;if(this.y.toBigInteger().signum()==0)return this.curve.getInfinity();var e=new BigInteger("3"),t=this.x.toBigInteger(),n=this.y.toBigInteger(),r=n.multiply(this.z),i=r.multiply(n).mod(this.curve.q),s=this.curve.a.toBigInteger(),o=t.square().multiply(e);BigInteger.ZERO.equals(s)||(o=o.add(this.z.square().multiply(s))),o=o.mod(this.curve.q);var u=o.square().subtract(t.shiftLeft(3).multiply(i)).shiftLeft(1).multiply(r).mod(this.curve.q),a=o.multiply(e).multiply(t).subtract(i.shiftLeft(1)).shiftLeft(2).multiply(i).subtract(o.square().multiply(o)).mod(this.curve.q),f=r.square().multiply(r).shiftLeft(3).mod(this.curve.q);return new ECPointFp(this.curve,this.curve.fromBigInteger(u),this.curve.fromBigInteger(a),f)}function pointFpMultiply(e){if(this.isInfinity())return this;if(e.signum()==0)return this.curve.getInfinity();var t=e,n=t.multiply(new BigInteger("3")),r=this.negate(),i=this,s;for(s=n.bitLength()-2;s>0;--s){i=i.twice();var o=n.testBit(s),u=t.testBit(s);o!=u&&(i=i.add(o?this:r))}return i}function pointFpMultiplyTwo(e,t,n){var r;e.bitLength()>n.bitLength()?r=e.bitLength()-1:r=n.bitLength()-1;var i=this.curve.getInfinity(),s=this.add(t);while(r>=0)i=i.twice(),e.testBit(r)?n.testBit(r)?i=i.add(s):i=i.add(this):n.testBit(r)&&(i=i.add(t)),--r;return i}function ECCurveFp(e,t,n){this.q=e,this.a=this.fromBigInteger(t),this.b=this.fromBigInteger(n),this.infinity=new ECPointFp(this,null,null)}function curveFpGetQ(){return this.q}function curveFpGetA(){return this.a}function curveFpGetB(){return this.b}function curveFpEquals(e){return e==this?!0:this.q.equals(e.q)&&this.a.equals(e.a)&&this.b.equals(e.b)}function curveFpGetInfinity(){return this.infinity}function curveFpFromBigInteger(e){return new ECFieldElementFp(this.q,e)}function curveFpDecodePointHex(e){switch(parseInt(e.substr(0,2),16)){case 0:return this.infinity;case 2:case 3:return null;case 4:case 6:case 7:var t=(e.length-2)/2,n=e.substr(2,t),r=e.substr(t+2,t);return new ECPointFp(this,this.fromBigInteger(new BigInteger(n,16)),this.fromBigInteger(new BigInteger(r,16)));default:return null}}ECFieldElementFp.prototype.equals=feFpEquals,ECFieldElementFp.prototype.toBigInteger=feFpToBigInteger,ECFieldElementFp.prototype.negate=feFpNegate,ECFieldElementFp.prototype.add=feFpAdd,ECFieldElementFp.prototype.subtract=feFpSubtract,ECFieldElementFp.prototype.multiply=feFpMultiply,ECFieldElementFp.prototype.square=feFpSquare,ECFieldElementFp.prototype.divide=feFpDivide,ECPointFp.prototype.getX=pointFpGetX,ECPointFp.prototype.getY=pointFpGetY,ECPointFp.prototype.equals=pointFpEquals,ECPointFp.prototype.isInfinity=pointFpIsInfinity,ECPointFp.prototype.negate=pointFpNegate,ECPointFp.prototype.add=pointFpAdd,ECPointFp.prototype.twice=pointFpTwice,ECPointFp.prototype.multiply=pointFpMultiply,ECPointFp.prototype.multiplyTwo=pointFpMultiplyTwo,ECCurveFp.prototype.getQ=curveFpGetQ,ECCurveFp.prototype.getA=curveFpGetA,ECCurveFp.prototype.getB=curveFpGetB,ECCurveFp.prototype.equals=curveFpEquals,ECCurveFp.prototype.getInfinity=curveFpGetInfinity,ECCurveFp.prototype.fromBigInteger=curveFpFromBigInteger,ECCurveFp.prototype.decodePointHex=curveFpDecodePointHex;
function X9ECParameters(e,t,n,r){this.curve=e,this.g=t,this.n=n,this.h=r}function x9getCurve(){return this.curve}function x9getG(){return this.g}function x9getN(){return this.n}function x9getH(){return this.h}function fromHex(e){return new BigInteger(e,16)}function secp128r1(){var e=fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF"),t=fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFC"),n=fromHex("E87579C11079F43DD824993C2CEE5ED3"),r=fromHex("FFFFFFFE0000000075A30D1B9038A115"),i=BigInteger.ONE,s=new ECCurveFp(e,t,n),o=s.decodePointHex("04161FF7528B899B2D0C28607CA52C5B86CF5AC8395BAFEB13C02DA292DDED7A83");return new X9ECParameters(s,o,r,i)}function secp160k1(){var e=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73"),t=BigInteger.ZERO,n=fromHex("7"),r=fromHex("0100000000000000000001B8FA16DFAB9ACA16B6B3"),i=BigInteger.ONE,s=new ECCurveFp(e,t,n),o=s.decodePointHex("043B4C382CE37AA192A4019E763036F4F5DD4D7EBB938CF935318FDCED6BC28286531733C3F03C4FEE");return new X9ECParameters(s,o,r,i)}function secp160r1(){var e=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF"),t=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC"),n=fromHex("1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45"),r=fromHex("0100000000000000000001F4C8F927AED3CA752257"),i=BigInteger.ONE,s=new ECCurveFp(e,t,n),o=s.decodePointHex("044A96B5688EF573284664698968C38BB913CBFC8223A628553168947D59DCC912042351377AC5FB32");return new X9ECParameters(s,o,r,i)}function secp192k1(){var e=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFEE37"),t=BigInteger.ZERO,n=fromHex("3"),r=fromHex("FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D"),i=BigInteger.ONE,s=new ECCurveFp(e,t,n),o=s.decodePointHex("04DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D");return new X9ECParameters(s,o,r,i)}function secp192r1(){var e=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF"),t=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC"),n=fromHex("64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1"),r=fromHex("FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831"),i=BigInteger.ONE,s=new ECCurveFp(e,t,n),o=s.decodePointHex("04188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF101207192B95FFC8DA78631011ED6B24CDD573F977A11E794811");return new X9ECParameters(s,o,r,i)}function secp224r1(){var e=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001"),t=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE"),n=fromHex("B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4"),r=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D"),i=BigInteger.ONE,s=new ECCurveFp(e,t,n),o=s.decodePointHex("04B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34");return new X9ECParameters(s,o,r,i)}function secp256k1(){var e=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F"),t=BigInteger.ZERO,n=fromHex("7"),r=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141"),i=BigInteger.ONE,s=new ECCurveFp(e,t,n),o=s.decodePointHex("0479BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8");return new X9ECParameters(s,o,r,i)}function secp256r1(){var e=fromHex("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF"),t=fromHex("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC"),n=fromHex("5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B"),r=fromHex("FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551"),i=BigInteger.ONE,s=new ECCurveFp(e,t,n),o=s.decodePointHex("046B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C2964FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5");return new X9ECParameters(s,o,r,i)}function getSECCurveByName(e){return e=="secp128r1"?secp128r1():e=="secp160k1"?secp160k1():e=="secp160r1"?secp160r1():e=="secp192k1"?secp192k1():e=="secp192r1"?secp192r1():e=="secp224r1"?secp224r1():e=="secp256k1"?secp256k1():e=="secp256r1"?secp256r1():null}X9ECParameters.prototype.getCurve=x9getCurve,X9ECParameters.prototype.getG=x9getG,X9ECParameters.prototype.getN=x9getN,X9ECParameters.prototype.getH=x9getH;
var EventEmitter=function(){};EventEmitter.prototype.on=function(e,t,n){n||(n=this),this._listeners||(this._listeners={}),this._listeners[e]||(this._listeners[e]=[]),this._unbinders||(this._unbinders={}),this._unbinders[e]||(this._unbinders[e]=[]);var r=function(e){t.apply(n,[e])};this._unbinders[e].push(t),this._listeners[e].push(r)},EventEmitter.prototype.trigger=function(e,t){t===undefined&&(t={}),this._listeners||(this._listeners={});if(!this._listeners[e])return;var n=this._listeners[e].length;while(n--)this._listeners[e][n](t)},EventEmitter.prototype.removeListener=function(e,t){this._unbinders||(this._unbinders={});if(!this._unbinders[e])return;var n=this._unbinders[e].length;while(n--)this._unbinders[e][n]===t&&(this._unbinders[e].splice(n,1),this._listeners[e].splice(n,1))},EventEmitter.augment=function(e){for(var t in EventEmitter.prototype)e[t]||(e[t]=EventEmitter.prototype[t])};
(function(e){var t=e;"object"!=typeof module&&(t.EventEmitter=EventEmitter)})("object"==typeof module?module.exports:window.Bitcoin={});
BigInteger.valueOf=nbv,BigInteger.prototype.toByteArrayUnsigned=function(){var e=this.abs().toByteArray();return e.length?(e[0]==0&&(e=e.slice(1)),e.map(function(e){return e<0?e+256:e})):e},BigInteger.fromByteArrayUnsigned=function(e){return e.length?e[0]&128?new BigInteger([0].concat(e)):new BigInteger(e):e.valueOf(0)},BigInteger.prototype.toByteArraySigned=function(){var e=this.abs().toByteArrayUnsigned(),t=this.compareTo(BigInteger.ZERO)<0;return t?e[0]&128?e.unshift(128):e[0]|=128:e[0]&128&&e.unshift(0),e},BigInteger.fromByteArraySigned=function(e){return e[0]&128?(e[0]&=127,BigInteger.fromByteArrayUnsigned(e).negate()):BigInteger.fromByteArrayUnsigned(e)};var names=["log","debug","info","warn","error","assert","dir","dirxml","group","groupEnd","time","timeEnd","count","trace","profile","profileEnd"];"undefined"==typeof window.console&&(window.console={});for(var i=0;i<names.length;++i)"undefined"==typeof window.console[names[i]]&&(window.console[names[i]]=function(){});Bitcoin.Util={isArray:Array.isArray||function(e){return Object.prototype.toString.call(e)==="[object Array]"},makeFilledArray:function(e,t){var n=[],r=0;while(r<e)n[r++]=t;return n},numToVarInt:function(e){return e<253?[e]:e<=65536?[253,e&255,e>>>8]:e<=1?[254].concat(Crypto.util.wordsToBytes([e])):[255].concat(Crypto.util.wordsToBytes([e>>>32,e]))},valueToBigInt:function(e){return e instanceof BigInteger?e:BigInteger.fromByteArrayUnsigned(e)},formatValue:function(e){var t=this.valueToBigInt(e).toString(),n=t.length>8?t.substr(0,t.length-8):"0",r=t.length>8?t.substr(t.length-8):t;while(r.length<8)r="0"+r;r=r.replace(/0*$/,"");while(r.length<2)r+="0";return n+"."+r},parseValue:function(e){var t=e.split("."),n=t[0],r=t[1]||"0";while(r.length<8)r+="0";r=r.replace(/^0+/g,"");var i=BigInteger.valueOf(parseInt(n));return i=i.multiply(BigInteger.valueOf(1e8)),i=i.add(BigInteger.valueOf(parseInt(r))),i},sha256ripe160:function(e){return Crypto.RIPEMD160(Crypto.SHA256(e,{asBytes:!0}),{asBytes:!0})}};for(var i in Crypto.util)Crypto.util.hasOwnProperty(i)&&(Bitcoin.Util[i]=Crypto.util[i]);
(function(e){e.Base58={alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",validRegex:/^[1-9A-HJ-NP-Za-km-z]+$/,base:BigInteger.valueOf(58),encode:function(e){var n=BigInteger.fromByteArrayUnsigned(e),r=[];while(n.compareTo(t.base)>=0){var i=n.mod(t.base);r.unshift(t.alphabet[i.intValue()]),n=n.subtract(i).divide(t.base)}r.unshift(t.alphabet[n.intValue()]);for(var s=0;s<e.length;s++){if(e[s]!=0)break;r.unshift(t.alphabet[0])}return r.join("")},decode:function(e){var n=BigInteger.valueOf(0),r=0;for(var i=e.length-1;i>=0;i--){var s=t.alphabet.indexOf(e[i]);if(s<0)throw"Invalid character";n=n.add(BigInteger.valueOf(s).multiply(t.base.pow(e.length-1-i))),e[i]=="1"?r++:r=0}var o=n.toByteArrayUnsigned();while(r-->0)o.unshift(0);return o}};var t=e.Base58})("undefined"!=typeof Bitcoin?Bitcoin:module.exports);
Bitcoin.Address=function(e){"string"==typeof e&&(e=Bitcoin.Address.decodeString(e));this.hash=e['hash']||e;this.version=e['version']||0;},Bitcoin.Address.prototype.toString=function(){var e=this.hash.slice(0);e.unshift(this.version);var t=Crypto.SHA256(Crypto.SHA256(e,{asBytes:!0}),{asBytes:!0}),n=e.concat(t.slice(0,4));return Bitcoin.Base58.encode(n)},Bitcoin.Address.prototype.getHashBase64=function(){return Crypto.util.bytesToBase64(this.hash)},Bitcoin.Address.decodeString=function(e){var t=Bitcoin.Base58.decode(e); n=t.slice(0,21),r=Crypto.SHA256(Crypto.SHA256(n,{asBytes:!0}),{asBytes:!0});if(r[0]!=t[21]||r[1]!=t[22]||r[2]!=t[23]||r[3]!=t[24])throw"Checksum validation failed!";var i=n.shift();if(i!=0 && i!=5)throw"Version "+i+" not supported."; return {'hash':n,'version':i}};
function integerToBytes(e,t){var n=e.toByteArrayUnsigned();if(t<n.length)n=n.slice(n.length-t);else while(t>n.length)n.unshift(0);return n}function dmp(e){return e instanceof BigInteger||(e=e.toBigInteger()),Crypto.util.bytesToHex(e.toByteArrayUnsigned())}ECFieldElementFp.prototype.getByteLength=function(){return Math.floor((this.toBigInteger().bitLength()+7)/8)},ECPointFp.prototype.getEncoded=function(e){var t=this.getX().toBigInteger(),n=this.getY().toBigInteger(),r=integerToBytes(t,32);return e?n.isEven()?r.unshift(2):r.unshift(3):(r.unshift(4),r=r.concat(integerToBytes(n,32))),r},ECPointFp.decodeFrom=function(e,t){var n=t[0],r=t.length-1,i=t.slice(1,1+r/2),s=t.slice(1+r/2,1+r);i.unshift(0),s.unshift(0);var o=new BigInteger(i),u=new BigInteger(s);return new ECPointFp(e,e.fromBigInteger(o),e.fromBigInteger(u))},ECPointFp.prototype.add2D=function(e){if(this.isInfinity())return e;if(e.isInfinity())return this;if(this.x.equals(e.x))return this.y.equals(e.y)?this.twice():this.curve.getInfinity();var t=e.x.subtract(this.x),n=e.y.subtract(this.y),r=n.divide(t),i=r.square().subtract(this.x).subtract(e.x),s=r.multiply(this.x.subtract(i)).subtract(this.y);return new ECPointFp(this.curve,i,s)},ECPointFp.prototype.twice2D=function(){if(this.isInfinity())return this;if(this.y.toBigInteger().signum()==0)return this.curve.getInfinity();var e=this.curve.fromBigInteger(BigInteger.valueOf(2)),t=this.curve.fromBigInteger(BigInteger.valueOf(3)),n=this.x.square().multiply(t).add(this.curve.a).divide(this.y.multiply(e)),r=n.square().subtract(this.x.multiply(e)),i=n.multiply(this.x.subtract(r)).subtract(this.y);return new ECPointFp(this.curve,r,i)},ECPointFp.prototype.multiply2D=function(e){if(this.isInfinity())return this;if(e.signum()==0)return this.curve.getInfinity();var t=e,n=t.multiply(new BigInteger("3")),r=this.negate(),i=this,s;for(s=n.bitLength()-2;s>0;--s){i=i.twice();var o=n.testBit(s),u=t.testBit(s);o!=u&&(i=i.add2D(o?this:r))}return i},ECPointFp.prototype.isOnCurve=function(){var e=this.getX().toBigInteger(),t=this.getY().toBigInteger(),n=this.curve.getA().toBigInteger(),r=this.curve.getB().toBigInteger(),i=this.curve.getQ(),s=t.multiply(t).mod(i),o=e.multiply(e).multiply(e).add(n.multiply(e)).add(r).mod(i);return s.equals(o)},ECPointFp.prototype.toString=function(){return"("+this.getX().toBigInteger().toString()+","+this.getY().toBigInteger().toString()+")"},ECPointFp.prototype.validate=function(){var e=this.curve.getQ();if(this.isInfinity())throw new Error("Point is at infinity.");var t=this.getX().toBigInteger(),n=this.getY().toBigInteger();if(t.compareTo(BigInteger.ONE)<0||t.compareTo(e.subtract(BigInteger.ONE))>0)throw new Error("x coordinate out of bounds");if(n.compareTo(BigInteger.ONE)<0||n.compareTo(e.subtract(BigInteger.ONE))>0)throw new Error("y coordinate out of bounds");if(!this.isOnCurve())throw new Error("Point is not on the curve.");if(this.multiply(e).isInfinity())throw new Error("Point is not a scalar multiple of G.");return!0},Bitcoin.ECDSA=function(){function r(e,t,n,r){var i=Math.max(t.bitLength(),r.bitLength()),s=e.add2D(n),o=e.curve.getInfinity();for(var u=i-1;u>=0;--u)o=o.twice2D(),o.z=BigInteger.ONE,t.testBit(u)?r.testBit(u)?o=o.add2D(s):o=o.add2D(e):r.testBit(u)&&(o=o.add2D(n));return o}var e=getSECCurveByName("secp256k1"),t=new SecureRandom,n=null,i={getBigRandom:function(e){return(new BigInteger(e.bitLength(),t)).mod(e.subtract(BigInteger.ONE)).add(BigInteger.ONE)},sign:function(t,n){var r=n,s=e.getN(),o=BigInteger.fromByteArrayUnsigned(t);do var u=i.getBigRandom(s),a=e.getG(),f=a.multiply(u),l=f.getX().toBigInteger().mod(s);while(l.compareTo(BigInteger.ZERO)<=0);var c=u.modInverse(s).multiply(o.add(r.multiply(l))).mod(s);return i.serializeSig(l,c)},verify:function(t,n,r){var s,o;if(Bitcoin.Util.isArray(n)){var u=i.parseSig(n);s=u.r,o=u.s}else{if("object"!=typeof n||!n.r||!n.s)throw"Invalid value for signature";s=n.r,o=n.s}var a;if(r instanceof ECPointFp)a=r;else{if(!Bitcoin.Util.isArray(r))throw"Invalid format for pubkey value, must be byte array or ECPointFp";a=ECPointFp.decodeFrom(e.getCurve(),r)}var f=BigInteger.fromByteArrayUnsigned(t);return i.verifyRaw(f,s,o,a)},verifyRaw:function(t,n,r,i){var s=e.getN(),o=e.getG();if(n.compareTo(BigInteger.ONE)<0||n.compareTo(s)>=0)return!1;if(r.compareTo(BigInteger.ONE)<0||r.compareTo(s)>=0)return!1;var u=r.modInverse(s),a=t.multiply(u).mod(s),f=n.multiply(u).mod(s),l=o.multiply(a).add(i.multiply(f)),c=l.getX().toBigInteger().mod(s);return c.equals(n)},serializeSig:function(e,t){var n=e.toByteArraySigned(),r=t.toByteArraySigned(),i=[];return i.push(2),i.push(n.length),i=i.concat(n),i.push(2),i.push(r.length),i=i.concat(r),i.unshift(i.length),i.unshift(48),i},parseSig:function(e){var t;if(e[0]!=48)throw new Error("Signature not a valid DERSequence");t=2;if(e[t]!=2)throw new Error("First element in signature must be a DERInteger");var n=e.slice(t+2,t+2+e[t+1]);t+=2+e[t+1];if(e[t]!=2)throw new Error("Second element in signature must be a DERInteger");var r=e.slice(t+2,t+2+e[t+1]);t+=2+e[t+1];var i=BigInteger.fromByteArrayUnsigned(n),s=BigInteger.fromByteArrayUnsigned(r);return{r:i,s:s}},parseSigCompact:function(t){if(t.length!==65)throw"Signature has the wrong length";var n=t[0]-27;if(n<0||n>7)throw"Invalid signature type";var r=e.getN(),i=BigInteger.fromByteArrayUnsigned(t.slice(1,33)).mod(r),s=BigInteger.fromByteArrayUnsigned(t.slice(33,65)).mod(r);return{r:i,s:s,i:n}},recoverPubKey:function(t,s,o,u){u&=3;var a=u&1,f=u>>1,l=e.getN(),c=e.getG(),h=e.getCurve(),p=h.getQ(),d=h.getA().toBigInteger(),v=h.getB().toBigInteger();n||(n=p.add(BigInteger.ONE).divide(BigInteger.valueOf(4)));var m=f?t.add(l):t,g=m.multiply(m).multiply(m).add(d.multiply(m)).add(v).mod(p),y=g.modPow(n,p),b=y.isEven()?u%2:(u+1)%2,w=(y.isEven()?!a:a)?y:p.subtract(y),E=new ECPointFp(h,h.fromBigInteger(m),h.fromBigInteger(w));E.validate();var S=BigInteger.fromByteArrayUnsigned(o),x=BigInteger.ZERO.subtract(S).mod(l),T=t.modInverse(l),N=r(E,s,c,x).multiply(T);console.log("G.x: ",Crypto.util.bytesToHex(c.x.toBigInteger().toByteArrayUnsigned())),console.log("G.y: ",Crypto.util.bytesToHex(c.y.toBigInteger().toByteArrayUnsigned())),console.log("s: ",Crypto.util.bytesToHex(T.toByteArrayUnsigned())),console.log("Q.x: ",Crypto.util.bytesToHex(N.x.toBigInteger().toByteArrayUnsigned())),console.log("Q.y: ",Crypto.util.bytesToHex(N.y.toBigInteger().toByteArrayUnsigned())),N.validate();if(!i.verifyRaw(S,t,s,N))throw"Pubkey recovery unsuccessful";var C=new Bitcoin.ECKey;return C.pub=N,C},calcPubkeyRecoveryParam:function(e,t,n,r){for(var i=0;i<4;i++)try{var s=Bitcoin.ECDSA.recoverPubKey(t,n,r,i);if(s.getBitcoinAddress().toString()==e)return i}catch(o){}throw"Unable to find valid recovery factor"}};return i}();
Bitcoin.ECKey=function(){var e=Bitcoin.ECDSA,t=getSECCurveByName("secp256k1"),n=new SecureRandom,r=function(n){if(!n){var i=t.getN();this.priv=e.getBigRandom(i)}else n instanceof BigInteger?this.priv=n:Bitcoin.Util.isArray(n)?this.priv=BigInteger.fromByteArrayUnsigned(n):"string"==typeof n&&(n.length==51&&n[0]=="5"?this.priv=BigInteger.fromByteArrayUnsigned(r.decodeString(n)):this.priv=BigInteger.fromByteArrayUnsigned(Crypto.util.base64ToBytes(n)));this.compressed=!!r.compressByDefault};return r.compressByDefault=!1,r.prototype.setCompressed=function(e){this.compressed=!!e},r.prototype.getPub=function(){return this.getPubPoint().getEncoded(this.compressed)},r.prototype.getPubPoint=function(){return this.pub||(this.pub=t.getG().multiply(this.priv)),this.pub},r.prototype.getPubKeyHash=function(){return this.pubKeyHash?this.pubKeyHash:this.pubKeyHash=Bitcoin.Util.sha256ripe160(this.getPub())},r.prototype.getBitcoinAddress=function(){var e=this.getPubKeyHash(),t=new Bitcoin.Address(e);return t},r.prototype.getExportedPrivateKey=function(){var e=this.priv.toByteArrayUnsigned();while(e.length<32)e.unshift(0);e.unshift(128);var t=Crypto.SHA256(Crypto.SHA256(e,{asBytes:!0}),{asBytes:!0}),n=e.concat(t.slice(0,4));return Bitcoin.Base58.encode(n)},r.prototype.setPub=function(e){this.pub=ECPointFp.decodeFrom(t.getCurve(),e)},r.prototype.toString=function(e){return e==="base64"?Crypto.util.bytesToBase64(this.priv.toByteArrayUnsigned()):Crypto.util.bytesToHex(this.priv.toByteArrayUnsigned())},r.prototype.sign=function(t){return e.sign(t,this.priv)},r.prototype.verify=function(t,n){return e.verify(t,n,this.getPub())},r.decodeString=function(e){var t=Bitcoin.Base58.decode(e),n=t.slice(0,33),r=Crypto.SHA256(Crypto.SHA256(n,{asBytes:!0}),{asBytes:!0});if(r[0]!=t[33]||r[1]!=t[34]||r[2]!=t[35]||r[3]!=t[36])throw"Checksum validation failed!";alert('debug');var i=n.shift();if(i!=128)throw"Version "+i+" not supported!";return n},r}();
(function(){var e=Bitcoin.Opcode=function(e){this.code=e};e.prototype.toString=function(){return e.reverseMap[this.code]},e.map={OP_0:0,OP_FALSE:0,OP_PUSHDATA1:76,OP_PUSHDATA2:77,OP_PUSHDATA4:78,OP_1NEGATE:79,OP_RESERVED:80,OP_1:81,OP_TRUE:81,OP_2:82,OP_3:83,OP_4:84,OP_5:85,OP_6:86,OP_7:87,OP_8:88,OP_9:89,OP_10:90,OP_11:91,OP_12:92,OP_13:93,OP_14:94,OP_15:95,OP_16:96,OP_NOP:97,OP_VER:98,OP_IF:99,OP_NOTIF:100,OP_VERIF:101,OP_VERNOTIF:102,OP_ELSE:103,OP_ENDIF:104,OP_VERIFY:105,OP_RETURN:106,OP_TOALTSTACK:107,OP_FROMALTSTACK:108,OP_2DROP:109,OP_2DUP:110,OP_3DUP:111,OP_2OVER:112,OP_2ROT:113,OP_2SWAP:114,OP_IFDUP:115,OP_DEPTH:116,OP_DROP:117,OP_DUP:118,OP_NIP:119,OP_OVER:120,OP_PICK:121,OP_ROLL:122,OP_ROT:123,OP_SWAP:124,OP_TUCK:125,OP_CAT:126,OP_SUBSTR:127,OP_LEFT:128,OP_RIGHT:129,OP_SIZE:130,OP_INVERT:131,OP_AND:132,OP_OR:133,OP_XOR:134,OP_EQUAL:135,OP_EQUALVERIFY:136,OP_RESERVED1:137,OP_RESERVED2:138,OP_1ADD:139,OP_1SUB:140,OP_2MUL:141,OP_2DIV:142,OP_NEGATE:143,OP_ABS:144,OP_NOT:145,OP_0NOTEQUAL:146,OP_ADD:147,OP_SUB:148,OP_MUL:149,OP_DIV:150,OP_MOD:151,OP_LSHIFT:152,OP_RSHIFT:153,OP_BOOLAND:154,OP_BOOLOR:155,OP_NUMEQUAL:156,OP_NUMEQUALVERIFY:157,OP_NUMNOTEQUAL:158,OP_LESSTHAN:159,OP_GREATERTHAN:160,OP_LESSTHANOREQUAL:161,OP_GREATERTHANOREQUAL:162,OP_MIN:163,OP_MAX:164,OP_WITHIN:165,OP_RIPEMD160:166,OP_SHA1:167,OP_SHA256:168,OP_HASH160:169,OP_HASH256:170,OP_CODESEPARATOR:171,OP_CHECKSIG:172,OP_CHECKSIGVERIFY:173,OP_CHECKMULTISIG:174,OP_CHECKMULTISIGVERIFY:175,OP_NOP1:176,OP_NOP2:177,OP_NOP3:178,OP_NOP4:179,OP_NOP5:180,OP_NOP6:181,OP_NOP7:182,OP_NOP8:183,OP_NOP9:184,OP_NOP10:185,OP_PUBKEYHASH:253,OP_PUBKEY:254,OP_INVALIDOPCODE:255},e.reverseMap=[];for(var t in e.map)e.reverseMap[e.map[t]]=t})();
(function(){var Opcode=Bitcoin.Opcode;for(var i in Opcode.map)eval("var "+i+" = "+Opcode.map[i]+";");var Script=Bitcoin.Script=function(e){if(!e)this.buffer=[];else if("string"==typeof e)this.buffer=Crypto.util.base64ToBytes(e);else if(Bitcoin.Util.isArray(e))this.buffer=e;else{if(!(e instanceof Script))throw new Error("Invalid script");this.buffer=e.buffer}this.parse()};Script.prototype.parse=function(){function n(n){e.chunks.push(e.buffer.slice(t,t+n)),t+=n}var e=this;this.chunks=[];var t=0;while(t<this.buffer.length){var r=this.buffer[t++];r>=240&&(r=r<<8|this.buffer[t++]);var i;r>0&&r<OP_PUSHDATA1?n(r):r==OP_PUSHDATA1?(i=this.buffer[t++],n(i)):r==OP_PUSHDATA2?(i=this.buffer[t++]<<8|this.buffer[t++],n(i)):r==OP_PUSHDATA4?(i=this.buffer[t++]<<24|this.buffer[t++]<<16|this.buffer[t++]<<8|this.buffer[t++],n(i)):this.chunks.push(r)}},Script.prototype.getOutType=function(){return this.chunks[this.chunks.length-1]==OP_CHECKMULTISIG&&this.chunks[this.chunks.length-2]<=3?"Multisig":this.chunks.length==5&&this.chunks[0]==OP_DUP&&this.chunks[1]==OP_HASH160&&this.chunks[3]==OP_EQUALVERIFY&&this.chunks[4]==OP_CHECKSIG?"Address":this.chunks.length==2&&this.chunks[1]==OP_CHECKSIG?"Pubkey":"Strange"},Script.prototype.simpleOutHash=function(){switch(this.getOutType()){case"Address":return this.chunks[2];case"Pubkey":return Bitcoin.Util.sha256ripe160(this.chunks[0]);default:throw new Error("Encountered non-standard scriptPubKey")}},Script.prototype.simpleOutPubKeyHash=Script.prototype.simpleOutHash,Script.prototype.getInType=function(){return this.chunks.length==1&&Bitcoin.Util.isArray(this.chunks[0])?"Pubkey":this.chunks.length==2&&Bitcoin.Util.isArray(this.chunks[0])&&Bitcoin.Util.isArray(this.chunks[1])?"Address":"Strange"},Script.prototype.simpleInPubKey=function(){switch(this.getInType()){case"Address":return this.chunks[1];case"Pubkey":throw new Error("Script does not contain pubkey.");default:throw new Error("Encountered non-standard scriptSig")}},Script.prototype.simpleInHash=function(){return Bitcoin.Util.sha256ripe160(this.simpleInPubKey())},Script.prototype.simpleInPubKeyHash=Script.prototype.simpleInHash,Script.prototype.writeOp=function(e){this.buffer.push(e),this.chunks.push(e)},Script.prototype.writeBytes=function(e){e.length<OP_PUSHDATA1?this.buffer.push(e.length):e.length<=255?(this.buffer.push(OP_PUSHDATA1),this.buffer.push(e.length)):e.length<=65535?(this.buffer.push(OP_PUSHDATA2),this.buffer.push(e.length&255),this.buffer.push(e.length>>>8&255)):(this.buffer.push(OP_PUSHDATA4),this.buffer.push(e.length&255),this.buffer.push(e.length>>>8&255),this.buffer.push(e.length>>>16&255),this.buffer.push(e.length>>>24&255)),this.buffer=this.buffer.concat(e),this.chunks.push(e)},
Script.createOutputScript=function(e){ var t=new Script; if(e['version']=="0"){ t.writeOp(OP_DUP); t.writeOp(OP_HASH160); t.writeBytes(e.hash); t.writeOp(OP_EQUALVERIFY); t.writeOp(OP_CHECKSIG); } else if (e['version']=='5') { t.writeOp(OP_HASH160); t.writeBytes(e.hash); t.writeOp(OP_EQUAL); } return t;
},Script.prototype.extractAddresses=function(e){switch(this.getOutType()){case"Address":return e.push(new Address(this.chunks[2])),1;case"Pubkey":return e.push(new Address(Util.sha256ripe160(this.chunks[0]))),1;case"Multisig":for(var t=1;t<this.chunks.length-2;++t)e.push(new Address(Util.sha256ripe160(this.chunks[t])));return this.chunks[0]-OP_1+1;default:throw new Error("Encountered non-standard scriptPubKey")}},Script.createMultiSigOutputScript=function(e,t){var n=new Bitcoin.Script;n.writeOp(OP_1+e-1);for(var r=0;r<t.length;++r)n.writeBytes(t[r]);return n.writeOp(OP_1+t.length-1),n.writeOp(OP_CHECKMULTISIG),n},Script.createInputScript=function(e,t){var n=new Script;return n.writeBytes(e),n.writeBytes(t),n},Script.prototype.clone=function(){return new Script(this.buffer)}})();
(function(){var e=Bitcoin.Script,t=Bitcoin.Transaction=function(e){this.version=1,this.lock_time=0,this.ins=[],this.outs=[],this.timestamp=null,this.block=null;if(e){e.hash&&(this.hash=e.hash),e.version&&(this.version=e.version),e.lock_time&&(this.lock_time=e.lock_time);if(e.ins&&e.ins.length)for(var t=0;t<e.ins.length;t++)this.addInput(new u(e.ins[t]));if(e.outs&&e.outs.length)for(var t=0;t<e.outs.length;t++)this.addOutput(new a(e.outs[t]));e.timestamp&&(this.timestamp=e.timestamp),e.block&&(this.block=e.block)}};t.objectify=function(e){var n=[];for(var r=0;r<e.length;r++)n.push(new t(e[r]));return n},t.prototype.addInput=function(e,t){arguments[0]instanceof u?this.ins.push(arguments[0]):this.ins.push(new u({outpoint:{hash:e.hash,index:t},script:new Bitcoin.Script,sequence:4294967295}))},t.prototype.addOutput=function(t,n){if(arguments[0]instanceof a)this.outs.push(arguments[0]);else{if(n instanceof BigInteger){n=n.toByteArrayUnsigned().reverse();while(n.length<8)n.push(0)}else Bitcoin.Util.isArray(n);this.outs.push(new a({value:n,script:e.createOutputScript(t)}))}},t.prototype.serialize=function(){var e=[];e=e.concat(Crypto.util.wordsToBytes([parseInt(this.version)]).reverse()),e=e.concat(Bitcoin.Util.numToVarInt(this.ins.length));for(var t=0;t<this.ins.length;t++){var n=this.ins[t];e=e.concat(Crypto.util.base64ToBytes(n.outpoint.hash)),e=e.concat(Crypto.util.wordsToBytes([parseInt(n.outpoint.index)]).reverse());var r=n.script.buffer;e=e.concat(Bitcoin.Util.numToVarInt(r.length)),e=e.concat(r),e=e.concat(Crypto.util.wordsToBytes([parseInt(n.sequence)]).reverse())}e=e.concat(Bitcoin.Util.numToVarInt(this.outs.length));for(var t=0;t<this.outs.length;t++){var i=this.outs[t];e=e.concat(i.value);var r=i.script.buffer;e=e.concat(Bitcoin.Util.numToVarInt(r.length)),e=e.concat(r)}return e=e.concat(Crypto.util.wordsToBytes([parseInt(this.lock_time)]).reverse()),e};var n=171,r=1,i=2,s=3,o=80;t.deserialize=function(e){if(typeof e=="string"){e=Crypto.util.hexToBytes(e)}var t=0;var n=function(r){if(r==0)return 0;t++;return e[t-1]+n(r-1)*256};var r=function(){t++;if(e[t-1]<253){return e[t-1]}return n(e[t-1]-251)};var i=function(n){t+=n;return e.slice(t-n,t)};var s=function(){var e=r();return i(e)};var o=function(e){if(e.length==0)return 0;else return e[0]+256*o(e.slice(1))};var u={ins:[],outs:[]};u.version=n(4);var a=r();for(var f=0;f<a;f++){u.ins.push({outpoint:{hash:Crypto.util.bytesToBase64(i(32)),index:n(4)},script:new Bitcoin.Script(s()),sequence:n(4)})}var l=r();for(var f=0;f<l;f++){u.outs.push({value:(i(8)),script:new Bitcoin.Script(s())})}u.locktime=n(4);return new Bitcoin.Transaction(u)};t.prototype.hashTransactionForSignature=function(t,n,r){var u=this.clone();for(var a=0;a<u.ins.length;a++)u.ins[a].script=new e;u.ins[n].script=t;if((r&31)==i){u.outs=[];for(var a=0;a<u.ins.length;a++)a!=n&&(u.ins[a].sequence=0)}else(r&31)==s;r&o&&(u.ins=[u.ins[n]]);var f=u.serialize();f=f.concat(Crypto.util.wordsToBytes([parseInt(r)]).reverse());var l=Crypto.SHA256(f,{asBytes:!0});return Crypto.SHA256(l,{asBytes:!0})},t.prototype.getHash=function(){var e=this.serialize();return Crypto.SHA256(Crypto.SHA256(e,{asBytes:!0}),{asBytes:!0})},t.prototype.clone=function(){var e=new t;e.version=this.version,e.lock_time=this.lock_time;for(var n=0;n<this.ins.length;n++){var r=this.ins[n].clone();e.addInput(r)}for(var n=0;n<this.outs.length;n++){var i=this.outs[n].clone();e.addOutput(i)}return e},t.prototype.analyze=function(e){if(e instanceof Bitcoin.Wallet){var t=!0,n=!0,r=null,i=null,s=null;for(var o=this.outs.length-1;o>=0;o--){var u=this.outs[o],a=u.script.simpleOutPubKeyHash();e.hasHash(a)?i=a:n=!1,r=a}for(var o=this.ins.length-1;o>=0;o--){var f=this.ins[o];s=f.script.simpleInPubKeyHash();if(!e.hasHash(s)){t=!1;break}}var l=this.calcImpact(e),c={};return c.impact=l,l.sign>0&&l.value.compareTo(BigInteger.ZERO)>0?(c.type="recv",c.addr=new Bitcoin.Address(i)):t&&n?c.type="self":t?(c.type="sent",c.addr=new Bitcoin.Address(r)):c.type="other",c}return null},t.prototype.getDescription=function(e){var t=this.analyze(e);if(!t)return"";switch(t.type){case"recv":return"Received with "+t.addr;case"sent":return"Payment to "+t.addr;case"self":return"Payment to yourself";case"other":default:return""}},t.prototype.getTotalOutValue=function(){var e=BigInteger.ZERO;for(var t=0;t<this.outs.length;t++){var n=this.outs[t];e=e.add(Bitcoin.Util.valueToBigInt(n.value))}return e},t.prototype.getTotalValue=t.prototype.getTotalOutValue,t.prototype.calcImpact=function(e){if(e instanceof Bitcoin.Wallet){var t=BigInteger.ZERO;for(var n=0;n<this.outs.length;n++){var r=this.outs[n],i=Crypto.util.bytesToBase64(r.script.simpleOutPubKeyHash());e.hasHash(i)&&(t=t.add(Bitcoin.Util.valueToBigInt(r.value)))}var s=BigInteger.ZERO;for(var n=0;n<this.ins.length;n++){var o=this.ins[n],i=Crypto.util.bytesToBase64(o.script.simpleInPubKeyHash());if(e.hasHash(i)){var u=e.txIndex[o.outpoint.hash];u&&(s=s.add(Bitcoin.Util.valueToBigInt(u.outs[o.outpoint.index].value)))}}return t.compareTo(s)>=0?{sign:1,value:t.subtract(s)}:{sign:-1,value:s.subtract(t)}}return BigInteger.ZERO};var u=Bitcoin.TransactionIn=function(t){this.outpoint=t.outpoint,t.script instanceof e?this.script=t.script:this.script=new e(t.script),this.sequence=t.sequence};u.prototype.clone=function(){var e=new u({outpoint:{hash:this.outpoint.hash,index:this.outpoint.index},script:this.script.clone(),sequence:this.sequence});return e};var a=Bitcoin.TransactionOut=function(t){t.script instanceof e?this.script=t.script:this.script=new e(t.script);if(Bitcoin.Util.isArray(t.value))this.value=t.value;else if("string"==typeof t.value){var n=(new BigInteger(t.value,10)).toString(16);while(n.length<16)n="0"+n;this.value=Crypto.util.hexToBytes(n)}};a.prototype.clone=function(){var e=new a({script:this.script.clone(),value:this.value});return e}})();
Bitcoin.Wallet=function(){var e=Bitcoin.Script,t=Bitcoin.TransactionIn,n=Bitcoin.TransactionOut,r=function(){var e=[];this.addressHashes=[],this.txIndex={},this.unspentOuts=[],this.addressPointer=0,this.addKey=function(t,n){t instanceof Bitcoin.ECKey||(t=new Bitcoin.ECKey(t)),e.push(t),n&&("string"==typeof n&&(n=Crypto.util.base64ToBytes(n)),t.setPub(n)),this.addressHashes.push(t.getBitcoinAddress().getHashBase64())},this.addKeys=function(e,t){"string"==typeof e&&(e=e.split(",")),"string"==typeof t&&(t=t.split(","));var n;if(Array.isArray(t)&&e.length==t.length)for(n=0;n<e.length;n++)this.addKey(e[n],t[n]);else for(n=0;n<e.length;n++)this.addKey(e[n])},this.getKeys=function(){var t=[];for(var n=0;n<e.length;n++)t.push(e[n].toString("base64"));return t},this.getPubKeys=function(){var t=[];for(var n=0;n<e.length;n++)t.push(Crypto.util.bytesToBase64(e[n].getPub()));return t},this.clear=function(){e=[]},this.getLength=function(){return e.length},this.getAllAddresses=function(){var t=[];for(var n=0;n<e.length;n++)t.push(e[n].getBitcoinAddress());return t},this.getCurAddress=function(){return e[this.addressPointer]?e[this.addressPointer].getBitcoinAddress():null},this.getNextAddress=function(){return this.addressPointer++,e[this.addressPointer]||this.generateAddress(),e[this.addressPointer].getBitcoinAddress()},this.signWithKey=function(t,n){t=Crypto.util.bytesToBase64(t);for(var r=0;r<this.addressHashes.length;r++)if(this.addressHashes[r]==t)return e[r].sign(n);throw new Error("Missing key for signature")},this.getPubKeyFromHash=function(t){t=Crypto.util.bytesToBase64(t);for(var n=0;n<this.addressHashes.length;n++)if(this.addressHashes[n]==t)return e[n].getPub();throw new Error("Hash unknown")}};return r.prototype.generateAddress=function(){this.addKey(new Bitcoin.ECKey)},r.prototype.process=function(e){if(this.txIndex[e.hash])return;var r,i,s;for(r=0;r<e.outs.length;r++){var o=new n(e.outs[r]);s=Crypto.util.bytesToBase64(o.script.simpleOutPubKeyHash());for(i=0;i<this.addressHashes.length;i++)if(this.addressHashes[i]===s){this.unspentOuts.push({tx:e,index:r,out:o});break}}for(r=0;r<e.ins.length;r++){var u=new t(e.ins[r]),a=u.script.simpleInPubKey();s=Crypto.util.bytesToBase64(Bitcoin.Util.sha256ripe160(a));for(i=0;i<this.addressHashes.length;i++)if(this.addressHashes[i]===s){for(var f=0;f<this.unspentOuts.length;f++)u.outpoint.hash==this.unspentOuts[f].tx.hash&&u.outpoint.index==this.unspentOuts[f].index&&this.unspentOuts.splice(f,1);break}}this.txIndex[e.hash]=e},r.prototype.getBalance=function(){var e=BigInteger.valueOf(0);for(var t=0;t<this.unspentOuts.length;t++){var n=this.unspentOuts[t].out;e=e.add(Bitcoin.Util.valueToBigInt(n.value))}return e},r.prototype.createSend=function(t,n,r){var i=[],s=n.add(r),o=BigInteger.ZERO,u;for(u=0;u<this.unspentOuts.length;u++){i.push(this.unspentOuts[u]),o=o.add(Bitcoin.Util.valueToBigInt(this.unspentOuts[u].out.value));if(o.compareTo(s)>=0)break}if(o.compareTo(s)<0)throw new Error("Insufficient funds.");var a=o.subtract(s),f=new Bitcoin.Transaction;for(u=0;u<i.length;u++)f.addInput(i[u].tx,i[u].index);f.addOutput(t,n),a.compareTo(BigInteger.ZERO)>0&&f.addOutput(this.getNextAddress(),a);var l=1;for(u=0;u<f.ins.length;u++){var c=f.hashTransactionForSignature(i[u].out.script,u,l),h=i[u].out.script.simpleOutPubKeyHash(),p=this.signWithKey(h,c);p.push(parseInt(l,10)),f.ins[u].script=e.createInputScript(p,this.getPubKeyFromHash(h))}return f},r.prototype.clearTransactions=function(){this.txIndex={},this.unspentOuts=[]},r.prototype.hasHash=function(e){Bitcoin.Util.isArray(e)&&(e=Crypto.util.bytesToBase64(e));for(var t=0;t<this.addressHashes.length;t++)if(this.addressHashes[t]===e)return!0;return!1},r}();
var TransactionDatabase=function(){this.txs=[],this.txIndex={}};EventEmitter.augment(TransactionDatabase.prototype),TransactionDatabase.prototype.addTransaction=function(e){this.addTransactionNoUpdate(e),$(this).trigger("update")},TransactionDatabase.prototype.addTransactionNoUpdate=function(e){if(this.txIndex[e.hash])return;this.txs.push(new Bitcoin.Transaction(e)),this.txIndex[e.hash]=e},TransactionDatabase.prototype.removeTransaction=function(e){this.removeTransactionNoUpdate(e),$(this).trigger("update")},TransactionDatabase.prototype.removeTransactionNoUpdate=function(e){var t=this.txIndex[e];if(!t)return;for(var n=0,r=this.txs.length;n<r;n++)if(this.txs[n].hash==e){this.txs.splice(n,1);break}delete this.txIndex[e]},TransactionDatabase.prototype.loadTransactions=function(e){for(var t=0;t<e.length;t++)this.addTransactionNoUpdate(e[t]);$(this).trigger("update")},TransactionDatabase.prototype.getTransactions=function(){return this.txs},TransactionDatabase.prototype.clear=function(){this.txs=[],this.txIndex={},$(this).trigger("update")}
</script>
<!-- ========================================= end content of bitcoinjs-min.js ========================================= -->


<!-- Source: https://github.com/kazuhikoarase/qrcode-generator/blob/master/js/qrcode.js -->
<!-- <script type="text/javascript" src="../../scripts/bitcoin/qrcode.js"></script> -->
<!-- Copy the content of qrcode.js on this page -->
<script language="JavaScript" type="text/javascript">
//---------------------------------------------------------------------
//
// QR Code Generator for JavaScript
//
// Copyright (c) 2009 Kazuhiko Arase
//
// URL: http://www.d-project.com/
//
// Licensed under the MIT license:
//	http://www.opensource.org/licenses/mit-license.php
//
// The word 'QR Code' is registered trademark of
// DENSO WAVE INCORPORATED
//	http://www.denso-wave.com/qrcode/faqpatent-e.html
//
//---------------------------------------------------------------------

var qrcode = function() {

	//---------------------------------------------------------------------
	// qrcode
	//---------------------------------------------------------------------

	/**
	 * qrcode
	 * @param typeNumber 1 to 10
	 * @param errorCorrectLevel 'L','M','Q','H'
	 */
	var qrcode = function(typeNumber, errorCorrectLevel) {

		var PAD0 = 0xEC;
		var PAD1 = 0x11;

		var _typeNumber = typeNumber;
		var _errorCorrectLevel = QRErrorCorrectLevel[errorCorrectLevel];
		var _modules = null;
		var _moduleCount = 0;
		var _dataCache = null;
		var _dataList = new Array();

		var _this = {};

		var makeImpl = function(test, maskPattern) {

			_moduleCount = _typeNumber * 4 + 17;
			_modules = function(moduleCount) {
				var modules = new Array(moduleCount);
				for (var row = 0; row < moduleCount; row += 1) {
					modules[row] = new Array(moduleCount);
					for (var col = 0; col < moduleCount; col += 1) {
						modules[row][col] = null;
					}
				}
				return modules;
			}(_moduleCount);

			setupPositionProbePattern(0, 0);
			setupPositionProbePattern(_moduleCount - 7, 0);
			setupPositionProbePattern(0, _moduleCount - 7);
			setupPositionAdjustPattern();
			setupTimingPattern();
			setupTypeInfo(test, maskPattern);

			if (_typeNumber >= 7) {
				setupTypeNumber(test);
			}

			if (_dataCache == null) {
				_dataCache = createData(_typeNumber, _errorCorrectLevel, _dataList);
			}

			mapData(_dataCache, maskPattern);
		};

		var setupPositionProbePattern = function(row, col) {

			for (var r = -1; r <= 7; r += 1) {

				if (row + r <= -1 || _moduleCount <= row + r) continue;

				for (var c = -1; c <= 7; c += 1) {

					if (col + c <= -1 || _moduleCount <= col + c) continue;

					if ( (0 <= r && r <= 6 && (c == 0 || c == 6) )
							|| (0 <= c && c <= 6 && (r == 0 || r == 6) )
							|| (2 <= r && r <= 4 && 2 <= c && c <= 4) ) {
						_modules[row + r][col + c] = true;
					} else {
						_modules[row + r][col + c] = false;
					}
				}
			}
		};

		var getBestMaskPattern = function() {

			var minLostPoint = 0;
			var pattern = 0;

			for (var i = 0; i < 8; i += 1) {

				makeImpl(true, i);

				var lostPoint = QRUtil.getLostPoint(_this);

				if (i == 0 || minLostPoint > lostPoint) {
					minLostPoint = lostPoint;
					pattern = i;
				}
			}

			return pattern;
		};

		var setupTimingPattern = function() {

			for (var r = 8; r < _moduleCount - 8; r += 1) {
				if (_modules[r][6] != null) {
					continue;
				}
				_modules[r][6] = (r % 2 == 0);
			}

			for (var c = 8; c < _moduleCount - 8; c += 1) {
				if (_modules[6][c] != null) {
					continue;
				}
				_modules[6][c] = (c % 2 == 0);
			}
		};

		var setupPositionAdjustPattern = function() {

			var pos = QRUtil.getPatternPosition(_typeNumber);

			for (var i = 0; i < pos.length; i += 1) {

				for (var j = 0; j < pos.length; j += 1) {

					var row = pos[i];
					var col = pos[j];

					if (_modules[row][col] != null) {
						continue;
					}

					for (var r = -2; r <= 2; r += 1) {

						for (var c = -2; c <= 2; c += 1) {

							if (r == -2 || r == 2 || c == -2 || c == 2
									|| (r == 0 && c == 0) ) {
								_modules[row + r][col + c] = true;
							} else {
								_modules[row + r][col + c] = false;
							}
						}
					}
				}
			}
		};

		var setupTypeNumber = function(test) {

			var bits = QRUtil.getBCHTypeNumber(_typeNumber);

			for (var i = 0; i < 18; i += 1) {
				var mod = (!test && ( (bits >> i) & 1) == 1);
				_modules[Math.floor(i / 3)][i % 3 + _moduleCount - 8 - 3] = mod;
			}

			for (var i = 0; i < 18; i += 1) {
				var mod = (!test && ( (bits >> i) & 1) == 1);
				_modules[i % 3 + _moduleCount - 8 - 3][Math.floor(i / 3)] = mod;
			}
		};

		var setupTypeInfo = function(test, maskPattern) {

			var data = (_errorCorrectLevel << 3) | maskPattern;
			var bits = QRUtil.getBCHTypeInfo(data);

			// vertical
			for (var i = 0; i < 15; i += 1) {

				var mod = (!test && ( (bits >> i) & 1) == 1);

				if (i < 6) {
					_modules[i][8] = mod;
				} else if (i < 8) {
					_modules[i + 1][8] = mod;
				} else {
					_modules[_moduleCount - 15 + i][8] = mod;
				}
			}

			// horizontal
			for (var i = 0; i < 15; i += 1) {

				var mod = (!test && ( (bits >> i) & 1) == 1);

				if (i < 8) {
					_modules[8][_moduleCount - i - 1] = mod;
				} else if (i < 9) {
					_modules[8][15 - i - 1 + 1] = mod;
				} else {
					_modules[8][15 - i - 1] = mod;
				}
			}

			// fixed module
			_modules[_moduleCount - 8][8] = (!test);
		};

		var mapData = function(data, maskPattern) {

			var inc = -1;
			var row = _moduleCount - 1;
			var bitIndex = 7;
			var byteIndex = 0;
			var maskFunc = QRUtil.getMaskFunction(maskPattern);

			for (var col = _moduleCount - 1; col > 0; col -= 2) {

				if (col == 6) col -= 1;

				while (true) {

					for (var c = 0; c < 2; c += 1) {

						if (_modules[row][col - c] == null) {

							var dark = false;

							if (byteIndex < data.length) {
								dark = ( ( (data[byteIndex] >>> bitIndex) & 1) == 1);
							}

							var mask = maskFunc(row, col - c);

							if (mask) {
								dark = !dark;
							}

							_modules[row][col - c] = dark;
							bitIndex -= 1;

							if (bitIndex == -1) {
								byteIndex += 1;
								bitIndex = 7;
							}
						}
					}

					row += inc;

					if (row < 0 || _moduleCount <= row) {
						row -= inc;
						inc = -inc;
						break;
					}
				}
			}
		};

		var createBytes = function(buffer, rsBlocks) {

			var offset = 0;

			var maxDcCount = 0;
			var maxEcCount = 0;

			var dcdata = new Array(rsBlocks.length);
			var ecdata = new Array(rsBlocks.length);

			for (var r = 0; r < rsBlocks.length; r += 1) {

				var dcCount = rsBlocks[r].dataCount;
				var ecCount = rsBlocks[r].totalCount - dcCount;

				maxDcCount = Math.max(maxDcCount, dcCount);
				maxEcCount = Math.max(maxEcCount, ecCount);

				dcdata[r] = new Array(dcCount);

				for (var i = 0; i < dcdata[r].length; i += 1) {
					dcdata[r][i] = 0xff & buffer.getBuffer()[i + offset];
				}
				offset += dcCount;

				var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
				var rawPoly = qrPolynomial(dcdata[r], rsPoly.getLength() - 1);

				var modPoly = rawPoly.mod(rsPoly);
				ecdata[r] = new Array(rsPoly.getLength() - 1);
				for (var i = 0; i < ecdata[r].length; i += 1) {
					var modIndex = i + modPoly.getLength() - ecdata[r].length;
					ecdata[r][i] = (modIndex >= 0)? modPoly.get(modIndex) : 0;
				}
			}

			var totalCodeCount = 0;
			for (var i = 0; i < rsBlocks.length; i += 1) {
				totalCodeCount += rsBlocks[i].totalCount;
			}

			var data = new Array(totalCodeCount);
			var index = 0;

			for (var i = 0; i < maxDcCount; i += 1) {
				for (var r = 0; r < rsBlocks.length; r += 1) {
					if (i < dcdata[r].length) {
						data[index] = dcdata[r][i];
						index += 1;
					}
				}
			}

			for (var i = 0; i < maxEcCount; i += 1) {
				for (var r = 0; r < rsBlocks.length; r += 1) {
					if (i < ecdata[r].length) {
						data[index] = ecdata[r][i];
						index += 1;
					}
				}
			}

			return data;
		};

		var createData = function(typeNumber, errorCorrectLevel, dataList) {

			var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectLevel);

			var buffer = qrBitBuffer();

			for (var i = 0; i < dataList.length; i += 1) {
				var data = dataList[i];
				buffer.put(data.getMode(), 4);
				buffer.put(data.getLength(), QRUtil.getLengthInBits(data.getMode(), typeNumber) );
				data.write(buffer);
			}

			// calc num max data.
			var totalDataCount = 0;
			for (var i = 0; i < rsBlocks.length; i += 1) {
				totalDataCount += rsBlocks[i].dataCount;
			}

			if (buffer.getLengthInBits() > totalDataCount * 8) {
				throw new Error('code length overflow. ('
					+ buffer.getLengthInBits()
					+ '>'
					+ totalDataCount * 8
					+ ')');
			}

			// end code
			if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {
				buffer.put(0, 4);
			}

			// padding
			while (buffer.getLengthInBits() % 8 != 0) {
				buffer.putBit(false);
			}

			// padding
			while (true) {

				if (buffer.getLengthInBits() >= totalDataCount * 8) {
					break;
				}
				buffer.put(PAD0, 8);

				if (buffer.getLengthInBits() >= totalDataCount * 8) {
					break;
				}
				buffer.put(PAD1, 8);
			}

			return createBytes(buffer, rsBlocks);
		};

		_this.addData = function(data) {
			var newData = qr8BitByte(data);
			_dataList.push(newData);
			_dataCache = null;
		};

		_this.isDark = function(row, col) {
			if (row < 0 || _moduleCount <= row || col < 0 || _moduleCount <= col) {
				throw new Error(row + ',' + col);
			}
			return _modules[row][col];
		};

		_this.getModuleCount = function() {
			return _moduleCount;
		};

		_this.make = function() {
			makeImpl(false, getBestMaskPattern() );
		};

		_this.createTableTag = function(cellSize, margin) {

			cellSize = cellSize || 2;
			margin = (typeof margin == 'undefined')? cellSize * 4 : margin;

			var qrHtml = '';

			qrHtml += '<table style="';
			qrHtml += ' border-width: 0px; border-style: none;';
			qrHtml += ' border-collapse: collapse;';
			qrHtml += ' padding: 0px; margin: ' + margin + 'px;';
			qrHtml += '">';
			qrHtml += '<tbody>';

			for (var r = 0; r < _this.getModuleCount(); r += 1) {

				qrHtml += '<tr>';

				for (var c = 0; c < _this.getModuleCount(); c += 1) {
					qrHtml += '<td style="';
					qrHtml += ' border-width: 0px; border-style: none;';
					qrHtml += ' border-collapse: collapse;';
					qrHtml += ' padding: 0px; margin: 0px;';
					qrHtml += ' width: ' + cellSize + 'px;';
					qrHtml += ' height: ' + cellSize + 'px;';
					qrHtml += ' background-color: ';
					qrHtml += _this.isDark(r, c)? '#000000' : '#ffffff';
					qrHtml += ';';
					qrHtml += '"/>';
				}

				qrHtml += '<\/tr>';
			}

			qrHtml += '<\/tbody>';
			qrHtml += '<\/table>';

			return qrHtml;
		};

		_this.createImgTag = function(cellSize, margin) {

			cellSize = cellSize || 2;
			margin = (typeof margin == 'undefined')? cellSize * 4 : margin;

			var size = _this.getModuleCount() * cellSize + margin * 2;
			var min = margin;
			var max = size - margin;

			return createImgTag(size, size, function(x, y) {
				if (min <= x && x < max && min <= y && y < max) {
					var c = Math.floor( (x - min) / cellSize);
					var r = Math.floor( (y - min) / cellSize);
					return _this.isDark(r, c)? 0 : 1;
				} else {
					return 1;
				}
			} );
		};

		return _this;
	};

	//---------------------------------------------------------------------
	// qrcode.stringToBytes
	//---------------------------------------------------------------------

	qrcode.stringToBytes = function(s) {
		var bytes = new Array();
		for (var i = 0; i < s.length; i += 1) {
			var c = s.charCodeAt(i);
			bytes.push(c & 0xff);
		}
		return bytes;
	};

	//---------------------------------------------------------------------
	// qrcode.createStringToBytes
	//---------------------------------------------------------------------

	/**
	 * @param unicodeData base64 string of byte array.
	 * [16bit Unicode],[16bit Bytes], ...
	 * @param numChars
	 */
	qrcode.createStringToBytes = function(unicodeData, numChars) {

		// create conversion map.

		var unicodeMap = function() {

			var bin = base64DecodeInputStream(unicodeData);
			var read = function() {
				var b = bin.read();
				if (b == -1) throw new Error();
				return b;
			};

			var count = 0;
			var unicodeMap = {};
			while (true) {
				var b0 = bin.read();
				if (b0 == -1) break;
				var b1 = read();
				var b2 = read();
				var b3 = read();
				var k = String.fromCharCode( (b0 << 8) | b1);
				var v = (b2 << 8) | b3;
				unicodeMap[k] = v;
				count += 1;
			}
			if (count != numChars) {
				throw new Error(count + ' != ' + numChars);
			}

			return unicodeMap;
		}();

		var unknownChar = '?'.charCodeAt(0);

		return function(s) {
			var bytes = new Array();
			for (var i = 0; i < s.length; i += 1) {
				var c = s.charCodeAt(i);
				if (c < 128) {
					bytes.push(c);
				} else {
					var b = unicodeMap[s.charAt(i)];
					if (typeof b == 'number') {
						if ( (b & 0xff) == b) {
							// 1byte
							bytes.push(b);
						} else {
							// 2bytes
							bytes.push(b >>> 8);
							bytes.push(b & 0xff);
						}
					} else {
						bytes.push(unknownChar);
					}
				}
			}
			return bytes;
		};
	};

	//---------------------------------------------------------------------
	// QRMode
	//---------------------------------------------------------------------

	var QRMode = {
		MODE_NUMBER :		1 << 0,
		MODE_ALPHA_NUM : 	1 << 1,
		MODE_8BIT_BYTE : 	1 << 2,
		MODE_KANJI :		1 << 3
	};

	//---------------------------------------------------------------------
	// QRErrorCorrectLevel
	//---------------------------------------------------------------------

	var QRErrorCorrectLevel = {
		L : 1,
		M : 0,
		Q : 3,
		H : 2
	};

	//---------------------------------------------------------------------
	// QRMaskPattern
	//---------------------------------------------------------------------

	var QRMaskPattern = {
		PATTERN000 : 0,
		PATTERN001 : 1,
		PATTERN010 : 2,
		PATTERN011 : 3,
		PATTERN100 : 4,
		PATTERN101 : 5,
		PATTERN110 : 6,
		PATTERN111 : 7
	};

	//---------------------------------------------------------------------
	// QRUtil
	//---------------------------------------------------------------------

	var QRUtil = function() {

		var PATTERN_POSITION_TABLE = [
			[],
			[6, 18],
			[6, 22],
			[6, 26],
			[6, 30],
			[6, 34],
			[6, 22, 38],
			[6, 24, 42],
			[6, 26, 46],
			[6, 28, 50],
			[6, 30, 54],
			[6, 32, 58],
			[6, 34, 62],
			[6, 26, 46, 66],
			[6, 26, 48, 70],
			[6, 26, 50, 74],
			[6, 30, 54, 78],
			[6, 30, 56, 82],
			[6, 30, 58, 86],
			[6, 34, 62, 90],
			[6, 28, 50, 72, 94],
			[6, 26, 50, 74, 98],
			[6, 30, 54, 78, 102],
			[6, 28, 54, 80, 106],
			[6, 32, 58, 84, 110],
			[6, 30, 58, 86, 114],
			[6, 34, 62, 90, 118],
			[6, 26, 50, 74, 98, 122],
			[6, 30, 54, 78, 102, 126],
			[6, 26, 52, 78, 104, 130],
			[6, 30, 56, 82, 108, 134],
			[6, 34, 60, 86, 112, 138],
			[6, 30, 58, 86, 114, 142],
			[6, 34, 62, 90, 118, 146],
			[6, 30, 54, 78, 102, 126, 150],
			[6, 24, 50, 76, 102, 128, 154],
			[6, 28, 54, 80, 106, 132, 158],
			[6, 32, 58, 84, 110, 136, 162],
			[6, 26, 54, 82, 110, 138, 166],
			[6, 30, 58, 86, 114, 142, 170]
		];
		var G15 = (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0);
		var G18 = (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0);
		var G15_MASK = (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1);

		var _this = {};

		var getBCHDigit = function(data) {
			var digit = 0;
			while (data != 0) {
				digit += 1;
				data >>>= 1;
			}
			return digit;
		};

		_this.getBCHTypeInfo = function(data) {
			var d = data << 10;
			while (getBCHDigit(d) - getBCHDigit(G15) >= 0) {
				d ^= (G15 << (getBCHDigit(d) - getBCHDigit(G15) ) );
			}
			return ( (data << 10) | d) ^ G15_MASK;
		};

		_this.getBCHTypeNumber = function(data) {
			var d = data << 12;
			while (getBCHDigit(d) - getBCHDigit(G18) >= 0) {
				d ^= (G18 << (getBCHDigit(d) - getBCHDigit(G18) ) );
			}
			return (data << 12) | d;
		};

		_this.getPatternPosition = function(typeNumber) {
			return PATTERN_POSITION_TABLE[typeNumber - 1];
		};

		_this.getMaskFunction = function(maskPattern) {

			switch (maskPattern) {

			case QRMaskPattern.PATTERN000 :
				return function(i, j) { return (i + j) % 2 == 0; };
			case QRMaskPattern.PATTERN001 :
				return function(i, j) { return i % 2 == 0; };
			case QRMaskPattern.PATTERN010 :
				return function(i, j) { return j % 3 == 0; };
			case QRMaskPattern.PATTERN011 :
				return function(i, j) { return (i + j) % 3 == 0; };
			case QRMaskPattern.PATTERN100 :
				return function(i, j) { return (Math.floor(i / 2) + Math.floor(j / 3) ) % 2 == 0; };
			case QRMaskPattern.PATTERN101 :
				return function(i, j) { return (i * j) % 2 + (i * j) % 3 == 0; };
			case QRMaskPattern.PATTERN110 :
				return function(i, j) { return ( (i * j) % 2 + (i * j) % 3) % 2 == 0; };
			case QRMaskPattern.PATTERN111 :
				return function(i, j) { return ( (i * j) % 3 + (i + j) % 2) % 2 == 0; };

			default :
				throw new Error('bad maskPattern:' + maskPattern);
			}
		};

		_this.getErrorCorrectPolynomial = function(errorCorrectLength) {
			var a = qrPolynomial([1], 0);
			for (var i = 0; i < errorCorrectLength; i += 1) {
				a = a.multiply(qrPolynomial([1, QRMath.gexp(i)], 0) );
			}
			return a;
		};

		_this.getLengthInBits = function(mode, type) {

			if (1 <= type && type < 10) {

				// 1 - 9

				switch(mode) {
				case QRMode.MODE_NUMBER 	: return 10;
				case QRMode.MODE_ALPHA_NUM 	: return 9;
				case QRMode.MODE_8BIT_BYTE	: return 8;
				case QRMode.MODE_KANJI		: return 8;
				default :
					throw new Error('mode:' + mode);
				}

			} else if (type < 27) {

				// 10 - 26

				switch(mode) {
				case QRMode.MODE_NUMBER 	: return 12;
				case QRMode.MODE_ALPHA_NUM 	: return 11;
				case QRMode.MODE_8BIT_BYTE	: return 16;
				case QRMode.MODE_KANJI		: return 10;
				default :
					throw new Error('mode:' + mode);
				}

			} else if (type < 41) {

				// 27 - 40

				switch(mode) {
				case QRMode.MODE_NUMBER 	: return 14;
				case QRMode.MODE_ALPHA_NUM	: return 13;
				case QRMode.MODE_8BIT_BYTE	: return 16;
				case QRMode.MODE_KANJI		: return 12;
				default :
					throw new Error('mode:' + mode);
				}

			} else {
				throw new Error('type:' + type);
			}
		};

		_this.getLostPoint = function(qrcode) {

			var moduleCount = qrcode.getModuleCount();

			var lostPoint = 0;

			// LEVEL1

			for (var row = 0; row < moduleCount; row += 1) {
				for (var col = 0; col < moduleCount; col += 1) {

					var sameCount = 0;
					var dark = qrcode.isDark(row, col);

					for (var r = -1; r <= 1; r += 1) {

						if (row + r < 0 || moduleCount <= row + r) {
							continue;
						}

						for (var c = -1; c <= 1; c += 1) {

							if (col + c < 0 || moduleCount <= col + c) {
								continue;
							}

							if (r == 0 && c == 0) {
								continue;
							}

							if (dark == qrcode.isDark(row + r, col + c) ) {
								sameCount += 1;
							}
						}
					}

					if (sameCount > 5) {
						lostPoint += (3 + sameCount - 5);
					}
				}
			};

			// LEVEL2

			for (var row = 0; row < moduleCount - 1; row += 1) {
				for (var col = 0; col < moduleCount - 1; col += 1) {
					var count = 0;
					if (qrcode.isDark(row, col) ) count += 1;
					if (qrcode.isDark(row + 1, col) ) count += 1;
					if (qrcode.isDark(row, col + 1) ) count += 1;
					if (qrcode.isDark(row + 1, col + 1) ) count += 1;
					if (count == 0 || count == 4) {
						lostPoint += 3;
					}
				}
			}

			// LEVEL3

			for (var row = 0; row < moduleCount; row += 1) {
				for (var col = 0; col < moduleCount - 6; col += 1) {
					if (qrcode.isDark(row, col)
							&& !qrcode.isDark(row, col + 1)
							&&  qrcode.isDark(row, col + 2)
							&&  qrcode.isDark(row, col + 3)
							&&  qrcode.isDark(row, col + 4)
							&& !qrcode.isDark(row, col + 5)
							&&  qrcode.isDark(row, col + 6) ) {
						lostPoint += 40;
					}
				}
			}

			for (var col = 0; col < moduleCount; col += 1) {
				for (var row = 0; row < moduleCount - 6; row += 1) {
					if (qrcode.isDark(row, col)
							&& !qrcode.isDark(row + 1, col)
							&&  qrcode.isDark(row + 2, col)
							&&  qrcode.isDark(row + 3, col)
							&&  qrcode.isDark(row + 4, col)
							&& !qrcode.isDark(row + 5, col)
							&&  qrcode.isDark(row + 6, col) ) {
						lostPoint += 40;
					}
				}
			}

			// LEVEL4

			var darkCount = 0;

			for (var col = 0; col < moduleCount; col += 1) {
				for (var row = 0; row < moduleCount; row += 1) {
					if (qrcode.isDark(row, col) ) {
						darkCount += 1;
					}
				}
			}

			var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
			lostPoint += ratio * 10;

			return lostPoint;
		};

		return _this;
	}();

	//---------------------------------------------------------------------
	// QRMath
	//---------------------------------------------------------------------

	var QRMath = function() {

		var EXP_TABLE = new Array(256);
		var LOG_TABLE = new Array(256);

		// initialize tables
		for (var i = 0; i < 8; i += 1) {
			EXP_TABLE[i] = 1 << i;
		}
		for (var i = 8; i < 256; i += 1) {
			EXP_TABLE[i] = EXP_TABLE[i - 4]
				^ EXP_TABLE[i - 5]
				^ EXP_TABLE[i - 6]
				^ EXP_TABLE[i - 8];
		}
		for (var i = 0; i < 255; i += 1) {
			LOG_TABLE[EXP_TABLE[i] ] = i;
		}

		var _this = {};

		_this.glog = function(n) {

			if (n < 1) {
				throw new Error('glog(' + n + ')');
			}

			return LOG_TABLE[n];
		};

		_this.gexp = function(n) {

			while (n < 0) {
				n += 255;
			}

			while (n >= 256) {
				n -= 255;
			}

			return EXP_TABLE[n];
		};

		return _this;
	}();

	//---------------------------------------------------------------------
	// qrPolynomial
	//---------------------------------------------------------------------

	function qrPolynomial(num, shift) {

		if (typeof num.length == 'undefined') {
			throw new Error(num.length + '/' + shift);
		}

		var _num = function() {
			var offset = 0;
			while (offset < num.length && num[offset] == 0) {
				offset += 1;
			}
			var _num = new Array(num.length - offset + shift);
			for (var i = 0; i < num.length - offset; i += 1) {
				_num[i] = num[i + offset];
			}
			return _num;
		}();

		var _this = {};

		_this.get = function(index) {
			return _num[index];
		};

		_this.getLength = function() {
			return _num.length;
		};

		_this.multiply = function(e) {

			var num = new Array(_this.getLength() + e.getLength() - 1);

			for (var i = 0; i < _this.getLength(); i += 1) {
				for (var j = 0; j < e.getLength(); j += 1) {
					num[i + j] ^= QRMath.gexp(QRMath.glog(_this.get(i) ) + QRMath.glog(e.get(j) ) );
				}
			}

			return qrPolynomial(num, 0);
		};

		_this.mod = function(e) {

			if (_this.getLength() - e.getLength() < 0) {
				return _this;
			}

			var ratio = QRMath.glog(_this.get(0) ) - QRMath.glog(e.get(0) );

			var num = new Array(_this.getLength() );
			for (var i = 0; i < _this.getLength(); i += 1) {
				num[i] = _this.get(i);
			}

			for (var i = 0; i < e.getLength(); i += 1) {
				num[i] ^= QRMath.gexp(QRMath.glog(e.get(i) ) + ratio);
			}

			// recursive call
			return qrPolynomial(num, 0).mod(e);
		};

		return _this;
	};

	//---------------------------------------------------------------------
	// QRRSBlock
	//---------------------------------------------------------------------

	var QRRSBlock = function() {

		var RS_BLOCK_TABLE = [

			// L
			// M
			// Q
			// H

			// 1
			[1, 26, 19],
			[1, 26, 16],
			[1, 26, 13],
			[1, 26, 9],

			// 2
			[1, 44, 34],
			[1, 44, 28],
			[1, 44, 22],
			[1, 44, 16],

			// 3
			[1, 70, 55],
			[1, 70, 44],
			[2, 35, 17],
			[2, 35, 13],

			// 4
			[1, 100, 80],
			[2, 50, 32],
			[2, 50, 24],
			[4, 25, 9],

			// 5
			[1, 134, 108],
			[2, 67, 43],
			[2, 33, 15, 2, 34, 16],
			[2, 33, 11, 2, 34, 12],

			// 6
			[2, 86, 68],
			[4, 43, 27],
			[4, 43, 19],
			[4, 43, 15],

			// 7
			[2, 98, 78],
			[4, 49, 31],
			[2, 32, 14, 4, 33, 15],
			[4, 39, 13, 1, 40, 14],

			// 8
			[2, 121, 97],
			[2, 60, 38, 2, 61, 39],
			[4, 40, 18, 2, 41, 19],
			[4, 40, 14, 2, 41, 15],

			// 9
			[2, 146, 116],
			[3, 58, 36, 2, 59, 37],
			[4, 36, 16, 4, 37, 17],
			[4, 36, 12, 4, 37, 13],

			// 10
			[2, 86, 68, 2, 87, 69],
			[4, 69, 43, 1, 70, 44],
			[6, 43, 19, 2, 44, 20],
			[6, 43, 15, 2, 44, 16]
		];

		var qrRSBlock = function(totalCount, dataCount) {
			var _this = {};
			_this.totalCount = totalCount;
			_this.dataCount = dataCount;
			return _this;
		};

		var _this = {};

		var getRsBlockTable = function(typeNumber, errorCorrectLevel) {

			switch(errorCorrectLevel) {
			case QRErrorCorrectLevel.L :
				return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
			case QRErrorCorrectLevel.M :
				return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
			case QRErrorCorrectLevel.Q :
				return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
			case QRErrorCorrectLevel.H :
				return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
			default :
				return undefined;
			}
		};

		_this.getRSBlocks = function(typeNumber, errorCorrectLevel) {

			var rsBlock = getRsBlockTable(typeNumber, errorCorrectLevel);

			if (typeof rsBlock == 'undefined') {
				throw new Error('bad rs block @ typeNumber:' + typeNumber +
						'/errorCorrectLevel:' + errorCorrectLevel);
			}

			var length = rsBlock.length / 3;

			var list = new Array();

			for (var i = 0; i < length; i += 1) {

				var count = rsBlock[i * 3 + 0];
				var totalCount = rsBlock[i * 3 + 1];
				var dataCount = rsBlock[i * 3 + 2];

				for (var j = 0; j < count; j += 1) {
					list.push(qrRSBlock(totalCount, dataCount) );
				}
			}

			return list;
		};

		return _this;
	}();

	//---------------------------------------------------------------------
	// qrBitBuffer
	//---------------------------------------------------------------------

	var qrBitBuffer = function() {

		var _buffer = new Array();
		var _length = 0;

		var _this = {};

		_this.getBuffer = function() {
			return _buffer;
		};

		_this.get = function(index) {
			var bufIndex = Math.floor(index / 8);
			return ( (_buffer[bufIndex] >>> (7 - index % 8) ) & 1) == 1;
		};

		_this.put = function(num, length) {
			for (var i = 0; i < length; i += 1) {
				_this.putBit( ( (num >>> (length - i - 1) ) & 1) == 1);
			}
		};

		_this.getLengthInBits = function() {
			return _length;
		};

		_this.putBit = function(bit) {

			var bufIndex = Math.floor(_length / 8);
			if (_buffer.length <= bufIndex) {
				_buffer.push(0);
			}

			if (bit) {
				_buffer[bufIndex] |= (0x80 >>> (_length % 8) );
			}

			_length += 1;
		};

		return _this;
	};

	//---------------------------------------------------------------------
	// qr8BitByte
	//---------------------------------------------------------------------

	var qr8BitByte = function(data) {

		var _mode = QRMode.MODE_8BIT_BYTE;
		var _data = data;
		var _bytes = qrcode.stringToBytes(data);

		var _this = {};

		_this.getMode = function() {
			return _mode;
		};

		_this.getLength = function(buffer) {
			return _bytes.length;
		};

		_this.write = function(buffer) {
			for (var i = 0; i < _bytes.length; i += 1) {
				buffer.put(_bytes[i], 8);
			}
		};

		return _this;
	};

	//=====================================================================
	// GIF Support etc.
	//

	//---------------------------------------------------------------------
	// byteArrayOutputStream
	//---------------------------------------------------------------------

	var byteArrayOutputStream = function() {

		var _bytes = new Array();

		var _this = {};

		_this.writeByte = function(b) {
			_bytes.push(b & 0xff);
		};

		_this.writeShort = function(i) {
			_this.writeByte(i);
			_this.writeByte(i >>> 8);
		};

		_this.writeBytes = function(b, off, len) {
			off = off || 0;
			len = len || b.length;
			for (var i = 0; i < len; i += 1) {
				_this.writeByte(b[i + off]);
			}
		};

		_this.writeString = function(s) {
			for (var i = 0; i < s.length; i += 1) {
				_this.writeByte(s.charCodeAt(i) );
			}
		};

		_this.toByteArray = function() {
			return _bytes;
		};

		_this.toString = function() {
			var s = '';
			s += '[';
			for (var i = 0; i < _bytes.length; i += 1) {
				if (i > 0) {
					s += ',';
				}
				s += _bytes[i];
			}
			s += ']';
			return s;
		};

		return _this;
	};

	//---------------------------------------------------------------------
	// base64EncodeOutputStream
	//---------------------------------------------------------------------

	var base64EncodeOutputStream = function() {

		var _buffer = 0;
		var _buflen = 0;
		var _length = 0;
		var _base64 = '';

		var _this = {};

		var writeEncoded = function(b) {
			_base64 += String.fromCharCode(encode(b & 0x3f) );
		};

		var encode = function(n) {
			if (n < 0) {
				// error.
			} else if (n < 26) {
				return 0x41 + n;
			} else if (n < 52) {
				return 0x61 + (n - 26);
			} else if (n < 62) {
				return 0x30 + (n - 52);
			} else if (n == 62) {
				return 0x2b;
			} else if (n == 63) {
				return 0x2f;
			}
			throw new Error('n:' + n);
		};

		_this.writeByte = function(n) {

			_buffer = (_buffer << 8) | (n & 0xff);
			_buflen += 8;
			_length += 1;

			while (_buflen >= 6) {
				writeEncoded(_buffer >>> (_buflen - 6) );
				_buflen -= 6;
			}
		};

		_this.flush = function() {

			if (_buflen > 0) {
				writeEncoded(_buffer << (6 - _buflen) );
				_buffer = 0;
				_buflen = 0;
			}

			if (_length % 3 != 0) {
				// padding
				var padlen = 3 - _length % 3;
				for (var i = 0; i < padlen; i += 1) {
					_base64 += '=';
				}
			}
		};

		_this.toString = function() {
			return _base64;
		};

		return _this;
	};

	//---------------------------------------------------------------------
	// base64DecodeInputStream
	//---------------------------------------------------------------------

	var base64DecodeInputStream = function(str) {

		var _str = str;
		var _pos = 0;
		var _buffer = 0;
		var _buflen = 0;

		var _this = {};

		_this.read = function() {

			while (_buflen < 8) {

				if (_pos >= _str.length) {
					if (_buflen == 0) {
						return -1;
					}
					throw new Error('unexpected end of file./' + _buflen);
				}

				var c = _str.charAt(_pos);
				_pos += 1;

				if (c == '=') {
					_buflen = 0;
					return -1;
				} else if (c.match(/^\s$/) ) {
					// ignore if whitespace.
					continue;
				}

				_buffer = (_buffer << 6) | decode(c.charCodeAt(0) );
				_buflen += 6;
			}

			var n = (_buffer >>> (_buflen - 8) ) & 0xff;
			_buflen -= 8;
			return n;
		};

		var decode = function(c) {
			if (0x41 <= c && c <= 0x5a) {
				return c - 0x41;
			} else if (0x61 <= c && c <= 0x7a) {
				return c - 0x61 + 26;
			} else if (0x30 <= c && c <= 0x39) {
				return c - 0x30 + 52;
			} else if (c == 0x2b) {
				return 62;
			} else if (c == 0x2f) {
				return 63;
			} else {
				throw new Error('c:' + c);
			}
		};

		return _this;
	};

	//---------------------------------------------------------------------
	// gifImage (B/W)
	//---------------------------------------------------------------------

	var gifImage = function(width, height) {

		var _width = width;
		var _height = height;
		var _data = new Array(width * height);

		var _this = {};

		_this.setPixel = function(x, y, pixel) {
			_data[y * _width + x] = pixel;
		};

		_this.write = function(out) {

			//---------------------------------
			// GIF Signature

			out.writeString('GIF87a');

			//---------------------------------
			// Screen Descriptor

			out.writeShort(_width);
			out.writeShort(_height);

			out.writeByte(0x80); // 2bit
			out.writeByte(0);
			out.writeByte(0);

			//---------------------------------
			// Global Color Map

			// black
			out.writeByte(0x00);
			out.writeByte(0x00);
			out.writeByte(0x00);

			// white
			out.writeByte(0xff);
			out.writeByte(0xff);
			out.writeByte(0xff);

			//---------------------------------
			// Image Descriptor

			out.writeString(',');
			out.writeShort(0);
			out.writeShort(0);
			out.writeShort(_width);
			out.writeShort(_height);
			out.writeByte(0);

			//---------------------------------
			// Local Color Map

			//---------------------------------
			// Raster Data

			var lzwMinCodeSize = 2;
			var raster = getLZWRaster(lzwMinCodeSize);

			out.writeByte(lzwMinCodeSize);

			var offset = 0;

			while (raster.length - offset > 255) {
				out.writeByte(255);
				out.writeBytes(raster, offset, 255);
				offset += 255;
			}

			out.writeByte(raster.length - offset);
			out.writeBytes(raster, offset, raster.length - offset);
			out.writeByte(0x00);

			//---------------------------------
			// GIF Terminator
			out.writeString(';');
		};

		var bitOutputStream = function(out) {

			var _out = out;
			var _bitLength = 0;
			var _bitBuffer = 0;

			var _this = {};

			_this.write = function(data, length) {

				if ( (data >>> length) != 0) {
					throw new Error('length over');
				}

				while (_bitLength + length >= 8) {
					_out.writeByte(0xff & ( (data << _bitLength) | _bitBuffer) );
					length -= (8 - _bitLength);
					data >>>= (8 - _bitLength);
					_bitBuffer = 0;
					_bitLength = 0;
				}

				_bitBuffer = (data << _bitLength) | _bitBuffer;
				_bitLength = _bitLength + length;
			};

			_this.flush = function() {
				if (_bitLength > 0) {
					_out.writeByte(_bitBuffer);
				}
			};

			return _this;
		};

		var getLZWRaster = function(lzwMinCodeSize) {

			var clearCode = 1 << lzwMinCodeSize;
			var endCode = (1 << lzwMinCodeSize) + 1;
			var bitLength = lzwMinCodeSize + 1;

			// Setup LZWTable
			var table = lzwTable();

			for (var i = 0; i < clearCode; i += 1) {
				table.add(String.fromCharCode(i) );
			}
			table.add(String.fromCharCode(clearCode) );
			table.add(String.fromCharCode(endCode) );

			var byteOut = byteArrayOutputStream();
			var bitOut = bitOutputStream(byteOut);

			// clear code
			bitOut.write(clearCode, bitLength);

			var dataIndex = 0;

			var s = String.fromCharCode(_data[dataIndex]);
			dataIndex += 1;

			while (dataIndex < _data.length) {

				var c = String.fromCharCode(_data[dataIndex]);
				dataIndex += 1;

				if (table.contains(s + c) ) {

					s = s + c;

				} else {

					bitOut.write(table.indexOf(s), bitLength);

					if (table.size() < 0xfff) {

						if (table.size() == (1 << bitLength) ) {
							bitLength += 1;
						}

						table.add(s + c);
					}

					s = c;
				}
			}

			bitOut.write(table.indexOf(s), bitLength);

			// end code
			bitOut.write(endCode, bitLength);

			bitOut.flush();

			return byteOut.toByteArray();
		};

		var lzwTable = function() {

			var _map = {};
			var _size = 0;

			var _this = {};

			_this.add = function(key) {
				if (_this.contains(key) ) {
					throw new Error('dup key:' + key);
				}
				_map[key] = _size;
				_size += 1;
			};

			_this.size = function() {
				return _size;
			};

			_this.indexOf = function(key) {
				return _map[key];
			};

			_this.contains = function(key) {
				return typeof _map[key] != 'undefined';
			};

			return _this;
		};

		return _this;
	};

	var createImgTag = function(width, height, getPixel, alt) {

		var gif = gifImage(width, height);
		for (var y = 0; y < height; y += 1) {
			for (var x = 0; x < width; x += 1) {
				gif.setPixel(x, y, getPixel(x, y) );
			}
		}

		var b = byteArrayOutputStream();
		gif.write(b);

		var base64 = base64EncodeOutputStream();
		var bytes = b.toByteArray();
		for (var i = 0; i < bytes.length; i += 1) {
			base64.writeByte(bytes[i]);
		}
		base64.flush();

		var img = '';
		img += '<img';
		img += '\u0020src="';
		img += 'data:image/gif;base64,';
		img += base64;
		img += '"';
		img += '\u0020width="';
		img += width;
		img += '"';
		img += '\u0020height="';
		img += height;
		img += '"';
		if (alt) {
			img += '\u0020alt="';
			img += alt;
			img += '"';
		}
		img += '/>';

		return img;
	};

	//---------------------------------------------------------------------
	// returns qrcode function.

	return qrcode;
}();
</script>

<!-- =================================== end content of qrcode.js =============================================== -->
<!-- Source: https://crypto.stanford.edu/sjcl/  referring to: https://github.com/bitwiseshiftleft/sjcl -->
<!-- <script type="text/javascript" src="../../scripts/sjcl.js"></script> -->
<!-- Copy the content of sjcl.js on this page -->
<script language="JavaScript" type="text/javascript">
"use strict";function q(a){throw a;}var t=void 0,u=!1;var sjcl={cipher:{},hash:{},keyexchange:{},mode:{},misc:{},codec:{},exception:{corrupt:function(a){this.toString=function(){return"CORRUPT: "+this.message};this.message=a},invalid:function(a){this.toString=function(){return"INVALID: "+this.message};this.message=a},bug:function(a){this.toString=function(){return"BUG: "+this.message};this.message=a},notReady:function(a){this.toString=function(){return"NOT READY: "+this.message};this.message=a}}};
"undefined"!==typeof module&&module.exports&&(module.exports=sjcl);
sjcl.cipher.aes=function(a){this.k[0][0][0]||this.D();var b,c,d,e,f=this.k[0][4],g=this.k[1];b=a.length;var h=1;4!==b&&(6!==b&&8!==b)&&q(new sjcl.exception.invalid("invalid aes key size"));this.b=[d=a.slice(0),e=[]];for(a=b;a<4*b+28;a++){c=d[a-1];if(0===a%b||8===b&&4===a%b)c=f[c>>>24]<<24^f[c>>16&255]<<16^f[c>>8&255]<<8^f[c&255],0===a%b&&(c=c<<8^c>>>24^h<<24,h=h<<1^283*(h>>7));d[a]=d[a-b]^c}for(b=0;a;b++,a--)c=d[b&3?a:a-4],e[b]=4>=a||4>b?c:g[0][f[c>>>24]]^g[1][f[c>>16&255]]^g[2][f[c>>8&255]]^g[3][f[c&
255]]};
sjcl.cipher.aes.prototype={encrypt:function(a){return y(this,a,0)},decrypt:function(a){return y(this,a,1)},k:[[[],[],[],[],[]],[[],[],[],[],[]]],D:function(){var a=this.k[0],b=this.k[1],c=a[4],d=b[4],e,f,g,h=[],l=[],k,n,m,p;for(e=0;0x100>e;e++)l[(h[e]=e<<1^283*(e>>7))^e]=e;for(f=g=0;!c[f];f^=k||1,g=l[g]||1){m=g^g<<1^g<<2^g<<3^g<<4;m=m>>8^m&255^99;c[f]=m;d[m]=f;n=h[e=h[k=h[f]]];p=0x1010101*n^0x10001*e^0x101*k^0x1010100*f;n=0x101*h[m]^0x1010100*m;for(e=0;4>e;e++)a[e][f]=n=n<<24^n>>>8,b[e][m]=p=p<<24^p>>>8}for(e=
0;5>e;e++)a[e]=a[e].slice(0),b[e]=b[e].slice(0)}};
function y(a,b,c){4!==b.length&&q(new sjcl.exception.invalid("invalid aes block size"));var d=a.b[c],e=b[0]^d[0],f=b[c?3:1]^d[1],g=b[2]^d[2];b=b[c?1:3]^d[3];var h,l,k,n=d.length/4-2,m,p=4,s=[0,0,0,0];h=a.k[c];a=h[0];var r=h[1],v=h[2],w=h[3],x=h[4];for(m=0;m<n;m++)h=a[e>>>24]^r[f>>16&255]^v[g>>8&255]^w[b&255]^d[p],l=a[f>>>24]^r[g>>16&255]^v[b>>8&255]^w[e&255]^d[p+1],k=a[g>>>24]^r[b>>16&255]^v[e>>8&255]^w[f&255]^d[p+2],b=a[b>>>24]^r[e>>16&255]^v[f>>8&255]^w[g&255]^d[p+3],p+=4,e=h,f=l,g=k;for(m=0;4>
m;m++)s[c?3&-m:m]=x[e>>>24]<<24^x[f>>16&255]<<16^x[g>>8&255]<<8^x[b&255]^d[p++],h=e,e=f,f=g,g=b,b=h;return s}
sjcl.bitArray={bitSlice:function(a,b,c){a=sjcl.bitArray.P(a.slice(b/32),32-(b&31)).slice(1);return c===t?a:sjcl.bitArray.clamp(a,c-b)},extract:function(a,b,c){var d=Math.floor(-b-c&31);return((b+c-1^b)&-32?a[b/32|0]<<32-d^a[b/32+1|0]>>>d:a[b/32|0]>>>d)&(1<<c)-1},concat:function(a,b){if(0===a.length||0===b.length)return a.concat(b);var c=a[a.length-1],d=sjcl.bitArray.getPartial(c);return 32===d?a.concat(b):sjcl.bitArray.P(b,d,c|0,a.slice(0,a.length-1))},bitLength:function(a){var b=a.length;return 0===
b?0:32*(b-1)+sjcl.bitArray.getPartial(a[b-1])},clamp:function(a,b){if(32*a.length<b)return a;a=a.slice(0,Math.ceil(b/32));var c=a.length;b&=31;0<c&&b&&(a[c-1]=sjcl.bitArray.partial(b,a[c-1]&2147483648>>b-1,1));return a},partial:function(a,b,c){return 32===a?b:(c?b|0:b<<32-a)+0x10000000000*a},getPartial:function(a){return Math.round(a/0x10000000000)||32},equal:function(a,b){if(sjcl.bitArray.bitLength(a)!==sjcl.bitArray.bitLength(b))return u;var c=0,d;for(d=0;d<a.length;d++)c|=a[d]^b[d];return 0===
c},P:function(a,b,c,d){var e;e=0;for(d===t&&(d=[]);32<=b;b-=32)d.push(c),c=0;if(0===b)return d.concat(a);for(e=0;e<a.length;e++)d.push(c|a[e]>>>b),c=a[e]<<32-b;e=a.length?a[a.length-1]:0;a=sjcl.bitArray.getPartial(e);d.push(sjcl.bitArray.partial(b+a&31,32<b+a?c:d.pop(),1));return d},l:function(a,b){return[a[0]^b[0],a[1]^b[1],a[2]^b[2],a[3]^b[3]]}};
sjcl.codec.utf8String={fromBits:function(a){var b="",c=sjcl.bitArray.bitLength(a),d,e;for(d=0;d<c/8;d++)0===(d&3)&&(e=a[d/4]),b+=String.fromCharCode(e>>>24),e<<=8;return decodeURIComponent(escape(b))},toBits:function(a){a=unescape(encodeURIComponent(a));var b=[],c,d=0;for(c=0;c<a.length;c++)d=d<<8|a.charCodeAt(c),3===(c&3)&&(b.push(d),d=0);c&3&&b.push(sjcl.bitArray.partial(8*(c&3),d));return b}};
sjcl.codec.hex={fromBits:function(a){var b="",c;for(c=0;c<a.length;c++)b+=((a[c]|0)+0xf00000000000).toString(16).substr(4);return b.substr(0,sjcl.bitArray.bitLength(a)/4)},toBits:function(a){var b,c=[],d;a=a.replace(/\s|0x/g,"");d=a.length;a+="00000000";for(b=0;b<a.length;b+=8)c.push(parseInt(a.substr(b,8),16)^0);return sjcl.bitArray.clamp(c,4*d)}};
sjcl.codec.base64={J:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",fromBits:function(a,b,c){var d="",e=0,f=sjcl.codec.base64.J,g=0,h=sjcl.bitArray.bitLength(a);c&&(f=f.substr(0,62)+"-_");for(c=0;6*d.length<=h;)d+=f.charAt((g^a[c]>>>e)>>>26),6>e?(g=a[c]<<6-e,e+=26,c++):(g<<=6,e-=6);for(;d.length&3&&!b;)d+="=";return d},toBits:function(a,b){a=a.replace(/\s|=/g,"");var c=[],d,e=0,f=sjcl.codec.base64.J,g=0,h;b&&(f=f.substr(0,62)+"-_");for(d=0;d<a.length;d++)h=f.indexOf(a.charAt(d)),
0>h&&q(new sjcl.exception.invalid("this isn't base64!")),26<e?(e-=26,c.push(g^h>>>e),g=h<<32-e):(e+=6,g^=h<<32-e);e&56&&c.push(sjcl.bitArray.partial(e&56,g,1));return c}};sjcl.codec.base64url={fromBits:function(a){return sjcl.codec.base64.fromBits(a,1,1)},toBits:function(a){return sjcl.codec.base64.toBits(a,1)}};sjcl.hash.sha256=function(a){this.b[0]||this.D();a?(this.r=a.r.slice(0),this.o=a.o.slice(0),this.h=a.h):this.reset()};sjcl.hash.sha256.hash=function(a){return(new sjcl.hash.sha256).update(a).finalize()};
sjcl.hash.sha256.prototype={blockSize:512,reset:function(){this.r=this.N.slice(0);this.o=[];this.h=0;return this},update:function(a){"string"===typeof a&&(a=sjcl.codec.utf8String.toBits(a));var b,c=this.o=sjcl.bitArray.concat(this.o,a);b=this.h;a=this.h=b+sjcl.bitArray.bitLength(a);for(b=512+b&-512;b<=a;b+=512)z(this,c.splice(0,16));return this},finalize:function(){var a,b=this.o,c=this.r,b=sjcl.bitArray.concat(b,[sjcl.bitArray.partial(1,1)]);for(a=b.length+2;a&15;a++)b.push(0);b.push(Math.floor(this.h/
4294967296));for(b.push(this.h|0);b.length;)z(this,b.splice(0,16));this.reset();return c},N:[],b:[],D:function(){function a(a){return 0x100000000*(a-Math.floor(a))|0}var b=0,c=2,d;a:for(;64>b;c++){for(d=2;d*d<=c;d++)if(0===c%d)continue a;8>b&&(this.N[b]=a(Math.pow(c,0.5)));this.b[b]=a(Math.pow(c,1/3));b++}}};
function z(a,b){var c,d,e,f=b.slice(0),g=a.r,h=a.b,l=g[0],k=g[1],n=g[2],m=g[3],p=g[4],s=g[5],r=g[6],v=g[7];for(c=0;64>c;c++)16>c?d=f[c]:(d=f[c+1&15],e=f[c+14&15],d=f[c&15]=(d>>>7^d>>>18^d>>>3^d<<25^d<<14)+(e>>>17^e>>>19^e>>>10^e<<15^e<<13)+f[c&15]+f[c+9&15]|0),d=d+v+(p>>>6^p>>>11^p>>>25^p<<26^p<<21^p<<7)+(r^p&(s^r))+h[c],v=r,r=s,s=p,p=m+d|0,m=n,n=k,k=l,l=d+(k&n^m&(k^n))+(k>>>2^k>>>13^k>>>22^k<<30^k<<19^k<<10)|0;g[0]=g[0]+l|0;g[1]=g[1]+k|0;g[2]=g[2]+n|0;g[3]=g[3]+m|0;g[4]=g[4]+p|0;g[5]=g[5]+s|0;g[6]=
g[6]+r|0;g[7]=g[7]+v|0}
sjcl.mode.ccm={name:"ccm",encrypt:function(a,b,c,d,e){var f,g=b.slice(0),h=sjcl.bitArray,l=h.bitLength(c)/8,k=h.bitLength(g)/8;e=e||64;d=d||[];7>l&&q(new sjcl.exception.invalid("ccm: iv must be at least 7 bytes"));for(f=2;4>f&&k>>>8*f;f++);f<15-l&&(f=15-l);c=h.clamp(c,8*(15-f));b=sjcl.mode.ccm.L(a,b,c,d,e,f);g=sjcl.mode.ccm.p(a,g,c,b,e,f);return h.concat(g.data,g.tag)},decrypt:function(a,b,c,d,e){e=e||64;d=d||[];var f=sjcl.bitArray,g=f.bitLength(c)/8,h=f.bitLength(b),l=f.clamp(b,h-e),k=f.bitSlice(b,
h-e),h=(h-e)/8;7>g&&q(new sjcl.exception.invalid("ccm: iv must be at least 7 bytes"));for(b=2;4>b&&h>>>8*b;b++);b<15-g&&(b=15-g);c=f.clamp(c,8*(15-b));l=sjcl.mode.ccm.p(a,l,c,k,e,b);a=sjcl.mode.ccm.L(a,l.data,c,d,e,b);f.equal(l.tag,a)||q(new sjcl.exception.corrupt("ccm: tag doesn't match"));return l.data},L:function(a,b,c,d,e,f){var g=[],h=sjcl.bitArray,l=h.l;e/=8;(e%2||4>e||16<e)&&q(new sjcl.exception.invalid("ccm: invalid tag length"));(0xffffffff<d.length||0xffffffff<b.length)&&q(new sjcl.exception.bug("ccm: can't deal with 4GiB or more data"));
f=[h.partial(8,(d.length?64:0)|e-2<<2|f-1)];f=h.concat(f,c);f[3]|=h.bitLength(b)/8;f=a.encrypt(f);if(d.length){c=h.bitLength(d)/8;65279>=c?g=[h.partial(16,c)]:0xffffffff>=c&&(g=h.concat([h.partial(16,65534)],[c]));g=h.concat(g,d);for(d=0;d<g.length;d+=4)f=a.encrypt(l(f,g.slice(d,d+4).concat([0,0,0])))}for(d=0;d<b.length;d+=4)f=a.encrypt(l(f,b.slice(d,d+4).concat([0,0,0])));return h.clamp(f,8*e)},p:function(a,b,c,d,e,f){var g,h=sjcl.bitArray;g=h.l;var l=b.length,k=h.bitLength(b);c=h.concat([h.partial(8,
f-1)],c).concat([0,0,0]).slice(0,4);d=h.bitSlice(g(d,a.encrypt(c)),0,e);if(!l)return{tag:d,data:[]};for(g=0;g<l;g+=4)c[3]++,e=a.encrypt(c),b[g]^=e[0],b[g+1]^=e[1],b[g+2]^=e[2],b[g+3]^=e[3];return{tag:d,data:h.clamp(b,k)}}};
sjcl.mode.ocb2={name:"ocb2",encrypt:function(a,b,c,d,e,f){128!==sjcl.bitArray.bitLength(c)&&q(new sjcl.exception.invalid("ocb iv must be 128 bits"));var g,h=sjcl.mode.ocb2.H,l=sjcl.bitArray,k=l.l,n=[0,0,0,0];c=h(a.encrypt(c));var m,p=[];d=d||[];e=e||64;for(g=0;g+4<b.length;g+=4)m=b.slice(g,g+4),n=k(n,m),p=p.concat(k(c,a.encrypt(k(c,m)))),c=h(c);m=b.slice(g);b=l.bitLength(m);g=a.encrypt(k(c,[0,0,0,b]));m=l.clamp(k(m.concat([0,0,0]),g),b);n=k(n,k(m.concat([0,0,0]),g));n=a.encrypt(k(n,k(c,h(c))));d.length&&
(n=k(n,f?d:sjcl.mode.ocb2.pmac(a,d)));return p.concat(l.concat(m,l.clamp(n,e)))},decrypt:function(a,b,c,d,e,f){128!==sjcl.bitArray.bitLength(c)&&q(new sjcl.exception.invalid("ocb iv must be 128 bits"));e=e||64;var g=sjcl.mode.ocb2.H,h=sjcl.bitArray,l=h.l,k=[0,0,0,0],n=g(a.encrypt(c)),m,p,s=sjcl.bitArray.bitLength(b)-e,r=[];d=d||[];for(c=0;c+4<s/32;c+=4)m=l(n,a.decrypt(l(n,b.slice(c,c+4)))),k=l(k,m),r=r.concat(m),n=g(n);p=s-32*c;m=a.encrypt(l(n,[0,0,0,p]));m=l(m,h.clamp(b.slice(c),p).concat([0,0,0]));
k=l(k,m);k=a.encrypt(l(k,l(n,g(n))));d.length&&(k=l(k,f?d:sjcl.mode.ocb2.pmac(a,d)));h.equal(h.clamp(k,e),h.bitSlice(b,s))||q(new sjcl.exception.corrupt("ocb: tag doesn't match"));return r.concat(h.clamp(m,p))},pmac:function(a,b){var c,d=sjcl.mode.ocb2.H,e=sjcl.bitArray,f=e.l,g=[0,0,0,0],h=a.encrypt([0,0,0,0]),h=f(h,d(d(h)));for(c=0;c+4<b.length;c+=4)h=d(h),g=f(g,a.encrypt(f(h,b.slice(c,c+4))));c=b.slice(c);128>e.bitLength(c)&&(h=f(h,d(h)),c=e.concat(c,[-2147483648,0,0,0]));g=f(g,c);return a.encrypt(f(d(f(h,
d(h))),g))},H:function(a){return[a[0]<<1^a[1]>>>31,a[1]<<1^a[2]>>>31,a[2]<<1^a[3]>>>31,a[3]<<1^135*(a[0]>>>31)]}};
sjcl.mode.gcm={name:"gcm",encrypt:function(a,b,c,d,e){var f=b.slice(0);b=sjcl.bitArray;d=d||[];a=sjcl.mode.gcm.p(!0,a,f,d,c,e||128);return b.concat(a.data,a.tag)},decrypt:function(a,b,c,d,e){var f=b.slice(0),g=sjcl.bitArray,h=g.bitLength(f);e=e||128;d=d||[];e<=h?(b=g.bitSlice(f,h-e),f=g.bitSlice(f,0,h-e)):(b=f,f=[]);a=sjcl.mode.gcm.p(u,a,f,d,c,e);g.equal(a.tag,b)||q(new sjcl.exception.corrupt("gcm: tag doesn't match"));return a.data},Z:function(a,b){var c,d,e,f,g,h=sjcl.bitArray.l;e=[0,0,0,0];f=b.slice(0);
for(c=0;128>c;c++){(d=0!==(a[Math.floor(c/32)]&1<<31-c%32))&&(e=h(e,f));g=0!==(f[3]&1);for(d=3;0<d;d--)f[d]=f[d]>>>1|(f[d-1]&1)<<31;f[0]>>>=1;g&&(f[0]^=-0x1f000000)}return e},g:function(a,b,c){var d,e=c.length;b=b.slice(0);for(d=0;d<e;d+=4)b[0]^=0xffffffff&c[d],b[1]^=0xffffffff&c[d+1],b[2]^=0xffffffff&c[d+2],b[3]^=0xffffffff&c[d+3],b=sjcl.mode.gcm.Z(b,a);return b},p:function(a,b,c,d,e,f){var g,h,l,k,n,m,p,s,r=sjcl.bitArray;m=c.length;p=r.bitLength(c);s=r.bitLength(d);h=r.bitLength(e);g=b.encrypt([0,
0,0,0]);96===h?(e=e.slice(0),e=r.concat(e,[1])):(e=sjcl.mode.gcm.g(g,[0,0,0,0],e),e=sjcl.mode.gcm.g(g,e,[0,0,Math.floor(h/0x100000000),h&0xffffffff]));h=sjcl.mode.gcm.g(g,[0,0,0,0],d);n=e.slice(0);d=h.slice(0);a||(d=sjcl.mode.gcm.g(g,h,c));for(k=0;k<m;k+=4)n[3]++,l=b.encrypt(n),c[k]^=l[0],c[k+1]^=l[1],c[k+2]^=l[2],c[k+3]^=l[3];c=r.clamp(c,p);a&&(d=sjcl.mode.gcm.g(g,h,c));a=[Math.floor(s/0x100000000),s&0xffffffff,Math.floor(p/0x100000000),p&0xffffffff];d=sjcl.mode.gcm.g(g,d,a);l=b.encrypt(e);d[0]^=l[0];
d[1]^=l[1];d[2]^=l[2];d[3]^=l[3];return{tag:r.bitSlice(d,0,f),data:c}}};sjcl.misc.hmac=function(a,b){this.M=b=b||sjcl.hash.sha256;var c=[[],[]],d,e=b.prototype.blockSize/32;this.n=[new b,new b];a.length>e&&(a=b.hash(a));for(d=0;d<e;d++)c[0][d]=a[d]^909522486,c[1][d]=a[d]^1549556828;this.n[0].update(c[0]);this.n[1].update(c[1]);this.G=new b(this.n[0])};
sjcl.misc.hmac.prototype.encrypt=sjcl.misc.hmac.prototype.mac=function(a){this.Q&&q(new sjcl.exception.invalid("encrypt on already updated hmac called!"));this.update(a);return this.digest(a)};sjcl.misc.hmac.prototype.reset=function(){this.G=new this.M(this.n[0]);this.Q=u};sjcl.misc.hmac.prototype.update=function(a){this.Q=!0;this.G.update(a)};sjcl.misc.hmac.prototype.digest=function(){var a=this.G.finalize(),a=(new this.M(this.n[1])).update(a).finalize();this.reset();return a};
sjcl.misc.pbkdf2=function(a,b,c,d,e){c=c||1E3;(0>d||0>c)&&q(sjcl.exception.invalid("invalid params to pbkdf2"));"string"===typeof a&&(a=sjcl.codec.utf8String.toBits(a));"string"===typeof b&&(b=sjcl.codec.utf8String.toBits(b));e=e||sjcl.misc.hmac;a=new e(a);var f,g,h,l,k=[],n=sjcl.bitArray;for(l=1;32*k.length<(d||1);l++){e=f=a.encrypt(n.concat(b,[l]));for(g=1;g<c;g++){f=a.encrypt(f);for(h=0;h<f.length;h++)e[h]^=f[h]}k=k.concat(e)}d&&(k=n.clamp(k,d));return k};
sjcl.prng=function(a){this.c=[new sjcl.hash.sha256];this.i=[0];this.F=0;this.s={};this.C=0;this.K={};this.O=this.d=this.j=this.W=0;this.b=[0,0,0,0,0,0,0,0];this.f=[0,0,0,0];this.A=t;this.B=a;this.q=u;this.w={progress:{},seeded:{}};this.m=this.V=0;this.t=1;this.u=2;this.S=0x10000;this.I=[0,48,64,96,128,192,0x100,384,512,768,1024];this.T=3E4;this.R=80};
sjcl.prng.prototype={randomWords:function(a,b){var c=[],d;d=this.isReady(b);var e;d===this.m&&q(new sjcl.exception.notReady("generator isn't seeded"));if(d&this.u){d=!(d&this.t);e=[];var f=0,g;this.O=e[0]=(new Date).valueOf()+this.T;for(g=0;16>g;g++)e.push(0x100000000*Math.random()|0);for(g=0;g<this.c.length&&!(e=e.concat(this.c[g].finalize()),f+=this.i[g],this.i[g]=0,!d&&this.F&1<<g);g++);this.F>=1<<this.c.length&&(this.c.push(new sjcl.hash.sha256),this.i.push(0));this.d-=f;f>this.j&&(this.j=f);this.F++;
this.b=sjcl.hash.sha256.hash(this.b.concat(e));this.A=new sjcl.cipher.aes(this.b);for(d=0;4>d&&!(this.f[d]=this.f[d]+1|0,this.f[d]);d++);}for(d=0;d<a;d+=4)0===(d+1)%this.S&&A(this),e=B(this),c.push(e[0],e[1],e[2],e[3]);A(this);return c.slice(0,a)},setDefaultParanoia:function(a,b){0===a&&"Setting paranoia=0 will ruin your security; use it only for testing"!==b&&q("Setting paranoia=0 will ruin your security; use it only for testing");this.B=a},addEntropy:function(a,b,c){c=c||"user";var d,e,f=(new Date).valueOf(),
g=this.s[c],h=this.isReady(),l=0;d=this.K[c];d===t&&(d=this.K[c]=this.W++);g===t&&(g=this.s[c]=0);this.s[c]=(this.s[c]+1)%this.c.length;switch(typeof a){case "number":b===t&&(b=1);this.c[g].update([d,this.C++,1,b,f,1,a|0]);break;case "object":c=Object.prototype.toString.call(a);if("[object Uint32Array]"===c){e=[];for(c=0;c<a.length;c++)e.push(a[c]);a=e}else{"[object Array]"!==c&&(l=1);for(c=0;c<a.length&&!l;c++)"number"!==typeof a[c]&&(l=1)}if(!l){if(b===t)for(c=b=0;c<a.length;c++)for(e=a[c];0<e;)b++,
e>>>=1;this.c[g].update([d,this.C++,2,b,f,a.length].concat(a))}break;case "string":b===t&&(b=a.length);this.c[g].update([d,this.C++,3,b,f,a.length]);this.c[g].update(a);break;default:l=1}l&&q(new sjcl.exception.bug("random: addEntropy only supports number, array of numbers or string"));this.i[g]+=b;this.d+=b;h===this.m&&(this.isReady()!==this.m&&C("seeded",Math.max(this.j,this.d)),C("progress",this.getProgress()))},isReady:function(a){a=this.I[a!==t?a:this.B];return this.j&&this.j>=a?this.i[0]>this.R&&
(new Date).valueOf()>this.O?this.u|this.t:this.t:this.d>=a?this.u|this.m:this.m},getProgress:function(a){a=this.I[a?a:this.B];return this.j>=a?1:this.d>a?1:this.d/a},startCollectors:function(){this.q||(this.a={loadTimeCollector:D(this,this.aa),mouseCollector:D(this,this.ba),keyboardCollector:D(this,this.$),accelerometerCollector:D(this,this.U)},window.addEventListener?(window.addEventListener("load",this.a.loadTimeCollector,u),window.addEventListener("mousemove",this.a.mouseCollector,u),window.addEventListener("keypress",
this.a.keyboardCollector,u),window.addEventListener("devicemotion",this.a.accelerometerCollector,u)):document.attachEvent?(document.attachEvent("onload",this.a.loadTimeCollector),document.attachEvent("onmousemove",this.a.mouseCollector),document.attachEvent("keypress",this.a.keyboardCollector)):q(new sjcl.exception.bug("can't attach event")),this.q=!0)},stopCollectors:function(){this.q&&(window.removeEventListener?(window.removeEventListener("load",this.a.loadTimeCollector,u),window.removeEventListener("mousemove",
this.a.mouseCollector,u),window.removeEventListener("keypress",this.a.keyboardCollector,u),window.removeEventListener("devicemotion",this.a.accelerometerCollector,u)):document.detachEvent&&(document.detachEvent("onload",this.a.loadTimeCollector),document.detachEvent("onmousemove",this.a.mouseCollector),document.detachEvent("keypress",this.a.keyboardCollector)),this.q=u)},addEventListener:function(a,b){this.w[a][this.V++]=b},removeEventListener:function(a,b){var c,d,e=this.w[a],f=[];for(d in e)e.hasOwnProperty(d)&&
e[d]===b&&f.push(d);for(c=0;c<f.length;c++)d=f[c],delete e[d]},$:function(){E(1)},ba:function(a){sjcl.random.addEntropy([a.x||a.clientX||a.offsetX||0,a.y||a.clientY||a.offsetY||0],2,"mouse");E(0)},aa:function(){E(2)},U:function(a){a=a.accelerationIncludingGravity.x||a.accelerationIncludingGravity.y||a.accelerationIncludingGravity.z;if(window.orientation){var b=window.orientation;"number"===typeof b&&sjcl.random.addEntropy(b,1,"accelerometer")}a&&sjcl.random.addEntropy(a,2,"accelerometer");E(0)}};
function C(a,b){var c,d=sjcl.random.w[a],e=[];for(c in d)d.hasOwnProperty(c)&&e.push(d[c]);for(c=0;c<e.length;c++)e[c](b)}function E(a){window&&window.performance&&"function"===typeof window.performance.now?sjcl.random.addEntropy(window.performance.now(),a,"loadtime"):sjcl.random.addEntropy((new Date).valueOf(),a,"loadtime")}function A(a){a.b=B(a).concat(B(a));a.A=new sjcl.cipher.aes(a.b)}function B(a){for(var b=0;4>b&&!(a.f[b]=a.f[b]+1|0,a.f[b]);b++);return a.A.encrypt(a.f)}
function D(a,b){return function(){b.apply(a,arguments)}}sjcl.random=new sjcl.prng(6);
a:try{var F,G,H,I;if(I="undefined"!==typeof module){var J;if(J=module.exports){var K;try{K=require("crypto")}catch(L){K=null}J=(G=K)&&G.randomBytes}I=J}if(I)F=G.randomBytes(128),F=new Uint32Array((new Uint8Array(F)).buffer),sjcl.random.addEntropy(F,1024,"crypto['randomBytes']");else if(window&&Uint32Array){H=new Uint32Array(32);if(window.crypto&&window.crypto.getRandomValues)window.crypto.getRandomValues(H);else if(window.msCrypto&&window.msCrypto.getRandomValues)window.msCrypto.getRandomValues(H);
else break a;sjcl.random.addEntropy(H,1024,"crypto['getRandomValues']")}}catch(M){"undefined"!==typeof window&&window.console&&(console.log("There was an error collecting entropy from the browser:"),console.log(M))}
sjcl.json={defaults:{v:1,iter:1E3,ks:128,ts:64,mode:"ccm",adata:"",cipher:"aes"},Y:function(a,b,c,d){c=c||{};d=d||{};var e=sjcl.json,f=e.e({iv:sjcl.random.randomWords(4,0)},e.defaults),g;e.e(f,c);c=f.adata;"string"===typeof f.salt&&(f.salt=sjcl.codec.base64.toBits(f.salt));"string"===typeof f.iv&&(f.iv=sjcl.codec.base64.toBits(f.iv));(!sjcl.mode[f.mode]||!sjcl.cipher[f.cipher]||"string"===typeof a&&100>=f.iter||64!==f.ts&&96!==f.ts&&128!==f.ts||128!==f.ks&&192!==f.ks&&0x100!==f.ks||2>f.iv.length||4<
f.iv.length)&&q(new sjcl.exception.invalid("json encrypt: invalid parameters"));"string"===typeof a?(g=sjcl.misc.cachedPbkdf2(a,f),a=g.key.slice(0,f.ks/32),f.salt=g.salt):sjcl.ecc&&a instanceof sjcl.ecc.elGamal.publicKey&&(g=a.kem(),f.kemtag=g.tag,a=g.key.slice(0,f.ks/32));"string"===typeof b&&(b=sjcl.codec.utf8String.toBits(b));"string"===typeof c&&(c=sjcl.codec.utf8String.toBits(c));g=new sjcl.cipher[f.cipher](a);e.e(d,f);d.key=a;f.ct=sjcl.mode[f.mode].encrypt(g,b,f.iv,c,f.ts);return f},encrypt:function(a,
b,c,d){var e=sjcl.json,f=e.Y.apply(e,arguments);return e.encode(f)},X:function(a,b,c,d){c=c||{};d=d||{};var e=sjcl.json;b=e.e(e.e(e.e({},e.defaults),b),c,!0);var f;c=b.adata;"string"===typeof b.salt&&(b.salt=sjcl.codec.base64.toBits(b.salt));"string"===typeof b.iv&&(b.iv=sjcl.codec.base64.toBits(b.iv));(!sjcl.mode[b.mode]||!sjcl.cipher[b.cipher]||"string"===typeof a&&100>=b.iter||64!==b.ts&&96!==b.ts&&128!==b.ts||128!==b.ks&&192!==b.ks&&0x100!==b.ks||!b.iv||2>b.iv.length||4<b.iv.length)&&q(new sjcl.exception.invalid("json decrypt: invalid parameters"));
"string"===typeof a?(f=sjcl.misc.cachedPbkdf2(a,b),a=f.key.slice(0,b.ks/32),b.salt=f.salt):sjcl.ecc&&a instanceof sjcl.ecc.elGamal.secretKey&&(a=a.unkem(sjcl.codec.base64.toBits(b.kemtag)).slice(0,b.ks/32));"string"===typeof c&&(c=sjcl.codec.utf8String.toBits(c));f=new sjcl.cipher[b.cipher](a);c=sjcl.mode[b.mode].decrypt(f,b.ct,b.iv,c,b.ts);e.e(d,b);d.key=a;return sjcl.codec.utf8String.fromBits(c)},decrypt:function(a,b,c,d){var e=sjcl.json;return e.X(a,e.decode(b),c,d)},encode:function(a){var b,c=
"{",d="";for(b in a)if(a.hasOwnProperty(b))switch(b.match(/^[a-z0-9]+$/i)||q(new sjcl.exception.invalid("json encode: invalid property name")),c+=d+'"'+b+'":',d=",",typeof a[b]){case "number":case "boolean":c+=a[b];break;case "string":c+='"'+escape(a[b])+'"';break;case "object":c+='"'+sjcl.codec.base64.fromBits(a[b],0)+'"';break;default:q(new sjcl.exception.bug("json encode: unsupported type"))}return c+"}"},decode:function(a){a=a.replace(/\s/g,"");a.match(/^\{.*\}$/)||q(new sjcl.exception.invalid("json decode: this isn't json!"));
a=a.replace(/^\{|\}$/g,"").split(/,/);var b={},c,d;for(c=0;c<a.length;c++)(d=a[c].match(/^(?:(["']?)([a-z][a-z0-9]*)\1):(?:(\d+)|"([a-z0-9+\/%*_.@=\-]*)")$/i))||q(new sjcl.exception.invalid("json decode: this isn't json!")),b[d[2]]=d[3]?parseInt(d[3],10):d[2].match(/^(ct|salt|iv)$/)?sjcl.codec.base64.toBits(d[4]):unescape(d[4]);return b},e:function(a,b,c){a===t&&(a={});if(b===t)return a;for(var d in b)b.hasOwnProperty(d)&&(c&&(a[d]!==t&&a[d]!==b[d])&&q(new sjcl.exception.invalid("required parameter overridden")),
a[d]=b[d]);return a},ea:function(a,b){var c={},d;for(d in a)a.hasOwnProperty(d)&&a[d]!==b[d]&&(c[d]=a[d]);return c},da:function(a,b){var c={},d;for(d=0;d<b.length;d++)a[b[d]]!==t&&(c[b[d]]=a[b[d]]);return c}};sjcl.encrypt=sjcl.json.encrypt;sjcl.decrypt=sjcl.json.decrypt;sjcl.misc.ca={};
sjcl.misc.cachedPbkdf2=function(a,b){var c=sjcl.misc.ca,d;b=b||{};d=b.iter||1E3;c=c[a]=c[a]||{};d=c[d]=c[d]||{firstSalt:b.salt&&b.salt.length?b.salt.slice(0):sjcl.random.randomWords(2,0)};c=b.salt===t?d.firstSalt:b.salt;d[c]=d[c]||sjcl.misc.pbkdf2(a,c,b.iter);return{key:d[c].slice(0),salt:c.slice(0)}};
</script>
<!-- ===================================== end content of sjcl.js ============================================= -->

<script language="JavaScript" type="text/javascript">

//====================================================================================================================================
//====================================================================================================================================
var MAX_RANDOM_BYTES = 32;

// 0 network name
//   For example: BITCOIN, LITECOIN etc
// 1 PublicAddressCompressedOrUncompressedLeadCharacter = first character in Public address (compressed or uncompressed)
//   The same character is used in: PublicKeyUncompressed and PublicKeyCompressed
//   Bitcoin example, PublicKeyCompressed = 1JQrk6A5mwaksTKxt53zYg1pyvvHqLnrJt (1 is the lead character)
// 2 PublicHex = This hexadecimal value has two purposes:
//   Purpose 1:
//   This hex value is used to determine the version which will prepended to the PrivateKey and PrivateKeyVersionComp:
//   and the version is calculated as follow: version = (PublicHex + 128) & 255
//   The same value is used to create: PrivateKeyVersion and PrivateKeyVersionComp
//   Bitcoin example:
//   version = (0x00 + 128) & 255 = 0x80
//   PrivateKeyVersion = 80370705F4CD78884F48DC6C787467899E4CF059D662D53B9C2ADA40CE022CFBDE
//   Purpose 2:
//   This hex value is prepended to HashC2 and HashD2:
//   The same value is used to create: PublicKeyVersionHashC and PublicKeyVersionHashD
//   Bitcoin example:
//   PublicKeyVersionHashC= 00BF830BC5CBA4E742C7C584FFCD095656E797DB4D
// 3 PrivateAddressUncompressedLeadCharacter  = first character in Private address uncompressed (Wallet Import Format)
//   Bitcoin example, PrivateKeyWIFUncompressed = 5JEXBbTKSR9kE83kzzmMmm9KcPq61iw87hzeE7q2xddWh8KBqfv (5 is the lead character)
// 4 PrivateAddressCompressedLeadCharacter  = first character in Private address compressed (Wallet Import Format)
//   Bitcoin example, PrivateKeyWIFCompressed = Ky4gDm5APBbbnv7BCyxngZqj9DmF8C5tQbwRJu91eYgA3m8C8ror (K is the lead character)
// 5 Port number

var coinaddress_arr = [];
coinaddress_arr[0]    = ["BITCOIN",  			   "1",  	"0x00", 5,"K,L",    8333,"http://blockchain.info"];
coinaddress_arr[1]		= ["BBQCOIN", 			   "3",  	"0x05", 8, 	"K",       	,""];
coinaddress_arr[2]		= ["BITBAR", 			     "B",  	"0x19", 6, 	"K",       	,""];
coinaddress_arr[3]		= ["BYTECOIN", 			   "8",  	"0x12", 5, 	"K",       	,""];
coinaddress_arr[4]		= ["DEVCOIN",  			   "1",  	"0x00", 5,"K,L",     	  ,""];
coinaddress_arr[5]		= ["DEVCOIN", 			   "6",  	"0x0E", 5, 	"K",       	,""];
coinaddress_arr[6]		= ["FEATHERCOIN",  		 "1",  	"0x0E", 5,"K,L",     	  ,"http://ftc.cryptocoinexplorer.com"];
coinaddress_arr[7]    = ["JUNKCOIN", 			   "7",  	"0x10", 5, 	"K",       	,""];
coinaddress_arr[8]		= ["LITECOIN", 			   "L",  	"0x30", 6, 	"K",       	,"http://explorer.litecoin.net"];
coinaddress_arr[9]		= ["MINCOIN", 			   "M",  	"0x32", 6, 	"K",       	,""];
coinaddress_arr[10]		= ["MINCOIN", 			 "M,N",	  "0x34", 7, 	"K",       	,""];
coinaddress_arr[11]		= ["NOVACOIN",  		   "4",  	"0x08", 5, 	"K",       	,"http://nvc.cryptocoinexplorer.com"];
coinaddress_arr[12]		= ["ONECOIN",			     "o",  	"0x73", 9, 	"K",       	,""];
coinaddress_arr[13]		= ["PPCOIN", 			     "P",  	"0x37", 7, 	"K",       	,""];
coinaddress_arr[14]		= ["SMALLCHANGE", 		 "S",  	"0x3E", 7, 	"K",       	,""];
coinaddress_arr[15]		= ["TERRACOIN",  		   "1",  	"0x00", 5,"K,L",     	  ,"http://trc.cryptocoinexplorer.com"];
coinaddress_arr[16]   = ["YACOIN", 			     "Y",  	"0x4D", 7, 	"K",       	,""];
coinaddress_arr[17] 	= ["BITCOIN-TESTNET","m,n",	  "0x6F", 9, 	 "",	 18333,"http://blockexplorer.com/testnet"];
coinaddress_arr[18] 	= ["BBQCOIN-TESTNET",   "",		"0x19",  ,	 "",        ,""];
coinaddress_arr[19]  	= ["BITBAR-TESTNET",    "",		"0x73",  ,,           	,""];

/*
coinaddress_arr[]		= ["Cryptogenic", 		"?",  	"0x0B", ?, 	"?",       	,"http://explorer.cryptogenicbullion.org:2750"];
coinaddress_arr[]		= ["Datacoin", 			"?",  	"0x1E", ?, 	"?",       	,"http://www.chainbrowser.com/datacoin"];
coinaddress_arr[]		= ["Digitalcoin", 		"?",  	"0x1E", ?, 	"?",       	,"http://dgc.cryptocoinexplorer.com"];
coinaddress_arr[]		= ["Dogecoin", 			"D",  	"0x1E", ?, 	"?",       	,"http://dogechain.info"];
coinaddress_arr[]		= ["Infinitecoin", 		"?",  	"0x66", ?, 	"?",       	,"http://exploretheblocks.com:2750"];
coinaddress_arr[]		= ["Ixcoin", 			"?",  	"0x8A", ?, 	"?",       	,"http://d.evco.in/abe"];
coinaddress_arr[]		= ["Memorycoin", 		"?",  	"0x32", ?, 	"?",       	,"http://www.chainbrowser.com/memorycoin"];
coinaddress_arr[]		= ["Namecoin", 			"?",  	"0x34", ?, 	"?",       	,"http://explorer.dot-bit.org"];
coinaddress_arr[]		= ["Peercoin", 			"P",  	"0x37", ?, 	"?",       	,"http://ppc.cryptocoinexplorer.com"];
coinaddress_arr[]		= ["Primecoin", 		"A",  	"0x17", ?, 	"?",       	,"http://primecoin.org"];
coinaddress_arr[]		= ["Protoshares", 		"P",  	"0x38", ?, 	"?",       	,"http://btsblock.com"];
coinaddress_arr[]		= ["Quarkcoin", 		"?",  	"0x3A", ?, 	"?",       	,"http://quarkexplorer.com"];
coinaddress_arr[]		= ["Vertcoin", 			"?",  	"0x47", ?, 	"?",       	,"http://explorer.vertcoin.org"];
coinaddress_arr[]		= ["Worldcoin", 		"?",  	"0x49", ?, 	"?",       	,"http://wdc.cryptocoinexplorer.com"];
coinaddress_arr[]		= ["Zetacoin", 			"?",  	"0x50", ?, 	"?",       	,"http://bit.usr.sh:2750"];
coinaddress_arr[]		= ["freicoin", 			"1",  	"0x00", ?, 	"?",       	,""];
coinaddress_arr[]		= ["MEGACOIN", 			"M",  	"0x32", ?, 	"?",      	,""];
coinaddress_arr[]		= ["AURORACOIN", 		"A",  	"0x17", ?, 	"?",       	,""];

coinaddress_arr[] 		= ["LITECOIN-TEST",		"m,n",  "0x6F", ?, 	"?",		,""];
coinaddress_arr[] 		= ["PEERCOIN-TEST",		"m,n",  "0x6F", ?, 	"?",		,""];
coinaddress_arr[] 		= ["DOGECOIN-TEST",		"n",    "0x71", ?, 	"?",		,""];
coinaddress_arr[]		= ["freicoin-TEST", 	"m,n",  "0x6F", ?, 	"?",     	,""];
coinaddress_arr[]		= ["PHOTOSHARES-TEST", 	"m,n",  "0x6F", ?, 	"?",     	,""];
coinaddress_arr[]		= ["MEGACOIN-TEST", 	"m,n",  "0x6F", ?, 	"?",       	,""];
coinaddress_arr[]		= ["PRIMECOIN-TEST", 	"m,n",  "0x6F", ?, 	"?",       	,""];
coinaddress_arr[]		= ["AURORACOIN-TEST", 	"m,n",  "0x6F", ?, 	"?",       	,""];
*/

//====================================================================================================================================

// Variables used for generating vanity addresses
var jsxTimeout;
var jsxTimer_is_on = 0;
var jsxVanityLetters = "";
var jsxVanityConversion = "";
var jsxSelectedVersion = "";
var jsxVanityCounter = 0;
var jsxVanityCaseSensitive = false;
var jsxVanityLocation = "left";

function jsxConfirmAlert(url) {
    return confirm("You will leave this page and redirected to:\n\n"+url+"\n\nPlease click on OK to continue.");
}

function jsxToBin(bytes){
	var arr = [];
	for (var i=0; i<bytes.length;i++){
		var s = (bytes[i]).toString(2);
		arr.push(('0000000' + s).slice(-8));
	}
	return arr.join(' ');
}

function jsxIsHex(str) {
	return !/[^0123456789abcdef]+/i.test(str);
}

// Check if value is in range 0-9 or a-f
function jsxIsDiceHex(str) {
	var re = /^([0-9]|[a-f])$/i;
	return re.test(str);
}

// Check if value is in range 1-15
function jsxIsDiceDec(str) {
	var re = /^([1-9]|1[0-6])$/;
	return re.test(str);
}

function jsxIsBase58(str) {
	return !/[^123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]+/.test(str);
}

function jsxIsBase64(str) {
	return !/[^ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=]+/.test(str) && (str.length % 4) == 0;
}

function jsxLoaded(){
	sjcl.random.startCollectors();
}


function jsxGetRandomBytes() {
    var randomWords;

    // First we're going to try to use a built-in CSPRNG
    if (window.crypto && window.crypto.getRandomValues) {
        randomWords = new Uint8Array(MAX_RANDOM_BYTES); //create a typed array of 32 bytes (256 bits)
        window.crypto.getRandomValues(randomWords); //populate array with cryptographically secure random numbers
    }
    // Because of course IE calls it msCrypto instead of being standard
	// window.msCrypto should be available in: IE11
    else if (window.msCrypto && window.msCrypto.getRandomValues) {
        randomWords = new Uint8Array(MAX_RANDOM_BYTES);
        window.msCrypto.getRandomValues(randomWords);
    }
    // So, no built-in functionality - bummer. If the user has wiggled the mouse enough,
    // sjcl might help us out here
    else if (sjcl.random.isReady()) {
		// sjcl.random.randomWords generate several random words, and return them in an array
		// A word consists of 32 bits (4 bytes)
		// See: http://bitwiseshiftleft.github.io/sjcl/doc/index.html
		var nwords = MAX_RANDOM_BYTES/4; // The number of words to generate.
		var randomArrOfWords = sjcl.random.randomWords(nwords,0);
		var randomHex = sjcl.codec.hex.fromBits(randomArrOfWords);
		randomWords = Crypto.util.hexToBytes(randomHex); // Convert to array of bytes
    } else {
        alert("Please install the latest Firefox or Chrome browser.");
    }

    return randomWords;
}

function jsxGenerateQRCode(value, element){
	var QRcodeCellSize = 4;
	var qrCode = qrcode(4, 'M'); // Use version 4. Will hold max 61 bytes. See: http://www.qrcode.com/en/about/version.html
	var qrText = value;
	qrText = qrText.replace(/^[\s\u3000]+|[\s\u3000]+$/g, '');
	qrCode.addData(qrText);
	qrCode.make();
	document.getElementById(element).innerHTML = qrCode.createImgTag(QRcodeCellSize);
}

function jsxSetQRCodeTitle(){
	var network = document.getElementById('cssxNetwork').value;
	document.getElementById('cssxAddressNetworkQRCode1').innerHTML = network;
	document.getElementById('cssxAddressNetworkQRCode2').innerHTML = network;
	document.getElementById('cssxAddressNetworkQRCode3').innerHTML = network;
	document.getElementById('cssxAddressNetworkQRCode4').innerHTML = network;
}

function jsxChangeNetwork(){
	var network = document.getElementById('cssxNetwork').value;
	document.getElementById('cssxPrivateKeyPrefix').innerHTML = jsxGetPrivateKeyPrefix();
	document.getElementById('cssxPrivateKeyPrefixComp').innerHTML = jsxGetPrivateKeyPrefix();
	document.getElementById('cssxPublicKeyPrefix').innerHTML = jsxGetPublicKeyPrefix().substring(2);
	document.getElementById('cssxPublicKeyCompPrefix').innerHTML = jsxGetPublicKeyPrefix().substring(2);
	document.getElementById('cssxAddressPrefix').innerHTML = jsxGetAddressLeadPrefix();

	for (var i=1; i <=9; i++){
		document.getElementById('cssxAddressNetwork'+i).innerHTML = network;
	}

	jsxSetQRCodeTitle();
}


function jsxClearDiceRandomNumbers(){
	for (var i = 0; i < MAX_RANDOM_BYTES*2; i++){
		document.getElementById('cssxDice'+i).value = "";
	}
}

function jsxClearSystemRandomNumbers(){
	for (var i = 0; i < MAX_RANDOM_BYTES; i++){
		document.getElementById('cssxRandomNumber'+i).value = "";
	}
}

function jsxValidateEnteredDiceNumbers(inputMethod){
	jsxChangeNetwork();
	jsxClearSystemRandomNumbers();

	var privateKeyBytes = [];
	var errMessage = "";
	var selectedDiceRandomNumbers = document.getElementById('cssxDiceRandomNumbers').value;

	document.getElementById('cssxPassword').value = "";

	// If the page is refreshed, all fields are cleared. Do not display alert.
	var emptyFieldCounter =0;
	for (var i = 0; i < MAX_RANDOM_BYTES*2; i++){
		var diceValue = document.getElementById('cssxDice'+i).value.trim();
		if(diceValue == ""){
			emptyFieldCounter++;
		}
	}

	// All fields must not be empty "", otherwise show alert message
	if(emptyFieldCounter != MAX_RANDOM_BYTES*2) {

		// Reset emptyFieldCounter
		emptyFieldCounter = MAX_RANDOM_BYTES*2;

		var diceCombinedArr = new Array();  // Two dice values are combined and stored as dec value in array
											// Example dice (1-16) throws: 4, 16, 12, 3
											// Subtract 1 to get hex value: 3, 15, 11, 2
											// Convert to actual hex val: 3, e, b, 2
											// Combine 2 throws: 3e, b2
											// Convert hex to dec: 3e -> 62, b2 -> 178

		var storeHexVal = "";
		var diceArrCounter = 0;

		for (var i = 0; i < MAX_RANDOM_BYTES*2; i++){
			var diceValue = document.getElementById('cssxDice'+i).value.trim(); //may contain dice hex or dec value
			var checkValue = "";

			if(diceValue != "") {
				emptyFieldCounter--;

				if(selectedDiceRandomNumbers == "hex"){
					if(jsxIsDiceHex(diceValue)){
						checkValue = diceValue.toLowerCase();
					} else {
						errMessage += "Field "+(i+1)+": Invalid "+selectedDiceRandomNumbers+" value: "+ diceValue+"\n";
					}
				} else {
					if(jsxIsDiceDec(diceValue)){
						checkValue = parseInt(diceValue) - 1;  // Dice value (1 - 16). Convert to 0 - 15
						checkValue = ""+checkValue.toString(16); // convert to hex value (default lower case) and convert to string
					} else {
						errMessage += "Field "+(i+1)+": Invalid "+selectedDiceRandomNumbers+" value: "+ diceValue+"\n";
					}
				}

				if(storeHexVal.length < 2){
					storeHexVal += checkValue;
				}

				if(storeHexVal.length == 2){
					diceCombinedArr[diceArrCounter] = parseInt(storeHexVal, 16); // Convert hex string eg: "a8" to dec value 168
					storeHexVal = "";
					diceArrCounter++;
				}
			} // if(diceValue != "")
		} // for (var i = 0; i < MAX_RANDOM_BYTES*2; i++)


		for (var i = 0; i < diceCombinedArr.length; i++){
			checkValue = diceCombinedArr[i];
			// Value is an integer and must be 0 - 255
			if((checkValue >=0) && checkValue <= 255){
				privateKeyBytes[i] = checkValue;
			} else {
				errMessage += "Combined Field "+(i+1)+": Invalid "+selectedDiceRandomNumbers+" value: "+ enteredValue +". Allowed values: 0 (0x00) - 255 (0xFF)\n";
			}
		} // for (var i = 0; i < diceCombinedArr.length; i++)


		if(errMessage =="" && emptyFieldCounter == 0){
			if(jsxIsPrivateKeyInRange(privateKeyBytes)){
				jsxDisplayPrivateKeys(privateKeyBytes);
				jsxDisplayPublicKeys(privateKeyBytes);
			} else {
				jsxClearFields();
			}

		} else {
			jsxClearFields();
			if(emptyFieldCounter == 0 && errMessage != ""){
				alert(errMessage);
			}
		}
	} else {
		if(inputMethod == "button"){
			alert("Please enter "+MAX_RANDOM_BYTES*2+" random numbers.");
		}
		return;
	} // if(emptyFieldCounter != MAX_RANDOM_BYTES*2)
}

function jsxClearPassword(){
	document.getElementById('cssxPassword').value ="";
}

function jsxChangeDiceRandomNumbers(){
	jsxClearSystemRandomNumbers();

	var selectedDiceRandomNumbers = document.getElementById('cssxDiceRandomNumbers').value;

	var fieldMaxLength = "2";
	if(selectedDiceRandomNumbers == "hex"){
		fieldMaxLength = "1";
	}

	for (var i = 0; i < MAX_RANDOM_BYTES*2; i++){
		document.getElementById('cssxDice'+i).maxLength = fieldMaxLength;
	}

	var convertedArr = new Array();

	// Convert the value and store it into an array
	for (var i = 0; i < MAX_RANDOM_BYTES*2; i++){
		var checkValue = document.getElementById('cssxDice'+i).value.trim();

		if(checkValue == ""){
			convertedArr[i] = "";
		} else {
			if(selectedDiceRandomNumbers == "hex"){
				// Convert dice dec (1-16) -> hex
				//convertedArr[i] = ""+(+checkValue).toString(16);
				var diceVal = parseInt(checkValue)-1; //  Convert dice dec (1-16) to dec value 0-15
				convertedArr[i] = ""+diceVal.toString(16);  // Convert dec 0-15 to hex
			} else {
				// Convert dice hex (0-f) -> dec
				//convertedArr[i] = ""+parseInt(checkValue, 16);
				var diceVal = parseInt(checkValue, 16)+1; // Convert dice hex (0-f) to dec value 1-16
				convertedArr[i] = ""+diceVal;  // Convert dec 0-15 to hex
			}
		}
	}

	// Display the values
	for (var i = 0; i < MAX_RANDOM_BYTES*2; i++){
		document.getElementById('cssxDice'+i).value = convertedArr[i].toLowerCase();
	}
}


function jsxChangeSystemRandomNumbers(){
	jsxClearDiceRandomNumbers();
	var selectedSystemRandomNumbers = document.getElementById('cssxSystemRandomNumbers').value;
	var convertedArr = [];

	// Convert the value and store it into an array
	for (var i = 0; i < MAX_RANDOM_BYTES; i++){
		var checkValue = document.getElementById('cssxRandomNumber'+i).value.trim();

		if(selectedSystemRandomNumbers == "hex"){
			// dec -> hex
			convertedArr[i] = ""+(+checkValue).toString(16);
		} else {
			// hex - > dec
			convertedArr[i] = ""+parseInt(checkValue, 16);
		}
	}

	// Display the values
	for (var i = 0; i < MAX_RANDOM_BYTES; i++){
		document.getElementById('cssxRandomNumber'+i).value = convertedArr[i].toUpperCase();
	}
}


function jsxGenerateRandomNumbers(withRandomValues, randomBytes){
	jsxClearDiceRandomNumbers();

	var privateKeyBytes = [];
	var selectedSystemRandomNumbers = document.getElementById('cssxSystemRandomNumbers').value;

	// Create RANDOM private key
	var randArr;

	if(withRandomValues){
		randArr = jsxGetRandomBytes();
	}

	if(randomBytes != null){
		randArr = randomBytes;
	}

	if(randArr != null)	 {
		var displayKeyValue = "";
		for (var i = 0; i < MAX_RANDOM_BYTES; ++i){
			//some Bitcoin and Crypto methods don't like Uint8Array for input. They expect regular JS arrays.
			privateKeyBytes[i] = randArr[i]; // array contains 32 randomly choosen integer numbers from: 0-255

			if(selectedSystemRandomNumbers == "hex"){
				displayKeyValue = randArr[i].toString(16).toUpperCase();

				if(displayKeyValue.length == 1){
					displayKeyValue = "0"+displayKeyValue;
				}
			} else {
				displayKeyValue = randArr[i];
			}
			document.getElementById('cssxRandomNumber'+i).value = displayKeyValue;
		}
	}


	if(randArr != null  && jsxIsPrivateKeyInRange(privateKeyBytes)){
		jsxDisplayPrivateKeys(privateKeyBytes);
		jsxDisplayPublicKeys(privateKeyBytes);
	} else {
		jsxClearRandomBytes();
		jsxClearFields();
	}
}

function jsxGetArrayValue(network, index){
	var foundValue = "";
	for(var i=0; i<coinaddress_arr.length; i++) {
		if(coinaddress_arr[i][0] == network){
			foundValue = coinaddress_arr[i][index];
			break;
		}
	}

	return foundValue;
}

function jsxGetPrivateKeyPrefix(){
	var publicKeyPrefixDec = parseInt(jsxGetPublicKeyPrefix()); // Convert "0x80" to 128 (Dec) value
	var privateKeyPrefixDec = (publicKeyPrefixDec+128)&255;
	var privateKeyPrefix = privateKeyPrefixDec.toString(16).toUpperCase();
	if(privateKeyPrefix.length == 1) {
		privateKeyPrefix = "0"+privateKeyPrefix;
	}
	return privateKeyPrefix; // return hex value, for example: 0A without "0x"
}

function jsxGetPublicKeyPrefix(){
	var selectedNetwork = document.getElementById('cssxNetwork').value;
	var publicKeyPrefix = jsxGetArrayValue(selectedNetwork,2);
	return publicKeyPrefix; // return hex value, for example: "0x0A" with "0x"
}

function jsxGetAddressLeadPrefix(){
	var selectedNetwork = document.getElementById('cssxNetwork').value;
	var leadPrefix = jsxGetArrayValue(selectedNetwork,1);
	return leadPrefix.replace(",", " or ");
}

function jsxDisplayValuelength(element, value){
	document.getElementById(element).value = value.length;
}

function jsxIsPrivateKeyInRange(privateKeyBytes){
	//===================================================================
	// Check if the PrivateKey is in range [1, n-1]
	// n = FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141
	// See: Elliptic curve domain parameters over Fp associated with a Koblitz curve secp256k1
	// See: https://en.bitcoin.it/wiki/Private_key#Range_of_valid_private_keys
	//===================================================================
	var isInRange = true;

	// Convert max PrivateKey to bytes
	var privateKeyN   = "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141";
	var privateKeyBytesMax = Crypto.util.hexToBytes(privateKeyN);

	// Convert to BigInteger
	var privateKeyBigIntMax = BigInteger.fromByteArrayUnsigned(privateKeyBytesMax);
	var privateKeyBigInt = BigInteger.fromByteArrayUnsigned(privateKeyBytes);

	// Check which of the two values are the maxValue
	var maxValue = privateKeyBigIntMax.max(privateKeyBigInt);

	if(maxValue.equals(privateKeyBigInt)){
		alert("The PrivateKeyHex / random number should be smaller than\n"+privateKeyN);
		isInRange = false;
	}

	if(privateKeyBigInt.equals(BigInteger.ZERO)){
		alert("The PrivateKeyHex / random number should be greater than 0.\n");
		isInRange = false;
	}

	return isInRange;
}

function jsxDisplayPrivateKeys(privateKeyBytes){
	//===================================================================
	// PrivateKey in different formats
	//===================================================================
	// Display generated random value (privateKeyBytes) as a hex string
	var privateKeyHex = Crypto.util.bytesToHex(privateKeyBytes).toUpperCase();
	document.getElementById('cssxPrivateKeyHex').value = privateKeyHex;
	jsxDisplayValuelength('cssxPrivateKeyHexLength', privateKeyHex);

	// Display generated random value (privateKeyBytes) as a decimal string
	document.getElementById('cssxPrivateKeyDec').value = privateKeyBytes.toString();

	// Display generated random value (privateKeyBytes) as a base58 string
	var privateKeyBase58 = Bitcoin.Base58.encode(privateKeyBytes);
	document.getElementById('cssxPrivateKeyBase58').value = privateKeyBase58;
	jsxDisplayValuelength('cssxPrivateKeyBase58Length', privateKeyBase58);

	// Display generated random value (privateKeyBytes) as a base64 string
	var privateKeyBase64 = Crypto.util.bytesToBase64(privateKeyBytes);
	document.getElementById('cssxPrivateKeyBase64').value = privateKeyBase64;
	jsxDisplayValuelength('cssxPrivateKeyBase64Length', privateKeyBase64);

	// Display generated random value (privateKeyBytes) as a binary string
	var privateKeyBin = jsxToBin(privateKeyBytes);
	document.getElementById('cssxPrivateKeyBin').value = privateKeyBin;
	jsxDisplayValuelength('cssxPrivateKeyBinLength', privateKeyBin.replace(/\s/g,''));

	//===================================================================
	// Calculate PrivateKey Wallet Import Format (WIF) Uncompressed
	//===================================================================
	// Prepend version to privateKeyHex
	var privateKeyVersion = jsxGetPrivateKeyPrefix()+privateKeyHex;
	document.getElementById('cssxPrivateKeyVersion').value = privateKeyVersion.toUpperCase();
	jsxDisplayValuelength('cssxPrivateKeyVersionLength', privateKeyVersion);

	// hashA1 = SHA256(privateKeyVersion)
	var hashA1 = Crypto.SHA256(Crypto.util.hexToBytes(privateKeyVersion));
	document.getElementById('cssxHashA1').value = hashA1.toUpperCase();
	jsxDisplayValuelength('cssxHashA1Length', hashA1);

	// hashA2 = SHA256(hashA1)
	var hashA2  = Crypto.SHA256(Crypto.util.hexToBytes(hashA1));
	document.getElementById('cssxHashA2').value = hashA2.toUpperCase();
	jsxDisplayValuelength('cssxHashA2Length', hashA2);

	// checksumA = first 4 bytes of hashA2
	var checksumA = hashA2.substr(0, 8);
	document.getElementById('cssxChecksumA').value = checksumA.toUpperCase();
	jsxDisplayValuelength('cssxChecksumALength', checksumA);

	// Append checksumA to privateKeyVersion
	var privateKeyChecksum = privateKeyVersion + checksumA;
	document.getElementById('cssxPrivateKeyChecksum').value = privateKeyChecksum.toUpperCase();
	jsxDisplayValuelength('cssxPrivateKeyChecksumLength', privateKeyChecksum);

	// privateKeyWIFUncompressed
	var privateKeyWIFUncompressed = Bitcoin.Base58.encode(Crypto.util.hexToBytes(privateKeyChecksum));
	document.getElementById('cssxPrivateKeyWIFUncompressed').value = privateKeyWIFUncompressed;  // Do not use uppercase!
	jsxDisplayValuelength('cssxPrivateKeyWIFUncompressedLength', privateKeyWIFUncompressed);

	//===================================================================
	// Setup QR Code
	//===================================================================
	jsxGenerateQRCode(privateKeyWIFUncompressed, "cssxQRCodePrivateKeyWIFUncompressed");
	document.getElementById('cssxQRCodePrivateKeyWIFUncompressedValue').innerHTML = privateKeyWIFUncompressed;

	//===================================================================
	// Calculate PrivateKey Wallet Import Format (WIF) Compressed
	//===================================================================
	// Prepend version to privateKeyHex	and append "01"
	var privateKeyVersionComp = jsxGetPrivateKeyPrefix() + privateKeyHex + "01";
	document.getElementById('cssxPrivateKeyVersionComp').value = privateKeyVersionComp.toUpperCase();
	jsxDisplayValuelength('cssxPrivateKeyVersionCompLength', privateKeyVersionComp);

	// hashB1 = SHA256(privateKeyVersionComp)
	var hashB1 = Crypto.SHA256(Crypto.util.hexToBytes(privateKeyVersionComp));
	document.getElementById('cssxHashB1').value = hashB1.toUpperCase();
	jsxDisplayValuelength('cssxHashB1Length', hashB1);

	// hashB2 = SHA256(hashB1)
	var hashB2  = Crypto.SHA256(Crypto.util.hexToBytes(hashB1));
	document.getElementById('cssxHashB2').value = hashB2.toUpperCase();
	jsxDisplayValuelength('cssxHashB2Length', hashB2);

	// checksumB = first 4 bytes of hashB2
	var checksumB = hashB2.substr(0, 8);
	document.getElementById('cssxChecksumB').value = checksumB.toUpperCase();
	jsxDisplayValuelength('cssxChecksumBLength', checksumB);

	// Append checksumB to privateKeyVersionComp
	var privateKeyChecksumComp = privateKeyVersionComp + checksumB;
	document.getElementById('cssxPrivateKeyChecksumComp').value = privateKeyChecksumComp.toUpperCase();
	jsxDisplayValuelength('cssxPrivateKeyChecksumCompLength', privateKeyChecksumComp);

	// privateKeyWIFUncompressed
	var privateKeyWIFCompressed = Bitcoin.Base58.encode(Crypto.util.hexToBytes(privateKeyChecksumComp));
	document.getElementById('cssxPrivateKeyWIFCompressed').value = privateKeyWIFCompressed;  // Do not use uppercase!
	jsxDisplayValuelength('cssxPrivateKeyWIFCompressedLength', privateKeyWIFCompressed);

	//===================================================================
	// Setup QR Code
	//===================================================================
	jsxGenerateQRCode(privateKeyWIFCompressed, "cssxQRCodePrivateKeyWIFCompressed");
	document.getElementById('cssxQRCodePrivateKeyWIFCompressedValue').innerHTML = privateKeyWIFCompressed;
}


function jsxDisplayPublicKeys(privateKeyBytes){
	//===================================================================
	// Calculate PublicKey
	//===================================================================

	// convert our random array or private key to a Big Integer
	var privateKeyBN = BigInteger.fromByteArrayUnsigned(privateKeyBytes);

	// calculate X and Y
	var curve = getSECCurveByName("secp256k1") //found in bitcoinjs-lib/src/jsbn/sec.js
	var curvePt = curve.getG().multiply(privateKeyBN);
	var x = curvePt.getX().toBigInteger();
	var y = curvePt.getY().toBigInteger();

	// Convert X to bytes
	var publicKeyBytesX = integerToBytes(x,32); //integerToBytes is found in bitcoinjs-lib/src/ecdsa.js // calculate x
	var publicKeyBytesXValue = Crypto.util.bytesToHex(publicKeyBytesX)
	document.getElementById('cssxX').value = publicKeyBytesXValue.toUpperCase();
	jsxDisplayValuelength('cssxXLength', publicKeyBytesXValue);

	// Convert Y to bytes
	var publicKeyBytesY = integerToBytes(y,32); // calculate y
	var publicKeyBytesYValue = Crypto.util.bytesToHex(publicKeyBytesY);
	document.getElementById('cssxY').value = publicKeyBytesYValue.toUpperCase();
	jsxDisplayValuelength('cssxYLength', publicKeyBytesYValue);

	// Calculate publicKeyBytes = X + Y
	var publicKeyBytes = publicKeyBytesX.concat(publicKeyBytesY);
	var publicKeyBytesValue = Crypto.util.bytesToHex(publicKeyBytes)
	document.getElementById('cssxPublicKey').value = publicKeyBytesValue.toUpperCase();
	jsxDisplayValuelength('cssxPublicKeyLength', publicKeyBytesValue);

	//===================================================================
	//  Calculate PublicKey Uncompressed
	//===================================================================
	// Append 04 to publicKeyBytes
	publicKeyBytes.unshift(0x04);
	var publicKeyVersion = Crypto.util.bytesToHex(publicKeyBytes).toUpperCase();
	document.getElementById('cssxPublicKeyVersion').value = publicKeyVersion;
	jsxDisplayValuelength('cssxPublicKeyVersionLength', publicKeyVersion);

	// hashC1 = SHA256(publicKeyBytes)
	var hashC1 = Crypto.SHA256(publicKeyBytes);
	document.getElementById('cssxHashC1').value = hashC1.toUpperCase();
	jsxDisplayValuelength('cssxHashC1Length', hashC1);

	// hashC2 = RIPEMD160(hashC1)
	var hashC2 = Crypto.RIPEMD160(Crypto.util.hexToBytes(hashC1));
	document.getElementById('cssxHashC2').value = hashC2.toUpperCase();
	jsxDisplayValuelength('cssxHashC2Length', hashC2);

	// Get prefix value
	var versionC = jsxGetPublicKeyPrefix();

	// Convert hashC2 to bytes
	var hashC2Bytes = Crypto.util.hexToBytes(hashC2);

	// Append version to hashC2Bytes
	hashC2Bytes.unshift(versionC);
	var publicKeyVersionHashC =  Crypto.util.bytesToHex(hashC2Bytes).toUpperCase();
	document.getElementById('cssxPublicKeyVersionHashC').value = publicKeyVersionHashC;
	jsxDisplayValuelength('cssxPublicKeyVersionHashCLength', publicKeyVersionHashC);

	// hashC3 = SHA256(hashC2Bytes)
	var hashC3 = Crypto.SHA256(hashC2Bytes);
	document.getElementById('cssxHashC3').value = hashC3.toUpperCase();
	jsxDisplayValuelength('cssxHashC3Length', hashC3);

	// hashC4 = SHA256(hashC2)
	var hashC4 = Crypto.SHA256(Crypto.util.hexToBytes(hashC3));
	document.getElementById('cssxHashC4').value = hashC4.toUpperCase();
	jsxDisplayValuelength('cssxHashC4Length', hashC4);

	// checksumC = first 4 bytes of hashC4
	var checksumC = hashC4.substr(0,8);
	document.getElementById('cssxChecksumC').value = checksumC.toUpperCase();
	jsxDisplayValuelength('cssxChecksumCLength', checksumC);

	// Append checksumC to hashC2Bytes
	var publicKeyChecksumC = Crypto.util.bytesToHex(hashC2Bytes) + checksumC;
	document.getElementById('cssxPublicKeyChecksumC').value = publicKeyChecksumC.toUpperCase();
	jsxDisplayValuelength('cssxPublicKeyChecksumCLength', publicKeyChecksumC);

	// Calculate publicKeyUncompressed
	var publicKeyUncompressed = Bitcoin.Base58.encode(Crypto.util.hexToBytes(publicKeyChecksumC));
	document.getElementById('cssxPublicKeyUncompressed').value = publicKeyUncompressed;
	jsxDisplayValuelength('cssxPublicKeyUncompressedLength', publicKeyUncompressed);

	//===================================================================
	// Setup QR Code
	//===================================================================
	jsxGenerateQRCode(publicKeyUncompressed, "cssxQRCodePublicKeyUncompressed");
	document.getElementById('cssxQRCodePublicKeyUncompressedValue').innerHTML = publicKeyUncompressed;

	//===================================================================
	//  Calculate PublicKey Wallet Import Format (WIF) Compressed
	//===================================================================
	// Convert X to bytes
	var publicKeyBytesCompressed = integerToBytes(x,32);

	// Append 0x02 or 0x03 version (depending on Y) to publicKeyBytesCompressed
	if (y.isEven()){
		publicKeyBytesCompressed.unshift(0x02); // append 0x02
		document.getElementById('cssxYOddOrEven').value = "y is even. Append prefix '02' to value x.";
	} else {
		publicKeyBytesCompressed.unshift(0x03); // append 0x03
		document.getElementById('cssxYOddOrEven').value = "y is odd. Append prefix '03' to value x.";
	}

	var publicKeyBytesCompressedValue = Crypto.util.bytesToHex(publicKeyBytesCompressed);
	document.getElementById('cssxPublicKeyVersionComp').value = publicKeyBytesCompressedValue.toUpperCase();
	jsxDisplayValuelength('cssxPublicKeyVersionCompLength', publicKeyBytesCompressedValue);

	// hashD1 = SHA256(publicKeyBytesCompressed)
	var hashD1 = Crypto.SHA256(publicKeyBytesCompressed);
	document.getElementById('cssxHashD1').value = hashD1.toUpperCase();
	jsxDisplayValuelength('cssxHashD1Length', hashD1);


	// hashD2 = RIPEMD160(hashD1)
	var hashD2 = Crypto.RIPEMD160(Crypto.util.hexToBytes(hashD1));
	document.getElementById('cssxHashD2').value = hashD2.toUpperCase();
	jsxDisplayValuelength('cssxHashD2Length', hashD2);

	// Get prefix value
	var versionD = jsxGetPublicKeyPrefix();

	// Convert hashD2 to bytes
	var hashD2Bytes = Crypto.util.hexToBytes(hashD2);

	// Append version to hashD2Bytes
	hashD2Bytes.unshift(versionD);
	var hashD2BytesValue = Crypto.util.bytesToHex(hashD2Bytes);
	document.getElementById('cssxPublicKeyVersionHashD').value = hashD2BytesValue.toUpperCase();
	jsxDisplayValuelength('cssxPublicKeyVersionHashDLength', hashD2BytesValue);

	// hashD3 = SHA256(hashD2Bytes)
	var hashD3 = Crypto.SHA256(hashD2Bytes);
	document.getElementById('cssxHashD3').value = hashD3.toUpperCase();
	jsxDisplayValuelength('cssxHashD3Length', hashD3);

	// hashD4 = SHA256(hashD3)
	var hashD4 = Crypto.SHA256(Crypto.util.hexToBytes(hashD3));
	document.getElementById('cssxHashD4').value = hashD4.toUpperCase();
	jsxDisplayValuelength('cssxHashD4Length', hashD4);

	// checksumD = first 4 bytes of hashD4
	var checksumD = hashD4.substr(0,8);
	document.getElementById('cssxChecksumD').value = checksumD.toUpperCase();
	jsxDisplayValuelength('cssxChecksumDLength', checksumD);

	// Append checksumD to hashD2Bytes
	var publicKeyChecksumD = Crypto.util.bytesToHex(hashD2Bytes) + checksumD;
	document.getElementById('cssxPublicKeyChecksumD').value = publicKeyChecksumD.toUpperCase();
	jsxDisplayValuelength('cssxPublicKeyChecksumDLength', publicKeyChecksumD);

	// Calculate publicKeyCompressed
	var publicKeyCompressed = Bitcoin.Base58.encode(Crypto.util.hexToBytes(publicKeyChecksumD));
	document.getElementById('cssxPublicKeyCompressed').value = publicKeyCompressed;
	jsxDisplayValuelength('cssxPublicKeyCompressedLength', publicKeyCompressed);

	//===================================================================
	// Set value for QR code
	//===================================================================
	jsxGenerateQRCode(publicKeyCompressed, "cssxQRCodePublicKeyCompressed");
	document.getElementById('cssxQRCodePublicKeyCompressedValue').innerHTML = publicKeyCompressed;

}

function jsxChangePrivateKeyWIFOrWIFCompressed(type, privateKeyWIFOrWIFCompressed) {

	if(privateKeyWIFOrWIFCompressed == ""){
		if(type == "cssxPrivateKeyWIFUncompressed"){
			alert("Please enter a PrivateKeyWIFUncompressed.");
		} else if(type == "cssxPrivateKeyWIFCompressed"){
			alert("Please enter a PrivateKeyWIFCompressed.");
		}
		return;
	}

	if(!jsxIsChecksumValid(privateKeyWIFOrWIFCompressed)){
		alert("Wrong checksum");
		return;
	}

	var bytes = Bitcoin.Base58.decode(privateKeyWIFOrWIFCompressed);
	var end = bytes.length - 4;
    var hash = bytes.slice(0, end);

	if(type == "cssxPrivateKeyWIFCompressed"){
		// The PrivateKeyWIFCompressed has a compression flag. The size is 1 byte containing value 1.
		var compressionFlag = bytes.slice(end-1, end);
		hash = bytes.slice(0, end-1);

		if(compressionFlag != 1) {
			alert("The compression flag should be 01.");
			return;
		}
	}

	var version = hash.shift(); // The first byte of the hash is the version. After the shift, the hash contains the privateKeyBytes without the version.
	var networkFound = false;

	for(var i=0; i<coinaddress_arr.length; i++) {

		var publicKeyPrefixDec = parseInt(coinaddress_arr[i][2]);
		var privateKeyPrefixDec = (publicKeyPrefixDec+128)&255;

		if(privateKeyPrefixDec == version){
			document.getElementById('cssxNetwork').value = coinaddress_arr[i][0];
			jsxChangeNetwork();
			jsxValidateEnteredDiceNumbers();
			networkFound = true;
			break;
		}
	}

	if(networkFound){
		return hash; // privateKeyBytes
	} else {
		if(type == "cssxPrivateKeyWIFUncompressed"){
			alert("Unknown PrivateKeyWIFUncompressed");
		} else if(type == "cssxPrivateKeyWIFCompressed"){
			alert("Unknown PrivateKeyWIFCompressed");
		}
	}
}


function jsxChangePrivateKey(type){
	var privateKeyBytes = "";
	document.getElementById("cssxPassword").value = "";

	if(type=="cssxPrivateKeyHex"){
		var privateKeyHex = document.getElementById(type).value.trim();

		if(privateKeyHex == ""){
			alert("Please enter a PrivateKeyHex.");
			return;
		} else if(!jsxIsHex(privateKeyHex)){
			alert("PrivateKeyHex contains invalid characters.");
			return;
		}
		privateKeyBytes = Crypto.util.hexToBytes(privateKeyHex);

		if(privateKeyBytes.length != MAX_RANDOM_BYTES){
			alert("PrivateKeyHex length="+privateKeyBytes.length+" bytes. Must be "+MAX_RANDOM_BYTES+" bytes.");
			return;
		}

	} else if(type=="cssxPrivateKeyBase58"){
		var privateKeyBase58 = document.getElementById(type).value.trim();

		if(privateKeyBase58 == ""){
			alert("Please enter a PrivateKeyBase58.");
			return;
		} else if(!jsxIsBase58(privateKeyBase58)){
			alert("PrivateKeyBase58 contains invalid characters.");
			return;
		}

		privateKeyBytes = Bitcoin.Base58.decode(privateKeyBase58);

		if(privateKeyBytes.length != MAX_RANDOM_BYTES){
			alert("PrivateKeyBase58 length="+privateKeyBytes.length+" bytes. Must be "+MAX_RANDOM_BYTES+" bytes.");
			return;
		}
	} else if(type=="cssxPrivateKeyBase64"){
		var privateKeyBase64 = document.getElementById(type).value.trim();

		if(privateKeyBase64 == ""){
			alert("Please enter a PrivateKeyBase64.");
			return;
		} else if(!jsxIsBase64(privateKeyBase64)){
			alert("PrivateKeyBase64 is invalid.");
			return;
		}

		privateKeyBytes = Crypto.util.base64ToBytes(privateKeyBase64);

		if(privateKeyBytes.length != MAX_RANDOM_BYTES){
			alert("PrivateKeyBase64 length="+privateKeyBytes.length+" bytes. Must be "+MAX_RANDOM_BYTES+" bytes.");
			return;
		}
	} else if(type=="cssxPrivateKeyWIFUncompressed"){
		var privateKeyWIFUncompressed = document.getElementById(type).value.trim();

		if(privateKeyWIFUncompressed == ""){
			alert("Please enter a PrivateKeyWIFUncompressed.");
			return;
		} else if(!jsxIsBase58(privateKeyWIFUncompressed)){
			alert("PrivateKeyWIFUncompressed contains invalid characters.");
			return;
		}

		privateKeyBytes = jsxChangePrivateKeyWIFOrWIFCompressed(type, privateKeyWIFUncompressed);
	} else if(type=="cssxPrivateKeyWIFCompressed"){
		var privateKeyWIFCompressed = document.getElementById(type).value.trim();

		if(privateKeyWIFCompressed == ""){
			alert("Please enter a PrivateKeyWIFCompressed.");
			return;
		} else if(!jsxIsBase58(privateKeyWIFCompressed)){
			alert("PrivateKeyWIFCompressed contains invalid characters.");
			return;
		}

		privateKeyBytes = jsxChangePrivateKeyWIFOrWIFCompressed(type, privateKeyWIFCompressed);
	}

	if(jsxIsPrivateKeyInRange(privateKeyBytes)){
		jsxDisplayPrivateKeys(privateKeyBytes);
		jsxGenerateRandomNumbers(false, privateKeyBytes);
	} else {
		jsxClearFields();
	}
}


function jsxEnterPassword(){
	var password = document.getElementById('cssxPassword').value.trim();

	if(password == ""){
		alert("Please enter a Password.");
		return;
	}

	//  This tool hashes the password twice: privateKeyHex = SHA256(SHA256(password))
	var privateKeyHex = Crypto.SHA256(Crypto.util.hexToBytes(Crypto.SHA256(password)));

	// brainwallet.org hashes the password only once
	// This solution is implemented in http://brainwallet.org/
	// var privateKeyHex = Crypto.SHA256(password);

	// Convert to bytes
	var privateKeyBytes = Crypto.util.hexToBytes(privateKeyHex);

	if(jsxIsPrivateKeyInRange(privateKeyBytes)){
		jsxDisplayPrivateKeys(privateKeyBytes);
		jsxGenerateRandomNumbers(false, privateKeyBytes);
	} else {
		jsxClearFields();
	}
}

function jsxIsChecksumValid(privateOrPublicKey){
	var bytes = Bitcoin.Base58.decode(privateOrPublicKey);
	var end = bytes.length - 4;
    var hash = bytes.slice(0, end);

    var checksum = Crypto.SHA256(Crypto.SHA256(hash, {asBytes: true}), {asBytes: true});
    if (checksum[0] != bytes[end] || checksum[1] != bytes[end+1] || checksum[2] != bytes[end+2] || checksum[3] != bytes[end+3]){
    	return false;
	}
	return true;
}

function jsxIsPublicKeyCompressedOrUncompressedValid(id, showValidMessage){
	var publicKeyCompressedOrUncompressed = (document.getElementById(id).value).trim();

	var keyText = "";
	if(id == "cssxPublicKeyUncompressed") {
		keyText = "PublicKeyUncompressed";
	} else if(id == "cssxPublicKeyCompressed") {
		keyText = "PublicKeyCompressed";
	}

	if(publicKeyCompressedOrUncompressed == "") {
		alert(keyText+" is empty.");
		return false;
	}

	jsxDisplayValuelength(id+'Length', publicKeyCompressedOrUncompressed);

	if(!jsxIsChecksumValid(publicKeyCompressedOrUncompressed)) {
		alert(keyText+" is not valid. The checksum is wrong.");
		return false;
	} else {
		if(showValidMessage) {
			alert(keyText+" is valid.");
		}
		return true;
	}
}

function jsxStopGenerateVanityAddress(){
	clearTimeout(jsxTimeout);
    jsxTimer_is_on = 0;
	document.getElementById('cssxLoadImage').style.visibility = 'hidden';
}

function jsxStartGenerateVanityAddress(){
	jsxResetForVanity();

	jsxVanityLetters = (document.getElementById('cssxVanityLetters').value).trim();

	var requestedLettersValid = false;

	if(jsxVanityLetters == "") {
		alert("Please enter Vanity characters.");
	} else if(jsxIsBase58(jsxVanityLetters)){
		requestedLettersValid = true;
	} else {
		alert("Allowed Vanity characters are all letters and numbers except: 0 (zero), I (capital i), O (capital o), or l (lowercase L).");
	}

 	if (!jsxTimer_is_on && requestedLettersValid) {
        jsxTimer_is_on = 1;

		jsxVanityCaseSensitive = document.getElementById('cssxVanityCaseSensitive').checked;

		jsxVanityLetters = jsxVanityCaseSensitive ? jsxVanityLetters : jsxVanityLetters.toLowerCase();

		jsxVanityConversion = document.getElementById('cssxVanityConversion').value;
		jsxVanityLocation = document.getElementById('cssxVanityLocation').value;
		jsxSelectedVersion = jsxGetPublicKeyPrefix();
		jsxVanityCounter = 0;

		document.getElementById('cssxLoadImage').style.visibility = 'visible';
        jsxGenerateVanityAddress();
    }
}

function jsxGenerateVanityAddress(){
	var privateKeyBytes;

	jsxVanityCounter++;

	document.getElementById('cssxVanityCombinations').value = jsxVanityCounter;

	// Create RANDOM private key
	/*
	var randArr = new Uint8Array(MAX_RANDOM_BYTES); //create a typed array of 32 bytes (256 bits)
	window.crypto.getRandomValues(randArr); //populate array with cryptographically secure random numbers
	*/
	var randArr = jsxGetRandomBytes();

	privateKeyBytes = [];
	for (var i = 0; i < MAX_RANDOM_BYTES; ++i){
		//some Bitcoin and Crypto methods don't like Uint8Array for input. They expect regular JS arrays.
		privateKeyBytes[i] = randArr[i]; // array contains 32 randomly choosen integer numbers from: 0-255
	}

	var eckey = new Bitcoin.ECKey(privateKeyBytes);
	eckey.compressed = (jsxVanityConversion == "compressed") ? true : false;
	var address = eckey.getBitcoinAddress().toString();
	address.version = jsxSelectedVersion;

	var foundLetters = "";
	if(jsxVanityLocation == "left"){
		foundLetters = address.substring(1, (1+jsxVanityLetters.length));
	} else {
		foundLetters = address.substring((address.length - jsxVanityLetters.length), address.length);
	}

	foundLetters = jsxVanityCaseSensitive ? foundLetters : foundLetters.toLowerCase();

	document.getElementById('cssxVanityPublicKey').value = address;

	if(foundLetters == jsxVanityLetters){
		jsxGenerateRandomNumbers(false, privateKeyBytes);

		jsxStopGenerateVanityAddress();
	} else {
		jsxTimeout = setTimeout(function(){
			jsxGenerateVanityAddress();
		}, 1);
	}
}


function jsxClearRandomBytes(){
/*
	for (var i = 0; i < MAX_RANDOM_BYTES; i++){
		document.getElementById('cssxRandomNumber'+i).value = "";
	}
*/
	jsxClearSystemRandomNumbers();
	jsxClearDiceRandomNumbers();
}

function jsxResetForVanity(){
	jsxClearFields();
	jsxClearRandomBytes();
	jsxSetQRCodeTitle();
}

function jsxReset(){
	document.getElementById('cssxShowMoreDetails').checked = true;
	document.getElementById('cssxNetwork').value = "BITCOIN";
	document.getElementById('cssxSystemRandomNumbers').value = "hex";
	document.getElementById('cssxDiceRandomNumbers').value = "dec";

	// Vanity Address
	document.getElementById('cssxVanityConversion').value = "compressed";
	document.getElementById('cssxVanityLocation').value = "left";
	document.getElementById('cssxVanityCaseSensitive').checked = false;
	document.getElementById('cssxVanityLetters').value = "";


	jsxClearRandomBytes();
	jsxClearFields();
	jsxChangeNetwork();
	jsxSetQRCodeTitle();
	jsxValidateEnteredDiceNumbers();
}

function jsxClearVanityInputFields(){
	document.getElementById('cssxVanityCombinations').value = "";
	document.getElementById('cssxVanityPublicKey').value = "";
}


function jsxClearFields(){
	document.getElementById('cssxPassword').value = "";

	document.getElementById('cssxQRCodePrivateKeyWIFUncompressed').innerHTML = "";
	document.getElementById('cssxQRCodePublicKeyUncompressed').innerHTML = "";
	document.getElementById('cssxQRCodePrivateKeyWIFCompressed').innerHTML = "";
	document.getElementById('cssxQRCodePublicKeyCompressed').innerHTML = "";

	document.getElementById('cssxQRCodePrivateKeyWIFUncompressedValue').innerHTML = "";
	document.getElementById('cssxQRCodePublicKeyUncompressedValue').innerHTML = "";
	document.getElementById('cssxQRCodePrivateKeyWIFCompressedValue').innerHTML = "";
	document.getElementById('cssxQRCodePublicKeyCompressedValue').innerHTML = "";

	document.getElementById('cssxPrivateKeyBin').value = "";
	document.getElementById('cssxPrivateKeyDec').value = "";
	document.getElementById('cssxPrivateKeyHex').value = "";
	document.getElementById('cssxPrivateKeyBase58').value = "";
	document.getElementById('cssxPrivateKeyBase64').value = "";

	document.getElementById('cssxPrivateKeyVersion').value = "";
	document.getElementById('cssxHashA1').value = "";
	document.getElementById('cssxHashA2').value = "";
	document.getElementById('cssxChecksumA').value = "";
	document.getElementById('cssxPrivateKeyChecksum').value = "";
	document.getElementById('cssxPrivateKeyWIFUncompressed').value = "";

	document.getElementById('cssxPrivateKeyVersionComp').value = "";
	document.getElementById('cssxHashB1').value = "";
	document.getElementById('cssxHashB2').value = "";
	document.getElementById('cssxChecksumB').value = "";
	document.getElementById('cssxPrivateKeyChecksumComp').value = "";
	document.getElementById('cssxPrivateKeyWIFCompressed').value = "";

	document.getElementById('cssxX').value = "";
	document.getElementById('cssxY').value = "";
	document.getElementById('cssxPublicKey').value = "";

	document.getElementById('cssxPublicKeyVersion').value = "";
	document.getElementById('cssxHashC1').value = "";
	document.getElementById('cssxHashC2').value = "";
	document.getElementById('cssxPublicKeyVersionHashC').value = "";
	document.getElementById('cssxHashC3').value = "";
	document.getElementById('cssxHashC4').value = "";
	document.getElementById('cssxChecksumC').value = "";
	document.getElementById('cssxPublicKeyChecksumC').value = "";
	document.getElementById('cssxPublicKeyUncompressed').value = "";

	document.getElementById('cssxYOddOrEven').value = "";
	document.getElementById('cssxPublicKeyVersionComp').value = "";
	document.getElementById('cssxHashD1').value = "";
	document.getElementById('cssxHashD2').value = "";
	document.getElementById('cssxPublicKeyVersionHashD').value = "";
	document.getElementById('cssxHashD3').value = "";
	document.getElementById('cssxHashD4').value = "";
	document.getElementById('cssxChecksumD').value = "";
	document.getElementById('cssxPublicKeyChecksumD').value = "";
	document.getElementById('cssxPublicKeyCompressed').value = "";

	document.getElementById('cssxPrivateKeyBinLength').value = "";
	document.getElementById('cssxPrivateKeyHexLength').value = "";
	document.getElementById('cssxPrivateKeyBase58Length').value = "";
	document.getElementById('cssxPrivateKeyBase64Length').value = "";

	document.getElementById('cssxPrivateKeyVersionLength').value = "";
	document.getElementById('cssxHashA1Length').value = "";
	document.getElementById('cssxHashA2Length').value = "";
	document.getElementById('cssxChecksumALength').value = "";
	document.getElementById('cssxPrivateKeyChecksumLength').value = "";
	document.getElementById('cssxPrivateKeyWIFUncompressedLength').value = "";

	document.getElementById('cssxPrivateKeyVersionCompLength').value = "";
	document.getElementById('cssxHashB1Length').value = "";
	document.getElementById('cssxHashB2Length').value = "";
	document.getElementById('cssxChecksumBLength').value = "";
	document.getElementById('cssxPrivateKeyChecksumCompLength').value = "";
	document.getElementById('cssxPrivateKeyWIFCompressedLength').value = "";
	document.getElementById('cssxPublicKeyVersionLength').value = "";
	document.getElementById('cssxPublicKeyUncompressedLength').value = "";
	document.getElementById('cssxPublicKeyCompressedLength').value = "";

	document.getElementById('cssxXLength').value = "";
	document.getElementById('cssxYLength').value = "";
	document.getElementById('cssxPublicKeyLength').value = "";
	document.getElementById('cssxHashC1Length').value = "";
	document.getElementById('cssxHashC2Length').value = "";
	document.getElementById('cssxPublicKeyVersionHashCLength').value = "";
	document.getElementById('cssxHashC3Length').value = "";
	document.getElementById('cssxHashC4Length').value = "";
	document.getElementById('cssxChecksumCLength').value = "";
	document.getElementById('cssxPublicKeyChecksumCLength').value = "";

	document.getElementById('cssxPublicKeyVersionCompLength').value = "";
	document.getElementById('cssxHashD1Length').value = "";
	document.getElementById('cssxHashD2Length').value = "";
	document.getElementById('cssxPublicKeyVersionHashDLength').value = "";
	document.getElementById('cssxHashD3Length').value = "";
	document.getElementById('cssxPublicKeyVersionHashDLength').value = "";
	document.getElementById('cssxHashD4Length').value = "";
	document.getElementById('cssxChecksumDLength').value = "";
	document.getElementById('cssxPublicKeyChecksumDLength').value = "";

	jsxClearVanityInputFields();
}


function jsxShowMoreDetails(){
	var trVal = "table-row";
	var divVal = "inline";

	if (document.inputForm.cssxShowMoreDetails.checked == false) {
		trVal = "none";
		divVal = "none";
	}

	var elems = document.getElementsByTagName("tr");
  	for(var i =0; i<elems.length; i++){
		if(elems[i].getAttribute("class") == "cssxHideTr") {
			elems[i].style.display = trVal;
		}
  	}

	elems = document.getElementsByTagName("div");
  	for(var i =0; i<elems.length; i++){
		if(elems[i].getAttribute("class") == "cssxHideDiv") {
			elems[i].style.display = divVal;
		}
  	}
}

// finds any duplicate array elements using the fewest possible comparison
function jsxArrayHasDuplicates(arr) {
	var i, j, n;
	var n=arr.length;
    	                                     // to ensure the fewest possible comparisons
	for (i=0; i<n; i++) {                    // outer loop uses each item i at 0 through n
		for (j=i+1; j<n; j++) {              // inner loop only compares items j at i+1 to n
			if ((""+arr[i])==(""+arr[j])) {
				return true;
			}
	}	}
	return false;
}

/*
 * ModSqrt borrowed and translated from http://eli.thegreenplace.net/2009/03/07/computing-modular-square-roots-in-python/
 */
function LegendreSymbol(a, p) {
    var r = a.modPow(p.subtract(BigInteger.ONE).divide(new BigInteger("2")), p);
    if( r.equals(p.subtract(BigInteger.ONE)) ) return new BigInteger("-1");
    return r;
}

/* return `ret' such that ret^2 = this (mod p) */
function bnModSqrt(p) {
    var TWO = new BigInteger("2");
    var NEG_ONE = new BigInteger("-1");

    if( !(LegendreSymbol(this, p).equals(BigInteger.ONE)) )
        return BigInteger.ZERO;

    if( this.equals(BigInteger.ZERO) )
        return BigInteger.ZERO;

    if( p.equals(TWO) )
        return p;

    if( p.mod(new BigInteger("4")).equals(new BigInteger("3")) )
        return this.modPow(p.add(BigInteger.ONE).divide(new BigInteger("4")), p);

    var s = p.subtract(BigInteger.ONE);
    var e = 0;

    while( s.mod(TWO).equals(BigInteger.ZERO) ) {
        s = s.divide(TWO);
        e += 1;
    }

    // find some legendre symbol n|p = -1
    var n = TWO;
    while( !LegendreSymbol(n, p).equals(NEG_ONE) ) {
        n = n.add(BigInteger.ONE);
    }

	// Mobilefish.com comment out
    //console.log("LegendreSymbol found: " + n);

    /*
     * Here be dragons!
     * Read the paper "Square roots from 1; 24, 51,
     * 10 to Dan Shanks" by Ezra Brown for more
     * information
     *
     * x is a guess of the square root that gets better
     * with each iteration.
     * b is the "fudge factor" - by how much we're off
     * with the guess. The invariant x^2 = ab (mod p)
     * is maintained throughout the loop.
     * g is used for successive powers of n to update
     * both a and b
     * r is the exponent - decreases with each update
     */
    var x = this.modPow(s.add(BigInteger.ONE).divide(TWO), p);
    var b = this.modPow(s, p);
    var g = n.modPow(s, p);
    var r = e;
    var q = BigInteger.ZERO.clone();

    while(true) {
        var t = b.clone();
        var m = 0;

        for( ; m < r; m += 1 ) {
            if(t.equals(BigInteger.ONE))
                break;
            t = t.modPow(TWO, p);
        }

        if( m == 0 )
            return x;

        q.fromInt(r - m - 1);

        var gs = g.modPow(TWO.pow(q), p);
        g = gs.multiply(gs).mod(p);
        x = x.multiply(gs).mod(p);
        b = b.multiply(g).mod(p);
        r = m;
    }
}

BigInteger.prototype.modSqrt = bnModSqrt;


function uint(f, size) {
    if (f.length < size)
        throw new Error("not enough data");
    var n = 0;
    for (var i = 0; i < size; i++) {
        n *= 256;
        n += f[i];
    }
    return n;
}

function u8(f)  { return uint(f,1); }

function decompress_pubkey(key_bytes) {
    var y_bit = u8(key_bytes.slice(0, 1)) & 0x01;

    var ecparams = getSECCurveByName("secp256k1");

    // build X
    var x     = BigInteger.ZERO.clone();
    x.fromString(Crypto.util.bytesToHex(key_bytes.slice(1, 33)), 16);
	//var x_hex_value = key_bytes.substr(2);
    //x.fromString(x_hex_value, 16);

    // get curve
    var curve = ecparams.getCurve();
    var a = curve.getA().toBigInteger();
    var b = curve.getB().toBigInteger();
    var p = curve.getQ();

    // compute y^2 = x^3 + a*x + b
    var tmp = x.multiply(x).multiply(x).add(a.multiply(x)).add(b).mod(p);

	//alert(tmp); // tmp is goed uitgerekend

    // compute modular square root of y (mod p)
    var y = tmp.modSqrt(p);  // <== TODO y not calculated correctly

    // flip sign if we need to
    if( (y[0] & 0x01) != y_bit ) {
        y = y.multiply(new BigInteger("-1")).mod(p);
    }

    return new ECPointFp(curve, curve.fromBigInteger(x), curve.fromBigInteger(y));
}


function jsxMakePrinterFriendlyPage(){
	var displayVal = "table-row";
	var displayVal2 = "inline";

	var elems = document.getElementsByTagName("tr");
  	for(var i =0; i<elems.length; i++){
		if(elems[i].getAttribute("class") == "cssxHideTr") {
			elems[i].style.display = "none";
		}
  	}

	elems = document.getElementsByTagName("div");
  	for(var i =0; i<elems.length; i++){
		if(elems[i].getAttribute("class") == "cssxHideDiv") {
			elems[i].style.display = "none";
		}
  	}

	elems = document.getElementsByTagName("tr");
  	for(var i =0; i<elems.length; i++){
		if(elems[i].getAttribute("class") == "cssxNoPrint") {
			elems[i].style.display = "none";
		}
  	}

	elems = document.getElementsByTagName("span");
  	for(var i =0; i<elems.length; i++){
		if(elems[i].getAttribute("class") == "cssxNoPrint") {
			elems[i].style.display = "none";
		}
  	}

	document.getElementById("cssxMainTable").style.backgroundColor = "#ffffff";
	document.getElementById("cssxMainTable").style.border = "0px";

}

function jsxShowBitcoinImage() {
	var bitcoinImage = new Image();
	bitcoinImage.src = "data:image/gif;base64,"+
"/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAkGBwgHBgkIBwgKCgkLDRYPDQwMDRsUIRAWICQnLCAdHx8k"+
"KC44LyYxJSUrLT0tMTUsNC86JyRGRDQ4Oi01OjcBCgoKDQwNGg8PGjclHyU2NDc3NzcyNDQ3Nzc3NzQ0"+
"Lzc3NSw0NDc2NzQ0LC43NDczNCwyNDQ0NDQ4NDU1LDg2Nf/AABEIADIAMgMBIgACEQEDEQH/xAAbAAAC"+
"AgMBAAAAAAAAAAAAAAAAAwUGAQQHAv/EADgQAAEDAwEEBwUGBwAAAAAAAAECAwQABRExEiFBYQYTFCJR"+
"gaEyQ3FysQckQsHR8RUWI1JTYrL/xAAaAQADAQADAAAAAAAAAAAAAAADBAUAAQIG/8QAJBEAAgEEAAUF"+
"AAAAAAAAAAAAAAECAwQREhMhMTJRFEGRobH/2gAMAwEAAhEDEQA/AO3uuIabU46oIQkZUpRwAKq8q9zr"+
"kootP3eLp2lacqX8qToOZpt6Wq63E25JPZI2FSMe8WfZT8BrURdZz6HkwoCMKJ2MpwMnwFSby7ntw6fy"+
"N0aSxtI9SLdCJzdJTshZ/wA7xPpmlt262KV9yyw5wUw8Un60iDZ5rpmqnQlZ7Oep2lpOXOGhpotkiOxa"+
"ldkXt9We1lHeIVuxx38dKnaT7mxjaPQ32rheLQQVqVcog9pCxhxA5Hj5+lWe23CLc4iZMNwLbO48Ck8Q"+
"RwNQsN5kJ20L6xrOFZ1RUbPc/lu7t3WNugyFBE1saDOixzH6+NO215KEtZvK/BerTUu1F2orAIIBByDo"+
"aKtChVbMtRs7073khbjxz4k7qi1Rlq35UFZyFJOCD41vWQlViEZXttbbah4EE09ltoJ2lk48Sa8w5c+Z"+
"TisZExlyj0YlFLjzklLbwbVklWRnZxzpNg/iPXNdauWpotku9pTjB4Yzv/KtgPdV0dmvxV7JQh9Taxvw"+
"RnBqNts24mVEDc4y0uKSHW1IT3U8TkDdij+Afk2hLYXep3UrSWwEoXjisa+mB5UyelMyySWVd4bCgM8t"+
"4pPSUNsTIrrYCXXQoLx+IDG8/CsB4M2R91zd3Fq9KXqLEmFhhxK9C+0KTDhsRcBXUtpbyRrgYoqtI6P3"+
"CQhL7bJKHBtpOOBop5VrjABwpnUbghVpvjmd0WerbQr+138Q89aw+FjCm8YCgoZ0BHjyqy3KBHuURcWU"+
"nabVxGqTwI51WyuTYst3ZpciGNyJjSc4H+44fGtd2koz3j0f0cUqyccPqKiXeatUwPtMYZYLiCjPeI4G"+
"kzL3PTCtjkZlgOS2ypzaSTsEY03862kizTwFtvMn5VgehpoYs0Qlx15ofO4B9KXUm+WQjSyV1iHPuU4v"+
"yXFrVopZGAkeAFe78FzX43R+Af68hQDhHu0DUny3/vUpI6SrmqMDotDMp7QuhOENcyf19al+jHR1NmS5"+
"Iku9puUje++f+U8vrRaNo6s8+x1lW1jjBMRYrMWMzHZQA20gIQPAAYFFOoq7gRCiiisY579okOLGCXI8"+
"ZlpahlSm2wkk8yKqfRNpuVcm0SkJeQVey4NoetFFSKyXqBuDfDO1R2GYzSWo7TbTY0Q2kJA8hTKKKrig"+
"UUUVjH//2Q==";
	document.write('<img src="'+bitcoinImage.src+'" alt="Bitcoin" title="Bitcoin" width="50" height="50" />');
}


function jsxShowKeepSecretImage() {
	var keepSecretImage = new Image();
	keepSecretImage.src = "data:image/gif;base64,"+
"R0lGODlhCgAKAMQAAKl2AJmZmeCyFmZmZv/1r+7VbsyZALKysr+YQP/MAOXl5f//3biFAP/WLOa"+
"/QH9/f92pAP/lbr6LANejAK98AL+/v8KQALJ/AP///wAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BA"+
"EHABgALAAAAAAKAAoAAAVCIIYpQRkoovgEVRU8KTYc4jGIjgBARQEBAsdkQSwSJwCGAUIgQAwMg"+
"CVCrVItyWWj8YxSEuAwmIK4SAyTiUFyQYQAADs=";
	document.write('<img src="'+keepSecretImage.src+'" alt="keep information secret" title="keep information secret" width="10" height="10" />');
}

function jsxShowShareImage() {
	var shareImage = new Image();
	shareImage.src = "data:image/gif;base64,"+
"iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAACXBIWXMAAAsTAAALEwEAmpwYAAA"+
"AIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAC3SURBVHjahJHdDY"+
"JAEIS/JRRACZRAB2oHBhrQDrwKhAY4O9AGSOhA7QA6oITr4HxZzOXCzyT7cjOZ250R7z1rkMqeg"+
"SeQAQNwStjGLAYoAJtsuBeBeEaeBuQR6JW4A5cFn0EoWwvc9MEFrg54AbnOAJg0EBOIH0DjO+Pi"+
"L5ZucMC4JAYQyvat+8eYgAY46Epf35laKNtMD8xUNAFWY4zRyFpxUtla0wrxkZ2mY7Lfa/qqIfx"+
"v+g0ATyc1Ay9mImIAAAAASUVORK5CYII=";
	document.write('<img src="'+shareImage.src+'" alt="information can be shared" title="information can be shared" width="12" height="12" />');
}

function jsxShowLoadImage() {
	var loadImage = new Image();
	loadImage.src = "data:image/gif;base64,"+
"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"+
"QaZGgXzCgwIADs=";
	document.write('<img src="'+loadImage.src+'" alt="generating..." title="generating..." style="visibility:hidden" width="12" height="12" id="cssxLoadImage"/>');
}

function jsxShowDiceImage() {
	var diceImage = new Image();
	diceImage.src = "data:image/gif;base64,"+
"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"+
"oP//Z";
	document.write('<img src="'+diceImage.src+'" alt="Two different 16 sided dices" title="Two different 16 sided dices" width="150" height="114"/>');
}

function jsxShowAddingPointsImage() {
	var addingPointsImage = new Image();
	addingPointsImage.src = "data:image/gif;base64,"+
"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";
	document.write('<img src="'+addingPointsImage.src+'" alt="Adding points P and Q" title="Adding points P and Q" style="align:left; margin-left: 30px" width="200" height="200" id="cssxAddingPoints"/>');
}


function jsxShowDoublingPointImage() {
	var doublingPointImage = new Image();
	doublingPointImage.src = "data:image/gif;base64,"+
"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"+
"A7";
	document.write('<img src="'+doublingPointImage.src+'" alt="Doubling points P" title="Doubling point P" style="align:left; margin-left: 30px" width="200" height="200" id="cssxDoublingPoint"/>');
}

function jsxShowBitcoinAddressImage() {
	var bitcoinAddressImage = new Image();
	bitcoinAddressImage.src = "data:image/gif;base64,"+
"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"+
"spWvjOUsa3nLXNZyAQAAOw==";
document.write('<img src="'+bitcoinAddressImage.src+'" alt="Mobilefish.com Bitcoin address" title="Mobilefish.com Bitcoin address" width="147" height="144" />');
}

function jsxViewOnBlockChain(id) {
	if(jsxIsPublicKeyCompressedOrUncompressedValid(id, false)) {
		var publicKeyCompressedOrUncompressed = document.getElementById(id).value;
		var url = "https://blockchain.info/address/"+publicKeyCompressedOrUncompressed;
		window.open(url, '_blank'); // open in new window
		//location.href = url;      // open in same window
	}
}

</script>
</head>

<body onload="jsxLoaded()">
<h1 class="cssxNoPrint">Cryptocurrency address generator and validator (v1.1)</h1>

<!-- Show bitcoin image -->
<span class="cssxNoPrint" style="float:right">
<script language="JavaScript" type="text/javascript">jsxShowBitcoinImage();</script>
</span>

<span class="cssxNoPrint">
<br /><br />
This webpage is created for educational purpose explaining how cryptocurrency public and private keys are generated.<br />
<b>Do not use this tool in production, otherwise you will lose all your Bitcoins or other cryptocurrencies.</b><br />
All calculations are done in the browser using Javascript and no data is transmitted to any server. Verify this by inspecting the source code.
<br /><br />
The following functionalities are implemented:<br />
- Creating public keys (addresses) and private keys (uncompressed and compressed) for different cryptocurrencies (Bitcoin, Litecoin etc).<br />
&nbsp;&nbsp;All intermediate calculation steps can be seen by enabling checkbox "Show more details".<br />
- Creating paper wallets including QR codes<br />
- Creating vanity addresses
<br /><br />
Symbol legend<br />
|| : To indicate the concatenation of two strings on either side of the || symbol.<br />
<script language="JavaScript" type="text/javascript">jsxShowKeepSecretImage();</script> : The information should be kept secret.<br />
<script language="JavaScript" type="text/javascript">jsxShowShareImage();</script> : The information can be made public.
<br /><br />
</span>

<form name="inputForm" action="javascript:void(null);">
<table border="0" cellspacing="3" cellpadding="0"  class="css-Table" id="cssxMainTable">

<tr class="cssxNoPrint">
	<td width="280" class="css-Data">Select cryptocurrency network</td>
	<td colspan="2">
		<select name="cssxNetwork" id="cssxNetwork" onchange="jsxChangeNetwork();jsxValidateEnteredDiceNumbers();">
		<script language="JavaScript" type="text/javascript">
		for(var i=0; i<coinaddress_arr.length; i++) {
			var selected = "";
			if(i==0){
				selected ="selected='selected'"
			}
			document.write("<option value='"+coinaddress_arr[i][0]+"' "+selected+">"+coinaddress_arr[i][0]+"<\/option>");
		}
		</script>
		</select>
	</td>
	<td colspan="2">
		<input type="checkbox" name="cssxShowMoreDetails" id="cssxShowMoreDetails" onclick="jsxShowMoreDetails()"><label for="cssxShowMoreDetails" id="cssxShowMoreDetailsText">Show more details</label>
	</td>
</tr>

<tr class="cssxNoPrint"><td colspan="5"><hr /></td></tr>

<tr class="cssxNoPrint">
	<td class="css-Data">Reset</td>
	<td colspan="2">
		Clear all entered and calculated values.
	</td>
	<td colspan="2">
		<input type="button" class="css-Button" value="Clear" name="cssxClearAllData" id="cssxClearAllData" onclick=" jsxClearPassword();jsxGenerateRandomNumbers(false)" />
	</td>
</tr>

<tr class="cssxNoPrint"><td colspan="5"><hr /></td></tr>

<tr class="cssxNoPrint">
	<td class="css-Data" rowspan="4">
		Create random numbers<br />
		Choose one of the methods.

	</td>
</tr>


<tr class="cssxNoPrint">
	<td colspan="2">
		<a name="refMethod1"></a><b>Method 1</b>: <br />
		Auto generate cryptographically secure random numbers by pressing the "Generate" button or press the ESC key.
		<br /><br />
		This tool uses two methods to generate cryptographic pseudorandom numbers depending if your browser supports it.
		<ul>
		<li>The first method is using your browser WebCryptoAPI:
			<ul>
				<li>
					<a href="https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues" onclick="return jsxConfirmAlert(this);">Mozilla: window.crypto.getRandomValues(array)</a>
				</li>
				<li>
					<a href="https://msdn.microsoft.com/en-us/library/ie/dn302324%28v=vs.85%29.aspx" onclick="return jsxConfirmAlert(this);">Microsoft: window.msCrypto.getRandomValues(array)</a>
				</li>
			</ul>
			<br>
		</li>
		<li>If your browser does not support the WebCryptoAPI it uses the <a href="http://crypto.stanford.edu/sjcl/" onclick="return jsxConfirmAlert(this);">Stanford Javascript Crypto Library (SJCL)</a><br />
			to generate pseudorandom numbers.
		</li>
		</ul>

		The random numbers below are
		<select name="cssxSystemRandomNumbers" id="cssxSystemRandomNumbers" onchange="jsxChangeSystemRandomNumbers();">
		<option value="dec">decimal values (0-255)</option>
		<option value="hex" selected="selected">hexadecimal values (00-FF)</option>
		</select>
		<br /><br />

		<script language="JavaScript" type="text/javascript">
		for(var i=0; i<MAX_RANDOM_BYTES; i++){
			document.write("<input type='text' value='' size='2' maxlength='3' name='cssxRandomNumber"+i+"' id='cssxRandomNumber"+i+"' readonly='readonly' />");
			if(i==7|| i==15 || i==23) {
				jsxShowKeepSecretImage();
				document.write("<br />");
			}
		}
		jsxShowKeepSecretImage();
		</script>
		<br /><br />
	</td>
	<td colspan="2" width="300">
		<br />
		<input type="button" class="css-Button" value="Generate" name="cssxGenerateRandomNumbers" id="cssxGenerateRandomNumbers" onclick="jsxClearPassword();jsxGenerateRandomNumbers(true)" />
	</td>
</tr>

<tr class="cssxNoPrint">
	<td colspan="2">
		<a name="refMethod2"></a><b>Method 2</b>: <br />
		Roll a 16 sided dice 64 times and enter its
		<select name="cssxDiceRandomNumbers" id="cssxDiceRandomNumbers" onchange="jsxChangeDiceRandomNumbers();">
		<option value="dec" selected="selected">decimal value (1-16)</option>
		<option value="hex">hexadecimal value (0-F)</option>
		</select> in sequential order:
		<br />
		<script language="JavaScript" type="text/javascript">
		for(var i=0; i<MAX_RANDOM_BYTES*2; i++){
			if(i%2 == 0) {
				document.write("<span class='cssxDiceBlock'>");
			}

			document.write("<input type='text' value='' size='1' maxlength='2' name='cssxDice"+i+"' id='cssxDice"+i+"' class='cssxDiceBlockRow"+Math.floor(i/16)+"' onkeyup='jsxValidateEnteredDiceNumbers(\"field\");' /> ");
			if(i>0 && i%2 != 0) {
				document.write("<\/span>");
			}

			if(i==15|| i==31 || i==47) {
				jsxShowKeepSecretImage();
				document.write("<br />");
			}

		}
		jsxShowKeepSecretImage();
		</script>

		<br /><br />
		<div class="cssxHideDiv">
			<div class="css-Note">
				<ul>
					<li>
					Total number of combinations:<br />
					2<sup>(32*8)</sup> = 2<sup>256</sup> = 115,792,089,237,316,195,423,570,985,008,687,907,853,269,984,665,640,564,039,457,584,<br />
					007,913,129,639,936 (78 digits or approximately 10<sup>77</sup>)<br />
					The number of atoms in the entire observable universe is estimated to be within the range of 10<sup>78</sup> to 10<sup>82</sup>
					<br /><br />
					</li>
					<li>
					A valid random number must be in the interval [1, n - 1], where:<br />
					n = FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141<br />
					See: <a href="#refSecp256k1">secp256k1 elliptic curve domain parameters</a>
					<br /><br />
					</li>
					<li>
					If you use this method make sure the chosen numbers are truly random.<br />
					One way is to use a 16 sided dice.

					<br /><br />
					<script language="JavaScript" type="text/javascript">jsxShowDiceImage();</script>
					<br /><br />
					If you only have one dice you need to roll it 64 times.<br />
					If you have four dices (dice color blue, green, yellow and black) you need to roll them 16 times.
					<br />
					</li>
				</ul>
			</div>
		</div>
	</td>
	<td colspan="2">
		<input type="button" class="css-Button" value="Update" name="cssxValidateEnteredDiceNumbersButton" id="cssxValidateEnteredDiceNumbersButton" onclick="jsxValidateEnteredDiceNumbers('button')" />
	</td
</tr>



<tr class="cssxNoPrint">
	<td colspan="2">
		<a name="refMethod3"></a><b>Method 3</b>: <br />
		Enter password / passphrase.<br />
		This method is highly insecure. Hackers are able to steal your Bitcoins or other cryptocurrencies using this method.<br />
		Make it at least 16 characters long and use letters, numbers and special characters.<br />
		Random number = SHA256(SHA256(password / passphrase)))<br />
		<input name="cssxPassword" id="cssxPassword" type="text" size="90" value=""  onkeyup="jsxEnterPassword();"/>
		<script language="JavaScript" type="text/javascript">jsxShowKeepSecretImage();</script>
	</td>
	<td colspan="2">
		<br />
		<input type="button" class="css-Button" value="Update" id="cssxPasswordButton" onclick="jsxEnterPassword();" />
	</td
</tr>


<tr class="cssxNoPrint"><td colspan="5"><hr /></td></tr>

<tr class="cssxHideTr">
	<td>&nbsp;</td>
	<td class="css-Data" colspan="4">PrivateKey in different formats</td>
</tr>

<tr class="cssxHideTr"><td colspan="5">&nbsp;</td></tr>

<tr class="cssxHideTr">
	<td class="css-Data">&nbsp;</td>
	<td>
		The <a href="#refMethod1">random number</a> is converted into a large hexadecimal value, 32 bytes or 64 characters (chars) long.<br />
		A valid PrivateKeyHex must be in the interval [1, n - 1], where:<br />
		n = FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141<br />
		See: <a href="#refSecp256k1">secp256k1 elliptic curve domain parameters</a><br />
		Look at <a href="#refMethod2">method 2</a> and append each hexadecimal value, this will form the PrivateKeyHex value.<br />
		The PrivateKeyHex value is used to create the <a href="#refPrivateKeyWIFUncompressed">PrivateKey Wallet Import Format (WIF) Uncompressed</a> or<br />
		<a href="#refPrivateKeyWIFCompressed">PrivateKey Wallet Import Format (WIF) Compressed</a>.
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxNoPrint">
	<td class="css-Data"><a name="refPrivateKeyHex"></a>PrivateKeyHex</td>
	<td>
		<input name="cssxPrivateKeyHex" id="cssxPrivateKeyHex" type="text" size="90" value="" onkeyup="jsxChangePrivateKey(this.name);"/>
		<script language="JavaScript" type="text/javascript">jsxShowKeepSecretImage();</script>
	</td>
	<td width="135"><input type="text" name="cssxPrivateKeyHexLength" id="cssxPrivateKeyHexLength" size="4" maxlength="5" readonly="readonly" class="cssxGrey" /> chars</td>
	<td colspan="2">
		<input type="button" class="css-Button" value="Update" id="cssxPrivateKeyHexButton" onclick="jsxChangePrivateKey('cssxPrivateKeyHex');" />
	</td
</tr>

<tr class="cssxHideTr"><td colspan="5">&nbsp;</td></tr>

<tr class="cssxHideTr">
	<td class="css-Data">&nbsp;</td>
	<td>
		The <a href="#refPrivateKeyHex">PrivateKeyHex</a> value can also be encoded into a Base58 value.<br />
		It is similar to Base64 but has been modified to avoid both non-alphanumeric characters and letters which might<br />
		look ambiguous when printed. Compared to Base64, the following letters have been omitted from the alphabet: <br />
		0 (zero), O (capital o), I (capital i) and l (lower case L) as well as the non-alphanumeric characters + (plus) and <br />
		/ (slash). This number is not used within this tool and is only displayed here for educational purpose.
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr">
	<td class="css-Data"><a name="refPrivateKeyBase58"></a>PrivateKeyBase58</td>
	<td>
		<input name="cssxPrivateKeyBase58" id="cssxPrivateKeyBase58" type="text" size="90" value="" onkeyup="jsxChangePrivateKey(this.name);"/>
		<script language="JavaScript" type="text/javascript">jsxShowKeepSecretImage();</script>
	</td>
	<td><input type="text" name="cssxPrivateKeyBase58Length" id="cssxPrivateKeyBase58Length" size="4" maxlength="5" readonly="readonly" class="cssxGrey" /> chars</td>
	<td colspan="2">
		<input type="button" class="css-Button" value="Update" id="cssxPrivateKeyBase58Button" onclick="jsxChangePrivateKey('cssxPrivateKeyBase58');" />
	</td
</tr>

<tr class="cssxHideTr"><td colspan="5">&nbsp;</td></tr>

<tr class="cssxHideTr">
	<td class="css-Data">&nbsp;</td>
	<td>
		The <a href="#refPrivateKeyHex">PrivateKeyHex</a>  value can also be encoded into a Base64 value.<br />
		This number is not used within this tool and is only displayed here for educational purpose.
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr">
	<td class="css-Data"><a name="refPrivateKeyBase64"></a>PrivateKeyBase64</td>
	<td>
		<input name="cssxPrivateKeyBase64" id="cssxPrivateKeyBase64" type="text" size="90" value="" onkeyup="jsxChangePrivateKey(this.name);"/>
		<script language="JavaScript" type="text/javascript">jsxShowKeepSecretImage();</script>
	</td>
	<td><input type="text" name="cssxPrivateKeyBase64Length" id="cssxPrivateKeyBase64Length" size="4" maxlength="5" readonly="readonly" class="cssxGrey" /> chars</td>
	<td colspan="2">
		<input type="button" class="css-Button" value="Update" id="cssxPrivateKeyBase64Button" onclick="jsxChangePrivateKey('cssxPrivateKeyBase64');" />
	</td>
</tr>

<tr class="cssxHideTr"><td colspan="5">&nbsp;</td></tr>

<tr class="cssxHideTr">
	<td class="css-Data">&nbsp;</td>
	<td>
		The <a href="#refMethod2">32 random numbers</a> can also be converted into a comma separated decimal value string.<br />
		This number is not used within this tool and is only displayed here for educational purpose.
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr">
	<td class="css-Data"><a name="refPrivateKeyDec"></a>PrivateKeyDec</td>
	<td>
		<textarea cols="75" rows="2" name="cssxPrivateKeyDec" id="cssxPrivateKeyDec" readonly="readonly" class="cssxGrey"></textarea>
		<script language="JavaScript" type="text/javascript">jsxShowKeepSecretImage();</script>
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr"><td colspan="5">&nbsp;</td></tr>

<tr class="cssxHideTr">
	<td class="css-Data">&nbsp;</td>
	<td>
		The <a href="#refPrivateKeyHex">PrivateKeyHex</a> value can also be encoded into a binary value.<br />
		This value will be used to calculate the public key.
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr">
	<td class="css-Data"><a name="refPrivateKeyBin"></a>PrivateKeyBin</td>
	<td>
		<textarea cols="75" rows="4" name="cssxPrivateKeyBin" id="cssxPrivateKeyBin" readonly="readonly" class="cssxGrey"></textarea>
		<script language="JavaScript" type="text/javascript">jsxShowKeepSecretImage();</script>
	</td>
	<td><input type="text" name="cssxPrivateKeyBinLength" id="cssxPrivateKeyBinLength" size="4" maxlength="5" readonly="readonly" class="cssxGrey" /> chars</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxNoPrint"><td colspan="5"><hr /></td></tr>

<tr class="cssxNoPrint">
	<td>&nbsp;</td>
	<td class="css-Data" colspan="4">Calculate <div id="cssxAddressNetwork1"></div> PrivateKey Wallet Import Format (WIF) Uncompressed</td>
</tr>

<tr class="cssxNoPrint"><td colspan="5">&nbsp;</td></tr>

<tr class="cssxHideTr">
	<td class="css-Data">&nbsp;</td>
	<td>
		Each cryptocurrency privateKey has their own prefix version number (Bitcoin= 0x80, Litecoin=0xB0, etc).<br />
		Prepend this version number in front of the <a href="#refPrivateKeyHex">PrivateKeyHex</a> value.<br />
		The prefix version number is always 1 byte in size and the <a href="#refPrivateKeyHex">PrivateKeyHex</a> is 32 bytes.<br />
		The PrivateKeyVersion value is always (1+32=) 33 bytes or 66 characters long.
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr">
	<td class="css-Data"><a name="refPrivateKeyVersion"></a>PrivateKeyVersion = <br />Version "<div style="display:inline" id="cssxPrivateKeyPrefix"></div>" || PrivateKeyHex</td>
	<td>
		<input name="cssxPrivateKeyVersion" id="cssxPrivateKeyVersion" type="text" size="90" value="" readonly="readonly" class="cssxGrey"/>
		<script language="JavaScript" type="text/javascript">jsxShowKeepSecretImage();</script>
	</td>
	<td><input type="text" name="cssxPrivateKeyVersionLength" id="cssxPrivateKeyVersionLength" size="4" maxlength="5" readonly="readonly" class="cssxGrey" /> chars</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr"><td colspan="5">&nbsp;</td></tr>

<tr class="cssxHideTr">
	<td class="css-Data">&nbsp;</td>
	<td>
		Hash the <a href="#refPrivateKeyVersion">PrivateKeyVersion</a> value using the cryptographic hash function SHA256.<br />
		This Secure Hash Algorithm generates a 256-bit (32-byte) signature which cannot be decrypted back <br />
		to the original value (it is a one-way cryptographic function).<br />
		The HashA1 value is always 32 bytes or 64 characters long.
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr">
	<td class="css-Data"><a name="refHashA1"></a>HashA1 = <br />SHA256(PrivateKeyVersion)</td>
	<td>
		<input name="cssxHashA1" id="cssxHashA1" type="text" size="90" value="" readonly="readonly" class="cssxGrey"/>
		<script language="JavaScript" type="text/javascript">jsxShowKeepSecretImage();</script>
	</td>
	<td><input type="text" name="cssxHashA1Length" id="cssxHashA1Length" size="4" maxlength="5" readonly="readonly" class="cssxGrey" /> chars</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr"><td colspan="5">&nbsp;</td></tr>

<tr class="cssxHideTr">
	<td class="css-Data">&nbsp;</td>
	<td>
		Hash the <a href="#refHashA1">HashA1</a> value using the same cryptographic hash function SHA256.<br />
		The HashA2 value is always 32 bytes or 64 characters long.
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr">
	<td class="css-Data"><a name="refHashA2"></a>HashA2 = <br />SHA256(HashA1)</td>
	<td>
		<input name="cssxcssxHashA2" id="cssxHashA2" type="text" size="90" value="" readonly="readonly" class="cssxGrey"/>
		<script language="JavaScript" type="text/javascript">jsxShowKeepSecretImage();</script>
	</td>
	<td><input type="text" name="cssxHashA2Length" id="cssxHashA2Length" size="4" maxlength="5" readonly="readonly" class="cssxGrey" /> chars</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr"><td colspan="5">&nbsp;</td></tr>

<tr class="cssxHideTr">
	<td class="css-Data">&nbsp;</td>
	<td>
		Get the first 4 bytes (or first 8 characters) of the <a href="#refHashA2">HashA2</a> value.<br />
		These 4 bytes is the checksum value which will be used to validate the address.<br />
		The ChecksumA value is always 4 bytes or 8 characters long.
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr">
	<td class="css-Data"><a name="refChecksumA"></a>ChecksumA <br />(first 4 bytes of HashA2)</td>
	<td>
		<input name="cssxChecksumA" id="cssxChecksumA" type="text" size="90" value="" readonly="readonly" class="cssxGrey"/>
		<script language="JavaScript" type="text/javascript">jsxShowKeepSecretImage();</script>
	</td>
	<td><input type="text" name="cssxChecksumALength" id="cssxChecksumALength" size="4" maxlength="5" readonly="readonly" class="cssxGrey" /> chars</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr"><td colspan="5">&nbsp;</td></tr>

<tr class="cssxHideTr">
	<td class="css-Data">&nbsp;</td>
	<td>
		Append the <a href="#refChecksumA">ChecksumA</a> value at the end of the <a href="#refPrivateKeyVersion">PrivateKeyVersion</a> value.<br />
		The PrivateKeyChecksum value is always (33+4=) 37 bytes or 74 characters long.
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr">
	<td class="css-Data"><a name="refPrivateKeyChecksum"></a>PrivateKeyChecksum = PrivateKeyVersion || ChecksumA</td>
	<td>
		<input name="cssxPrivateKeyChecksum" id="cssxPrivateKeyChecksum" type="text" size="90" value="" readonly="readonly" class="cssxGrey"/>
		<script language="JavaScript" type="text/javascript">jsxShowKeepSecretImage();</script>
	</td>
	<td><input type="text" name="cssxPrivateKeyChecksumLength" id="cssxPrivateKeyChecksumLength" size="4" maxlength="5" readonly="readonly" class="cssxGrey" /> chars</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr"><td colspan="5">&nbsp;</td></tr>

<tr class="cssxHideTr">
	<td class="css-Data">&nbsp;</td>
	<td>
		The <a href="#refPrivateKeyWIFUncompressed">PrivateKey Wallet Import Format (WIF) Uncompressed</a> is the <a href="#refPrivateKeyChecksum">PrivateKeyChecksum</a> value encoded into a<br />
		Base58 value. The <a href="#refPrivateKeyWIFUncompressed">PrivateKeyWIFUncompressed</a> value must be kept secret and can be converted into <a href="#refQRCodes">QR codes</a><br />
		and can be printed on <a href="#refQRCodes">paper wallets</a>.
		<br /><br />
		If your software uses the <a href="#refPrivateKeyWIFUncompressed">PrivateKeyWIFUncompressed</a> value, it also means you are the using the <br />
		<a href="#refPublicKeyUncompressed">PublicKeyUncompressed</a>.
		<br /><br />
		It is recommended to always to use the compressed public key (<a href="#refPublicKeyCompressed">PublicKeyCompressed</a>) and the compressed<br />
		private key (<a href="#refPrivateKeyWIFCompressed">PrivateKeyWIFCompressed</a>. If your software does not support the compressed keys you can use<br />
		the uncompressed public key (<a href="#refPublicKeyUncompressed">PublicKeyUncompressed</a>) and uncompressed private key<br />
		(<a href="#refPrivateKeyWIFUncompressed">PrivateKeyWIFUncompressed</a>).
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxNoPrint">
	<td class="css-Data"><a name="refPrivateKeyWIFUncompressed"></a>PrivateKeyWIFUncompressed <div class="cssxHideDiv">= Base58(PrivateKeyChecksum)</div></td>
	<td>
		<input name="cssxPrivateKeyWIFUncompressed" id="cssxPrivateKeyWIFUncompressed" type="text" size="90" value="" onkeyup="jsxChangePrivateKey(this.name)" class="cssxRed"/>
		<script language="JavaScript" type="text/javascript">jsxShowKeepSecretImage();</script>
	</td>
	<td><input type="text" name="cssxPrivateKeyWIFUncompressedLength" id="cssxPrivateKeyWIFUncompressedLength" size="4" maxlength="5" readonly="readonly" class="cssxGrey" /> chars</td>
	<td colspan="2">
		<input type="button" class="css-Button" value="Update" id="cssxPrivateKeyWIFUncompressedButton" onclick="jsxChangePrivateKey('cssxPrivateKeyWIFUncompressed');" />
	</td>
</tr>

<tr class="cssxNoPrint"><td colspan="5"><hr /></td></tr>

<tr class="cssxNoPrint">
	<td>&nbsp;</td>
	<td class="css-Data" colspan="4">Calculate <div id="cssxAddressNetwork2"></div> PrivateKey Wallet Import Format (WIF) Compressed</td>
</tr>

<tr class="cssxNoPrint"><td colspan="5">&nbsp;</td></tr>

<tr class="cssxHideTr">
	<td class="css-Data">&nbsp;</td>
	<td>
		Each cryptocurrency has their own prefix version number (Bitcoin= 0x80, Litecoin=0xB0, etc).<br />
		Prepend this version number in front of the <a href="#refPrivateKeyHex">PrivateKeyHex</a> value and also append the value 0x01<br />
		to indicate that it correspond to a compressed public key. The prefix version number and compression flag <br />
		is always 1 byte in size and the <a href="#refPrivateKeyHex">PrivateKeyHex</a> is 32 bytes.<br />
		The PrivateKeyVersionComp value is always (1+32+1=) 34 bytes or 68 characters long.
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr">
	<td class="css-Data"><a name="refPrivateKeyVersionComp"></a>PrivateKeyVersionComp = <br />Version "<div style="display:inline" id="cssxPrivateKeyPrefixComp"></div>" || PrivateKeyHex || "01"</td>
	<td>
		<input name="cssxPrivateKeyVersionComp" id="cssxPrivateKeyVersionComp" type="text" size="90" value="" readonly="readonly" class="cssxGrey"/>
		<script language="JavaScript" type="text/javascript">jsxShowKeepSecretImage();</script>
	</td>
	<td><input type="text" name="cssxPrivateKeyVersionCompLength" id="cssxPrivateKeyVersionCompLength" size="4" maxlength="5" readonly="readonly" class="cssxGrey" /> chars</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr"><td colspan="5">&nbsp;</td></tr>


<tr class="cssxHideTr">
	<td class="css-Data">&nbsp;</td>
	<td>
		Hash the <a href="#refPrivateKeyVersionComp">PrivateKeyVersionComp</a> value using the cryptographic hash function SHA256.<br />
		This Secure Hash Algorithm generates a 256-bit (32-byte) signature which cannot be decrypted back <br />
		to the original value (it is a one-way cryptographic function).<br />
		The HashB1 value is always 32 bytes or 64 characters long.
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>


<tr class="cssxHideTr">
	<td class="css-Data"><a name="refHashB1"></a>HashB1 = SHA256(PrivateKeyVersionComp)</td>
	<td>
		<input name="cssxHashB1" id="cssxHashB1" type="text" size="90" value="" readonly="readonly" class="cssxGrey"/>
		<script language="JavaScript" type="text/javascript">jsxShowKeepSecretImage();</script>
	</td>
	<td><input type="text" name="cssxHashB1Length" id="cssxHashB1Length" size="4" maxlength="5" readonly="readonly" class="cssxGrey" /> chars</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr"><td colspan="5">&nbsp;</td></tr>


<tr class="cssxHideTr">
	<td class="css-Data">&nbsp;</td>
	<td>
		Hash the <a href="#refHashB1">HashB1</a> value using the same cryptographic hash function SHA256.<br />
		The HashB2 value is always 32 bytes or 64 characters long.
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr">
	<td class="css-Data"><a name="refHashB2"></a>HashB2 = SHA256(HashB1)</td>
	<td>
		<input name="cssxHashB2" id="cssxHashB2" type="text" size="90" value="" readonly="readonly" class="cssxGrey"/>
		<script language="JavaScript" type="text/javascript">jsxShowKeepSecretImage();</script>
	</td>
	<td><input type="text" name="cssxHashB2Length" id="cssxHashB2Length" size="4" maxlength="5" readonly="readonly" class="cssxGrey" /> chars</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr"><td colspan="5">&nbsp;</td></tr>

<tr class="cssxHideTr">
	<td class="css-Data">&nbsp;</td>
	<td>
		Get the first 4 bytes (or first 8 characters) of the <a href="#refHashB2">HashB2</a> value.<br />
		These 4 bytes is the checksum value which will be used to validate the address.<br />
		The ChecksumB value is always 4 bytes or 8 characters long.
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr">
	<td class="css-Data"><a name="refChecksumB"></a>ChecksumB (first 4 bytes of HashB2)</td>
	<td>
		<input name="cssxChecksumB" id="cssxChecksumB" type="text" size="90" value="" readonly="readonly" class="cssxGrey"/>
		<script language="JavaScript" type="text/javascript">jsxShowKeepSecretImage();</script>
	</td>
	<td><input type="text" name="cssxChecksumBLength" id="cssxChecksumBLength" size="4" maxlength="5" readonly="readonly" class="cssxGrey" /> chars</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr"><td colspan="5">&nbsp;</td></tr>

<tr class="cssxHideTr">
	<td class="css-Data">&nbsp;</td>
	<td>
		Append the <a href="#refChecksumB">ChecksumB</a> value at the end of the <a href="#refPrivateKeyVersionComp">PrivateKeyVersionComp</a> value.<br />
		The PrivateKeyChecksumComp value is always (34+4=) 38 bytes or 76 characters long.
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr">
	<td class="css-Data"><a name="refPrivateKeyChecksumComp"></a>PrivateKeyChecksumComp = PrivateKeyVersionComp || ChecksumB</td>
	<td>
		<input name="cssxPrivateKeyChecksumComp" id="cssxPrivateKeyChecksumComp" type="text" size="90" value="" readonly="readonly" class="cssxGrey"/>
		<script language="JavaScript" type="text/javascript">jsxShowKeepSecretImage();</script>
	</td>
	<td><input type="text" name="cssxPrivateKeyChecksumCompLength" id="cssxPrivateKeyChecksumCompLength" size="4" maxlength="5" readonly="readonly" class="cssxGrey" /> chars</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr"><td colspan="5">&nbsp;</td></tr>

<tr class="cssxHideTr">
	<td class="css-Data">&nbsp;</td>
	<td>
		The  <a href="#refPrivateKeyWIFCompressed">PrivateKey Wallet Import Format (WIF) Compressed</a> is the <a href="#refPrivateKeyChecksumComp">PrivateKeyChecksumComp</a> value encoded into a<br />
		Base58 value. The <a href="#refPrivateKeyWIFCompressed">PrivateKeyWIFCompressed</a> value must be kept secret and can be converted into <a href="#refQRCodes">QR codes</a><br />
		and can be printed on <a href="#refQRCodes">paper wallets</a>.
		<br /><br />
		If your software uses the <a href="#refPrivateKeyWIFCompressed">PrivateKeyWIFCompressed</a> value, it also means you are the using the <br />
		<a href="#refPublicKeyCompressed">PublicKeyCompressed</a>.
		<br /><br />
		It is recommended to always to use the compressed public key (<a href="#refPublicKeyCompressed">PublicKeyCompressed</a>) and the compressed<br />
		private key (<a href="#refPrivateKeyWIFCompressed">PrivateKeyWIFCompressed</a>. If your software does not support the compressed keys you can use<br />
		the uncompressed public key (<a href="#refPublicKeyUncompressed">PublicKeyUncompressed</a>) and uncompressed private key<br />
		(<a href="#refPrivateKeyWIFUncompressed">PrivateKeyWIFUncompressed</a>).
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxNoPrint">
	<td class="css-Data"><a name="refPrivateKeyWIFCompressed"></a>PrivateKeyWIFCompressed <div class="cssxHideDiv">= Base58(PrivateKeyChecksumComp)</div></td>
	<td>
		<input name="cssxPrivateKeyWIFCompressed" id="cssxPrivateKeyWIFCompressed" type="text" size="90" value="" onkeyup="jsxChangePrivateKey(this.name)"  class="cssxRed"/>
		<script language="JavaScript" type="text/javascript">jsxShowKeepSecretImage();</script>
	</td>
	<td><input type="text" name="cssxPrivateKeyWIFCompressedLength" id="cssxPrivateKeyWIFCompressedLength" size="4" maxlength="5" readonly="readonly" class="cssxGrey" /> chars</td>
	<td colspan="2">
		<input type="button" class="css-Button" value="Update" id="cssxPrivateKeyWIFCompressedButton" onclick="jsxChangePrivateKey('cssxPrivateKeyWIFCompressed');" />
	</td>
</tr>


<tr class="cssxNoPrint"><td colspan="5"><hr /></td></tr>

<tr class="cssxHideTr">
	<td>&nbsp;</td>
	<td class="css-Data" colspan="4">Calculate <div id="cssxAddressNetwork8"></div> PublicKey</td>
</tr>
<tr class="cssxHideTr">
	<td class="css-Data">&nbsp;</td>
	<td>Cryptocurrencies like Bitcoin or Litecoin, etc uses the <a name="refECDSA"></a>Elliptic Curve (EC) to calculate the public keys. <br />
		<a name="refECC"></a>Elliptic Curve Cryptography (ECC) was invented by Neal Koblitz and Victor Miller in 1985.<br />
		A 256-bit ECC public key should provide comparable security to a 3072-bit RSA public key thus less processing<br />
		power is required. Elliptic curves are called elliptic because of their relationship to elliptic<br />
		integrals in mathematics. Elliptic curves have nothing to do with ellipses. Ellipses are formed by quadratic<br />
		curves (x<sup>2</sup>). Elliptic curves are always cubic (x<sup>3</sup>).
		<br /><br />
		Cryptocurrencies uses the following elliptic curve equation: y<sup>2</sup> = x<sup>3</sup> + ax + b
		<br /><br />
		<a name="refSecp256k1"></a>
		<table border="0" cellspacing="1" cellpadding="3" class="css-Table3">
		<tr>
			<td class="css-TableHeader" colspan="2">
				Elliptic curve domain parameters over F<sub>p</sub> associated with a Koblitz curve secp256k1<br />
				Documented by the Standards for Efficient Cryptography Group (www.secg.org)
			</td>
		</tr>
		<tr>
			<td class="css-TableHeader">Parameter</td>
			<td class="css-TableHeader">Value</td>
		</tr>
		<tr>
			<td class="css-Data3">a</td>
			<td class="css-Data3">
				a is the constant that define the ellipc curve y<sup>2</sup> = x<sup>3</sup> + <b>a</b>x + b
				<br /><br />
				a = 0
				<br /><br />
			</td>
		</tr>
		<tr>
			<td class="css-Data3">b</td>
			<td class="css-Data3">
				b is the constant that define the ellipc curve y<sup>2</sup> = x<sup>3</sup> + ax + <b>b</b>
				<br /><br />
				b = 7
				<br /><br />
			</td>
		</tr>
		<tr>
			<td class="css-Data3">p</td>
			<td class="css-Data3">
				A finite field is a field with a finite number of elements, called its order (the size of the underlying set).
				The number of elements is the prime number p.<br />
				F<sub>p</sub> is called the prime field of order p, and is the field of residue classes modulo p, where the p elements are denoted 0, ..., p - 1.<br />
				This means prime number p should be used for all the finite field math operations (better known as modulo operation), for example:<br />
				y<sup>2</sup> mod p = (x<sup>3</sup> + ax + b) mod p
				<br /><br />
				The output of the math operation should never be bigger than the p value.
				<br /><br />
				p = 2<sup>256</sup> - 2<sup>32</sup> - 2<sup>9</sup> - 2<sup>8</sup> - 2<sup>7</sup> - 2<sup>6</sup> - 2<sup>4</sup> - 1 =
				2<sup>256</sup> - 2<sup>32</sup> - 977 =
				<br /><br />
				Hexadecimal:<br />
				FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE FFFFFC2F
				<br /><br />
				Decimal:<br />
				115792089237316195423570985008687907853269984665640564039457584007908834671663
				<br /><br />
			</td>
		</tr>
		<tr>
			<td class="css-Data3">G</td>
			<td class="css-Data3">
				The base point G is a predetermined point (x<sub>G</sub>, y<sub>G</sub>) on the elliptic curve that everyone uses
				to compute other points on the curve.<br />
				Often the base point G is displayed in two ways:
				<ul>
				<li><b>Compressed form (prefix 02)</b><br />
					<b>02</b> 79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9 59F2815B 16F81798
					<br /><br />
					If the prefix is removed, the value is the x<sub>G</sub> coordinate.<br />
					To get the y<sub>G</sub> coordinate, calculate y<sub>G</sub> = (x<sub>G</sub><sup>3</sup> + 7 )<sup>1/2</sup>
					<br /><br />
				</li>
				<li><b>Uncompressed form (prefix 04)</b><br />
					<b>04</b> <br />
					79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9 59F2815B 16F81798<br />
					483ADA77 26A3C465 5DA4FBFC 0E1108A8 FD17B448 A6855419 9C47D08F FB10D4B8
					<br /><br />
					If the prefix is removed, the first half of the value is the x<sub>G</sub> coordinate and the last half
					is the y<sub>G</sub> coordinate.
				</li>
				</ul>
			</td>
		</tr>
		<tr>
			<td class="css-Data3"><a name="refXG"></a>x<sub>G</sub></td>
			<td class="css-Data3">
				Hexadecimal:<br />
				79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9 59F2815B 16F81798
				<br /><br />
				Decimal:<br />
				55066263022277343669578718895168534326250603453777594175500187360389116729240
				<br /><br />
			</td>
		</tr>
		<tr>
			<td class="css-Data3"><a name="refYG"></a>y<sub>G</sub></td>
			<td class="css-Data3">
				Hexadecimal:<br />
				483ADA77 26A3C465 5DA4FBFC 0E1108A8 FD17B448 A6855419 9C47D08F FB10D4B8
				<br /><br />
				Decimal:<br />
				32670510020758816978083085130507043184471273380659243275938904335757337482424
				<br /><br />
			</td>
		</tr>
		<tr>
			<td class="css-Data3"><a name="refN"></a>n</td>
			<td class="css-Data3">
				The prime n which is the order of base point G.
				<br /><br />
				The parameter n determines which is the maximum value that can be turned into a Bitcoin private key.
				Any 256-bit number in the range [1, n - 1]  is a valid private key.
				<br /><br />
				Hexadecimal:<br />
				FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364141
				<br /><br />
				Decimal:<br />
				115792089237316195423570985008687907852837564279074904382605163141518161494337
				<br /><br />
				Thus any 256-bit number from 0x1 to 0xFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364140
				is a valid private key.
				<br /><br />
			</td>
		</tr>
		<tr>
			<td class="css-Data3">h</td>
			<td class="css-Data3">
				The cofactor: 01
			</td>
		</tr>
		</table>
		<br />
		<b>Elliptic curve properties</b>
		<ul>
		<li>If a line intersects two points P and Q, it intersects a third point on the curve -R.</li>
		<li>If a line is tangent to the curve, it intersects another point on the curve.</li>
		<li>All vertical lines intersects the curve at infinity.</li>
		</ul>

		<b>Adding two distinct points P and Q on an elliptic curve (P &#8800; Q)</b><br />
		<ul>
		<li><b><a name="refFig1"></a>Fig. 1 Geometry approach</b>
			<br /><br />
			<script language="JavaScript" type="text/javascript">jsxShowAddingPointsImage();</script>
			<br /><br />
			<ul>
				<li>Draw a straight line between P (x<sub>1</sub>, y<sub>1</sub>) and Q (x<sub>2</sub>, y<sub>2</sub>).</li>
				<li>The line will intersect the elliptic curve at exactly one more point -R (x<sub>3</sub>, -y<sub>3</sub>).</li>
				<li>The reflection of the point -R with respect to x-axis gives the point R (x<sub>3</sub>, y<sub>3</sub>), which is the results of<br />
				 	addition of points P and Q.
				</li>
			</ul>
			<br />
		</li>
		<li><b>Mathematical approach</b><br />
			<ul>
				<li><b>The point slope form of the line:</b><br />
					&#955; = ( y<sub>2</sub> - y<sub>1</sub> ) / ( x<sub>2</sub> - x<sub>1</sub> )<br />
					&#955; ( x<sub>2</sub> - x<sub>1</sub> ) = ( y<sub>2</sub> - y<sub>1</sub> )
					<br /><br />
					Let ( x, y ) be any point on the curve. Repace (x<sub>2</sub>, y<sub>2</sub>) with ( x, y ): <br />
					<span class="cssxEquation">&#955; ( x - x<sub>1</sub> ) = ( y - y<sub>1</sub> )</span>

					<br /><br />
				</li>
				<li><b>The slope-intercept form of the line:</b><br />
					&#955; ( x - x<sub>1</sub> ) + y<sub>1</sub> = y<br />
					&#955;x - &#955;x<sub>1</sub> + y<sub>1</sub> = y<br />
					&#955;x + y<sub>1</sub> - &#955;x<sub>1</sub> = y &nbsp;&nbsp;&nbsp;<span class="cssxGrey">[Equation 1]</span>
					<br /><br />
					Create variable: &#946; = y<sub>1</sub> - &#955;x<sub>1</sub>
					<br /><br />
					Implement variable &#946; in Equation 1:<br />
					<span class="cssxEquation">y = &#955;x + &#946;</span> &nbsp;&nbsp;&nbsp;<span class="cssxGrey">[Equation 2]</span>
					<br /><br />
				</li>
				<li><b>Finding coordinates point R (x<sub>3</sub>, y<sub>3</sub>):</b><br />
					y = &#955;x + &#946;<br />
					y<sup>2</sup> = ( &#955;x + &#946; )<sup>2</sup>
					<br /><br />
					the ellipc curve: y<sup>2</sup> = x<sup>3</sup> + ax + b<br />
					( &#955;x + &#946; )<sup>2</sup> = x<sup>3</sup> + ax + b<br />
					( &#955;x )<sup>2</sup> + 2&#946;&#955;x + &#946;<sup>2</sup> = x<sup>3</sup> + ax + b<br />
					x<sup>3</sup> + ax + b - ( &#955;x )<sup>2</sup> - 2&#946;&#955;x - &#946;<sup>2</sup> = 0 <br />
					x<sup>3</sup> - &#955;<sup>2</sup>x<sup>2</sup> + ax - 2&#946;&#955;x + b - &#946;<sup>2</sup> = 0 <br />
					x<sup>3</sup> - &#955;<sup>2</sup>x<sup>2</sup> + (a - 2&#946;&#955;)x + (b - &#946;<sup>2</sup>) = 0 &nbsp;&nbsp;&nbsp;<span class="cssxGrey">[Equation 3]</span>
					<br /><br />
					Equation 3 represents a monic polynomial, it means is that the coefficient of the highest power<br />
					of x which is x<sup>3</sup> is 1. A property of monic polynomials is that the sum of their roots (x<sub>1</sub>, x<sub>2</sub>, x<sub>3</sub>)<br />
					is equal to the negative of the coefficient of the second highest power. <br />
					Notice that the coefficient of x<sup>2</sup> is -&#955;<sup>2</sup>, thus:<br />
					x<sub>1</sub> + x<sub>2</sub> + x<sub>3</sub> = &#955;<sup>2</sup><br />
					<span class="cssxEquation">x<sub>3</sub> = &#955;<sup>2</sup> - x<sub>1</sub> - x<sub>2</sub></span>
					<br /><br />
					x<sub>3</sub> and  y<sub>3</sub> must be on the straight line y = &#955;x + &#946;:<br />
					y<sub>3</sub> = &#955;x<sub>3</sub> + &#946;<br />
					y<sub>3</sub> = &#955;x<sub>3</sub> + (y<sub>1</sub> - &#955;x<sub>1</sub>)<br />
					y<sub>3</sub> = &#955;(x<sub>3</sub> - x<sub>1</sub>) + y<sub>1</sub>
					<br /><br />
					Point -R has the coordinate (x<sub>3</sub>, -y<sub>3</sub>). The reflection of the point -R with respect to x-axis gives the<br />
					point R (x<sub>3</sub>, y<sub>3</sub>), which is the results of addition of points P and Q.<br />
					This means you need to multiple y<sub>3</sub> with -1:<br />
					<span class="cssxEquation">y<sub>3</sub> = &#955;(x<sub>1</sub> - x<sub>3</sub>) - y<sub>1</sub></span>

					<br /><br />
				</li>
				<li><b>Implement modulo p to limit points (x<sub>R</sub>, y<sub>R</sub>) in finite field F<sub>p</sub>:</b><br />
					A straight line will intersect an elliptic curve at three points P (x<sub>1</sub>, y<sub>1</sub>), Q (x<sub>2</sub>, y<sub>2</sub>) and -R (x<sub>3</sub>, -y<sub>3</sub>).<br />
					The reflection of the point -R with respect to x-axis gives the point R (x<sub>3</sub>, y<sub>3</sub>), which is the result of<br />
					addition of points P and Q.<br />
					&#955; = ( y<sub>2</sub> - y<sub>1</sub> ) / ( x<sub>2</sub> - x<sub>1</sub> )<br />
					x<sub>3</sub> = &#955;<sup>2</sup> - x<sub>1</sub> - x<sub>2</sub><br />
					y<sub>3</sub> = &#955;(x<sub>1</sub> - x<sub>3</sub>) - y<sub>1</sub>
					<br /><br />
					Make point Q the same as the Generator point G (see <a href="#refSecp256k1">secp256k1</a> elliptic curve domain<br />
					parameters), repace point P coordinates (x<sub>1</sub>, y<sub>1</sub>) with ( x, y ) to indicate it can be any coordinate on<br />
					the curve and R coordinates (x<sub>3</sub>, y<sub>3</sub>) with (x<sub>R</sub>, y<sub>R</sub>) the equations will look like:
					<br /><br />
					&#955; = ( y<sub>G</sub> - y ) / ( x<sub>G</sub> - x)<br />
					x<sub>R</sub> = &#955;<sup>2</sup> - x - x<sub>G</sub><br />
					y<sub>R</sub> = &#955;(x - x<sub>R</sub>) - y
					<br /><br />
					The last three math operations may output real numbers (&#8477;).<br />
					Real numbers are numbers that can be positive or negative and have decimal places after the point.<br />
					Example: &#8477; = {..., -5, -2.5, 0, 3, 6.334, ...}.<br />
					In <a href="#refECC">ECC</a> we never work with real numbers only with integers (&#8484;) so there are no inaccuraties<br />
					due to rounding errors.<br />
					Integers are positive numbers and have no decimal places after the point.<br />
					Example: &#8484; = {0, 1, 2, 3, ...}<br />
					To make the calculations go faster a finite number of integers are to be used (F<sub>p</sub>).<br />
					The finite field (F<sub>p</sub>) make working with curves a completely different concept.<br />
					The curves when graphed over a finite field do not even resemble <a href="#refFig1">fig 1.</a><br />
					When modulo p is applied, the equations of adding two points (<a name="refECAdd"></a>ECAdd) will look like:
					<br /><br />
					<div class="cssxBlock">
					&#955; = ( y<sub>G</sub> - y ) modinv( x<sub>G</sub> - x) (mod p)<br />
					x<sub>R</sub> = &#955;<sup>2</sup> - x - x<sub>G</sub> (mod p)<br />
					y<sub>R</sub> = &#955;(x - x<sub>R</sub>) - y (mod p)
					</div>
					<br />
				</li>
			</ul>
		</li>
		</ul>

		<b>Doubling point P on an elliptic curve. Same as moving point Q to same location as point P (P = Q)</b>
		<ul>
		<li><b><a name="refFig2"></a>Fig. 2 Geometry approach</b>
			<br /><br />
			<script language="JavaScript" type="text/javascript">jsxShowDoublingPointImage();</script>
			<br /><br />
			<ul>
				<li>Draw a tangent line to the elliptic curve at point P.
				</li>
				<li>The line intersects the elliptic curve at the point -R.</li>
				<li>The reflection of the point -R with respect to x-axis gives the point R, which is the results of<br />
				 	doubling of point P.
				</li>
			</ul>
			<br />
		</li>
		<li><b>Mathematical approach</b><br />
			<ul>
				<li><b>The slope of the tangent at a point P (x<sub>1</sub>, y<sub>1</sub>):</b><br />
					The ellipc curve: y<sup>2</sup> = x<sup>3</sup> + ax + b<br />
					2y<i>dy</i> = 3x<sup>2</sup><i>dx</i> + a<br />
					a = 0, see <a href="#refSecp256k1">secp256k1</a> elliptic curve domain parameters<br />
					2y<i>dy</i> = 3x<sup>2</sup><i>dx</i><br />
					(2y<i>dy</i>)/<i>dx</i> = 3x<sup>2</sup><br />
					(<i>dy</i>/<i>dx</i>) = (3x<sup>2</sup>)/(2y)<br />
					&#955; = (<i>dy</i>/<i>dx</i>)<br />
					&#955; = (3x<sup>2</sup>)/(2y)<br />
					<span class="cssxEquation">&#955; = (3x<sub>1</sub><sup>2</sup>)/(2y<sub>1</sub>)</span>
					<br /><br />
				</li>
				<li><b>Finding coordinates point R (x<sub>3</sub>, y<sub>3</sub>):</b><br />
					Equation 3 represents a monic polynomial, it means is that the coefficient of the highest power<br />
					of x which is x<sup>3</sup> is 1. A property of monic polynomials is that the sum of their roots (x<sub>1</sub>, x<sub>2</sub>, x<sub>3</sub>)<br />
					is equal to the negative of the coefficient of the second highest power. <br />
					Notice that the coefficient of x<sup>2</sup> is -&#955;<sup>2</sup>, thus:<br />
					x<sub>1</sub> + x<sub>2</sub> + x<sub>3</sub> = &#955;<sup>2</sup>
					<br /><br />
					But point Q (x<sub>2</sub>, y<sub>2</sub>) is the same as point P (x<sub>1</sub>, y<sub>1</sub>), thus: <br />
					x<sub>1</sub> + x<sub>1</sub> + x<sub>3</sub> = &#955;<sup>2</sup><br />
					<span class="cssxEquation">x<sub>3</sub> = &#955;<sup>2</sup> - 2x<sub>1</sub></span>

					<br /><br />
					x<sub>3</sub> and  y<sub>3</sub> must be on the straight line (see Equation 2): y = &#955;x + &#946;:<br />
					y<sub>3</sub> = &#955;x<sub>3</sub> + &#946;<br />
					y<sub>3</sub> = &#955;x<sub>3</sub> + (y<sub>1</sub> - &#955;x<sub>1</sub>)<br />
					y<sub>3</sub> = &#955;(x<sub>3</sub> - x<sub>1</sub>) + y<sub>1</sub>
					<br /><br />
					Point -R has the coordinate (x<sub>3</sub>, -y<sub>3</sub>). The reflection of the point -R with respect to x-axis gives the<br />
					point R (x<sub>3</sub>, y<sub>3</sub>), which is the results of doubling of point P.<br />
					This means you need to multiple y<sub>3</sub> with -1:<br />
					<span class="cssxEquation">y<sub>3</sub> = &#955;(x<sub>1</sub> - x<sub>3</sub>) - y<sub>1</sub></span>
					<br /><br />
				</li>
				<li><b>Implement modulo p to limit points (x<sub>R</sub>, y<sub>R</sub>) in finite field F<sub>p</sub>:</b><br />
					The tangent line will intersect an elliptic curve at points P (x<sub>1</sub>, y<sub>1</sub>) and -R (x<sub>3</sub>, -y<sub>3</sub>).<br />
					The reflection of the point -R with respect to x-axis gives the point R (x<sub>3</sub>, y<sub>3</sub>), which is the result of<br />
					doubling of point P.<br />
					&#955; = (3x<sub>1</sub><sup>2</sup>)/(2y<sub>1</sub>)<br />
					x<sub>3</sub> = &#955;<sup>2</sup> - 2x<sub>1</sub><br />
					y<sub>3</sub> = &#955;(x<sub>1</sub> - x<sub>3</sub>) - y<sub>1</sub>
					<br /><br />
					Repace point P coordinates (x<sub>1</sub>, y<sub>1</sub>) with ( x, y ) to indicate it can be any coordinate on<br />
					the curve and R coordinates (x<sub>3</sub>, y<sub>3</sub>) with (x<sub>R</sub>, y<sub>R</sub>) the equations will look like:
					<br /><br />
					&#955; = (3x<sup>2</sup>)/(2y)<br />
					x<sub>R</sub> = &#955;<sup>2</sup> - 2x<br />
					y<sub>R</sub> = &#955;(x - x<sub>R</sub>) - y
					<br /><br />
					The last three math operations may output real numbers (&#8477;).<br />
					Real numbers are numbers that can be positive or negative and have decimal places after the point.<br />
					Example: &#8477; = {..., -5, -2.5, 0, 3, 6.334, ...}.<br />
					In <a href="#refECC">ECC</a> we never work with real numbers only with integers (&#8484;) so there are no inaccuraties<br />
					due to rounding errors.<br />
					Integers are positive numbers and have no decimal places after the point.<br />
					Example: &#8484; = {0, 1, 2, 3, ...}<br />
					To make the calculations go faster a finite number of integers are to be used (F<sub>p</sub>).<br />
					The finite field (F<sub>p</sub>) make working with curves a completely different concept.<br />
					The curves when graphed over a finite field do not even resemble <a href="#refFig2">fig 2.</a><br />
					When modulo p is applied, the equations of doubling a point (<a name="refECDouble"></a>ECDouble) will look like:
					<br /><br />
					<div class="cssxBlock">
					&#955; = (3x<sup>2</sup>) modinv(2y) (mod p)<br />
					x<sub>R</sub> = &#955;<sup>2</sup> - 2x (mod p)<br />
					y<sub>R</sub> = &#955;(x - x<sub>R</sub>) - y (mod p)
					</div>
				</li>
			</ul>
		</li>
		</ul>
		<br />
		<b><a name="refProdedure"></a>Procedure to calculate x and y</b>
		<br /><br />
		<table border="0" cellspacing="1" cellpadding="3" class="css-Table3">
		<tr>
			<td class="css-TableHeader">Step</td>
			<td class="css-TableHeader">Description</td>
		</tr>
		<tr>
			<td class="css-Data3">1</td>
			<td class="css-Data3">
				Get the Generator point G (<a href="#refXG">x<sub>G</sub></a>, <a href="#refYG">y<sub>G</sub></a>)<br />
				Get the number of points in the field: <a href="#refN">n</a><br />
				Get the <a href="#refPrivateKeyHex">PrivateKeyHex</a><br />
			</td>
		</tr>
		<tr>
			<td class="css-Data3">2</td>
			<td class="css-Data3">
				if&nbsp;(&nbsp;PrivateKeyHex&nbsp;>=&nbsp;n&nbsp;)&nbsp;{<br />
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Show error "PrivateKeyHex is too large."<br />
				} else {<br />
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Continue with step 3<br />
				}<br />
			</td>
		</tr>
		<tr>
			<td class="css-Data3">3</td>
			<td class="css-Data3">
				Convert PrivateKeyHex to <a href="#refPrivateKeyBin">PrivateKeyBin</a>
			</td>
		</tr>
		<tr>
			<td class="css-Data3">4</td>
			<td class="css-Data3">
				i = 0<br />
				x = x<sub>G</sub><br />
				y = y<sub>G</sub>
			</td>
		</tr>
		<tr>
			<td class="css-Data3">5</td>
			<td class="css-Data3">
					Point R (x<sub>R</sub>, y<sub>R</sub>) = <a href="#refECDouble">ECDouble(x, y)</a><br />
					x = x<sub>R</sub><br />
					y = y<sub>R</sub><br />
			</td>
		</tr>
		<tr>
			<td class="css-Data3">6</td>
			<td class="css-Data3">
				if&nbsp;(&nbsp;PrivateKeyBin[ i ]&nbsp;==&nbsp;1&nbsp;)&nbsp;{<br />
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Point R (x<sub>R</sub>, y<sub>R</sub>) = <a href="#refECAdd">ECAdd(x, y)</a><br />
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = x<sub>R</sub><br />
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = y<sub>R</sub><br />
				}<br />
			</td>
		</tr>
		<tr>
			<td class="css-Data3">7</td>
			<td class="css-Data3">i = i + 1</td>
		</tr>
		<tr>
			<td class="css-Data3">8</td>
			<td class="css-Data3">
				if&nbsp;(&nbsp;i < PrivateKeyBin.length&nbsp;)&nbsp;{<br />
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue with step 5<br />
				} <br />
			</td>
		</tr>
		<tr>
			<td class="css-Data3">9</td>
			<td class="css-Data3">
				x = x<sub>R</sub><br />
				y = y<sub>R</sub>
			</td>
		</tr>
		</table>
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr"><td colspan="5">&nbsp;</td></tr>

<tr class="cssxHideTr">
	<td class="css-Data">&nbsp;</td>
	<td>
		See <a href="#refProdedure">Procedure to calculate x and y</a>.<br />
		The x value is always 32 bytes or 64 characters long.
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr">
	<td class="css-Data"><a name="refX"></a>x</td>
	<td>
		<input name="cssxX" id="cssxX" type="text" size="90" value="" readonly="readonly" class="cssxGrey"/>
		<script language="JavaScript" type="text/javascript">jsxShowKeepSecretImage();</script>
	</td>
	<td><input type="text" name="cssxXLength" id="cssxXLength" size="4" maxlength="5" readonly="readonly" class="cssxGrey" /> chars</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr"><td colspan="5">&nbsp;</td></tr>

<tr class="cssxHideTr">
	<td class="css-Data">&nbsp;</td>
	<td>
		See <a href="#refProdedure">Procedure to calculate x and y</a>.<br />
		The y value is always 32 bytes or 64 characters long.
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr">
	<td class="css-Data"><a name="refY"></a>y</td>
	<td>
		<input name="cssxY" id="cssxY" type="text" size="90" value="" readonly="readonly" class="cssxGrey"/>
		<script language="JavaScript" type="text/javascript">jsxShowKeepSecretImage();</script>
	</td>
	<td><input type="text" name="cssxYLength" id="cssxYLength" size="4" maxlength="5" readonly="readonly" class="cssxGrey" /> chars</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr"><td colspan="5">&nbsp;</td></tr>

<tr class="cssxHideTr">
	<td class="css-Data">&nbsp;</td>
	<td>
		The PublicKey is the concatenation of the calculated x and y value.<br />
		The PublicKey is always 64 bytes or 128 characters long.
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr">
	<td class="css-Data"><a name="refPublicKey"></a>PublicKey = <br /> x || y</td>
	<td>
		<textarea cols="75" rows="2" name="cssxPublicKey" id="cssxPublicKey" readonly="readonly" class="cssxGrey"></textarea>
		<script language="JavaScript" type="text/javascript">jsxShowKeepSecretImage();</script>
	</td>
	<td><input type="text" name="cssxPublicKeyLength" id="cssxPublicKeyLength" size="4" maxlength="5" readonly="readonly" class="cssxGrey" /> chars</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr"><td colspan="5"><hr /></td></tr>

<tr class="cssxNoPrint">
	<td>&nbsp;</td>
	<td class="css-Data" colspan="4">Calculate <div id="cssxAddressNetwork3"></div> PublicKey Uncompressed</td>
</tr>

<tr class="cssxNoPrint"><td colspan="5">&nbsp;</td></tr>

<tr class="cssxHideTr">
	<td class="css-Data">&nbsp;</td>
	<td>
		There are two types of PublickKeys, the compressed and uncompressed.<br />
		Prepend prefix value "04" in front of the PublickKey value to indicate that the PublickKey is uncompressed. <br />
		The prefix value is always 1 byte in size and the PublickKey is 64 bytes.<br />
		The PublicKeyVersion value is always (1+64=) 65 bytes or 130 characters long.<br />
		<br /><br />
		The public keys are either 33 bytes (<a href="#refPublicKeyVersionComp">PublicKey Compressed, PublicKeyVersionComp</a>) or 65 bytes long<br />
		(<a href="#PublicKeyVersion">PublicKey Uncompressed, PublicKeyVersion</a>). Compressed keys only specify the <a href="#refX">x coordinate</a> plus an 1 byte<br />
		flag indicating which side of the symmetrical curve the point is on, which allows y to be derived.<br />
		Uncompressed keys is represented by two coordinates (<a href="#refX">x</a>, <a href="#refY">y</a>) and there is a 1 byte prefix added.<br />
		Bitcoin originally only used uncompressed public keys, but since v0.6 compressed are now used.<br />
		It is recommended to use the compressed public keys (<a href="#refPublicKeyVersionComp">PublicKeyVersionComp</a>) because they are smaller, <br />
		resulting in smaller transactions on the network, saving block chain size for everyone.
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr">
	<td class="css-Data"><a name="refPublicKeyVersion"></a>PublicKeyVersion = <br /> "04" || PublicKey</td>
	<td>
		<textarea cols="75" rows="2" name="cssxPublicKeyVersion" id="cssxPublicKeyVersion" readonly="readonly" class="cssxGrey"></textarea>
		<script language="JavaScript" type="text/javascript">jsxShowKeepSecretImage();</script>
	</td>
	<td><input type="text" name="cssxPublicKeyVersionLength" id="cssxPublicKeyVersionLength" size="4" maxlength="5" readonly="readonly" class="cssxGrey" /> chars</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr"><td colspan="5">&nbsp;</td></tr>

<tr class="cssxHideTr">
	<td class="css-Data">&nbsp;</td>
	<td>
		Hash the <a href="#refPublicKeyVersion">PublicKeyVersion</a> value using the cryptographic hash function SHA256.<br />
		This Secure Hash Algorithm generates a 256-bit (32-byte) signature which cannot be decrypted back<br />
		to the original value (it is a one-way cryptographic function).<br />
		The HashC1 value is always 32 bytes or 64 characters long.<br />
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr">
	<td class="css-Data"><a name="refHashC1"></a>HashC1 = <br />SHA256(PublicKeyVersion)</td>
	<td>
		<input name="cssxHashC1" id="cssxHashC1" size="90" value="" readonly="readonly" class="cssxGrey" />
		<script language="JavaScript" type="text/javascript">jsxShowKeepSecretImage();</script>
	</td>
	<td><input type="text" name="cssxHashC1Length" id="cssxHashC1Length" size="4" maxlength="5" readonly="readonly" class="cssxGrey" /> chars</td>
	<td colspan="2">&nbsp;</td>
</tr>


<tr class="cssxHideTr"><td colspan="5">&nbsp;</td></tr>

<tr class="cssxHideTr">
	<td class="css-Data">&nbsp;</td>
	<td>
		Hash the <a href="#refHashC1">HashC1</a> value using the cryptographic hash function RIPEMD160.<br />
		The RIPEMD160 (RACE Integrity Primitives Evaluation Message Digest) generates a 160-bit (20-byte) signature<br />
		which cannot be decrypted back to the original value (it is a one-way cryptographic function).<br />
		The HashC2 value is always 20 bytes or 40 characters long.
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr">
	<td class="css-Data"><a name="refHashC2"></a>HashC2 = <br />RIPEMD160(HashC1) </td>
	<td>
		<input name="cssxHashC2" id="cssxHashC2" size="90" value="" readonly="readonly" class="cssxGrey" />
		<script language="JavaScript" type="text/javascript">jsxShowKeepSecretImage();</script>
	</td>
	<td><input type="text" name="cssxHashC2Length" id="cssxHashC2Length" size="4" maxlength="5" readonly="readonly" class="cssxGrey" /> chars</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr"><td colspan="5">&nbsp;</td></tr>

<tr class="cssxHideTr">
	<td class="css-Data">&nbsp;</td>
	<td>
		Each cryptocurrency publicKey has their own prefix version number (Bitcoin= 0x00, Litecoin=0x30, etc).<br />
		Prepend this version number in front of the <a href="#refHashC2">HashC2</a> value.<br />
		The prefix version number is always 1 byte in size and the HashC2 is 20 bytes.<br />
		The PublicKeyVersionHashC value is always (1+20=) 21 bytes or 42 characters long.
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr">
	<td class="css-Data"><a name="refPublicKeyVersionHashC"></a>PublicKeyVersionHashC = <br />Version "<div style="display:inline" id="cssxPublicKeyPrefix"></div>" || HashC2 </td>
	<td>
		<input name="cssxPublicKeyVersionHashC" id="cssxPublicKeyVersionHashC" size="90" value="" readonly="readonly" class="cssxGrey" />
		<script language="JavaScript" type="text/javascript">jsxShowKeepSecretImage();</script>
	</td>
	<td><input type="text" name="cssxPublicKeyVersionHashCLength" id="cssxPublicKeyVersionHashCLength" size="4" maxlength="5" readonly="readonly" class="cssxGrey" /> chars</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr"><td colspan="5">&nbsp;</td></tr>

<tr class="cssxHideTr">
	<td class="css-Data">&nbsp;</td>
	<td>
		Hash the <a href="#refPublicKeyVersionHashC">PublicKeyVersionHashC</a> value using the cryptographic hash function SHA256.<br />
		This Secure Hash Algorithm generates a 256-bit (32-byte) signature which cannot be decrypted back<br />
		to the original value (it is a one-way cryptographic function).<br />
		The HashC3 value is always 32 bytes or 64 characters long.<br />
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr">
	<td class="css-Data"><a name="refHashC3"></a>HashC3 = SHA256(PublicKeyVersionHashC)</td>
	<td>
		<input name="cssxHashC3" id="cssxHashC3" type="text" size="90" value="" readonly="readonly" class="cssxGrey"/>
		<script language="JavaScript" type="text/javascript">jsxShowKeepSecretImage();</script>
	</td>
	<td><input type="text" name="cssxHashC3Length" id="cssxHashC3Length" size="4" maxlength="5" readonly="readonly" class="cssxGrey" /> chars</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr"><td colspan="5">&nbsp;</td></tr>

<tr class="cssxHideTr">
	<td class="css-Data">&nbsp;</td>
	<td>
		Hash the <a href="#refHashC3">HashC3</a> value using the cryptographic hash function SHA256.<br />
		This Secure Hash Algorithm generates a 256-bit (32-byte) signature which cannot be decrypted back<br />
		to the original value (it is a one-way cryptographic function).<br />
		The HashC4 value is always 32 bytes or 64 characters long.<br />
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr">
	<td class="css-Data"><a name="refHashC4"></a>HashC4 = SHA256(HashC3)</td>
	<td>
		<input name="cssxHashC4" id="cssxHashC4" type="text" size="90" value="" readonly="readonly" class="cssxGrey"/>
		<script language="JavaScript" type="text/javascript">jsxShowKeepSecretImage();</script>
	</td>
	<td><input type="text" name="cssxHashC4Length" id="cssxHashC4Length" size="4" maxlength="5" readonly="readonly" class="cssxGrey" /> chars</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr"><td colspan="5">&nbsp;</td></tr>

<tr class="cssxHideTr">
	<td class="css-Data">&nbsp;</td>
	<td>
		Get the first 4 bytes (or first 8 characters) of the <a href="#refHashC4">HashC4</a> value.<br />
		These 4 bytes is the checksum value which will be used to validate the address.<br />
		The ChecksumC value is always 4 bytes or 8 characters long.<br />
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr">
	<td class="css-Data"><a name="refChecksumC"></a>ChecksumC (first 4 bytes of HashC4)</td>
	<td>
		<input name="cssxChecksumC" id="cssxChecksumC" type="text" size="90" value="" readonly="readonly" class="cssxGrey"/>
		<script language="JavaScript" type="text/javascript">jsxShowShareImage();</script>
	</td>
	<td><input type="text" name="cssxChecksumCLength" id="cssxChecksumCLength" size="4" maxlength="5" readonly="readonly" class="cssxGrey" /> chars</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr"><td colspan="5">&nbsp;</td></tr>

<tr class="cssxHideTr">
	<td class="css-Data">&nbsp;</td>
	<td>
		Append the <a href="#refChecksumC">ChecksumC</a> value at the end of the <a href="#refPublicKeyVersionHashC">PublicKeyVersionHashC</a> value.<br />
		The PublicKeyChecksumC value is always (21+4=) 25 bytes or 50 characters long.<br />
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr">
	<td class="css-Data"><a name="refPublicKeyChecksumC"></a>PublicKeyChecksumC = PublicKeyVersionHashC || ChecksumC</td>
	<td>
		<input name="cssxPublicKeyChecksumC" id="cssxPublicKeyChecksumC" type="text" size="90" value="" readonly="readonly" class="cssxGrey"/>
		<script language="JavaScript" type="text/javascript">jsxShowShareImage();</script>
	</td>
	<td><input type="text" name="cssxPublicKeyChecksumCLength" id="cssxPublicKeyChecksumCLength" size="4" maxlength="5" readonly="readonly" class="cssxGrey" /> chars</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr"><td colspan="5">&nbsp;</td></tr>

<tr class="cssxHideTr">
	<td class="css-Data">&nbsp;</td>
	<td>
		The Public Address Uncompressed is the <a href="#refPublicKeyChecksumC">PublicKeyChecksumC</a> value encoded into a<br />
		Base58 value. The PublicKeyUncompressed value can be made public and can be converted into <a href="#refQRCodes">QR codes</a><br />
		and can be printed on <a href="#refQRCodes">paper wallets</a>.
		<br /><br />
		If your software uses the <a href="#refPrivateKeyWIFCompressed">PrivateKeyWIFUncompressed</a> value, it also means you are the using the<br />
		PublicKeyUncompressed.
		<br /><br />
		It is recommended to always to use the compressed public key (<a href="#refPublicKeyCompressed">PublicKeyCompressed</a>) and the compressed<br />
		private key (<a href="#refPrivateKeyWIFCompressed">PrivateKeyWIFCompressed</a>. If your software does not support the compressed keys you can use<br />
		the uncompressed public key (<a href="#refPublicKeyUncompressed">PublicKeyUncompressed</a>) and uncompressed private key<br />
		(<a href="#refPrivateKeyWIFUncompressed">PrivateKeyWIFUncompressed</a>).
		<br /><br />
		To check if a PublicKeyUncompressed has a valid checksum enter a new PublicKeyUncompressed address <br />
		and press the Validate button.<br />
		This button does not update previous values, for example PublicKeyChecksumC, ChecksumC, etc.
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxNoPrint">
	<td class="css-Data"><a name="refPublicKeyUncompressed"></a>PublicKeyUncompressed <div class="cssxHideDiv">= Base58(PublicKeyChecksumC)</div></td>
	<td>
		<input name="cssxPublicKeyUncompressed" id="cssxPublicKeyUncompressed" type="text" size="90" value="" class="cssxGreen"/>
		<script language="JavaScript" type="text/javascript">jsxShowShareImage();</script>
	</td>
	<td><input type="text" name="cssxPublicKeyUncompressedLength" id="cssxPublicKeyUncompressedLength" size="4" maxlength="5" readonly="readonly" class="cssxGrey" /> chars</td>
	<td colspan="2">
		<input type="button" class="css-Button" value="Validate" id="cssxPublicKeyUncompressedButton" onclick="jsxIsPublicKeyCompressedOrUncompressedValid('cssxPublicKeyUncompressed', true);" />
	</td>
</tr>

<tr class="cssxNoPrint">
	<td class="css-Data">&nbsp;</td>
	<td>
		<input type="button" class="css-Button" value="View" onclick="jsxViewOnBlockChain('cssxPublicKeyUncompressed');" />
		the <div id="cssxAddressNetwork9"></div> PublicKeyUncompressed address on Blockchain.info.
	</td>
	<td colspan="3">
		&nbsp;
	</td>
</tr>

<tr class="cssxNoPrint"><td colspan="5"><hr /></td></tr>

<tr class="cssxNoPrint">
	<td>&nbsp;</td>
	<td class="css-Data" colspan="4">Calculate <div id="cssxAddressNetwork4"></div> PublicKey Compressed</td>
</tr>

<tr class="cssxNoPrint"><td colspan="5">&nbsp;</td></tr>

<tr class="cssxHideTr">
	<td class="css-Data">&nbsp;</td>
	<td>
		If y is even, prefix value 02 (1 byte) is appended to value <a href="#refX">x</a>.<br />
		If y is odd, prefix value 03 (1 byte) is appended to value <a href="#refX">x</a>.<br />
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr">
	<td class="css-Data">y is odd or even</td>
	<td colspan="2">
		<input name="cssxYOddOrEven" id="cssxYOddOrEven" type="text" size="90" value="" readonly="readonly" class="cssxGrey" />
		<script language="JavaScript" type="text/javascript">jsxShowShareImage();</script>
	</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr"><td colspan="5">&nbsp;</td></tr>

<tr class="cssxHideTr">
	<td class="css-Data">&nbsp;</td>
	<td>
		The prefix value (1 byte) is appended to value <a href="#refX">x</a>.<br />
		PublicKeyVersionComp is always (1 + 32) = 33 bytes or 66 characters long.
		<br /><br />
		The public keys are either 33 bytes (PublicKey Compressed, PublicKeyVersionComp) or 65 bytes long<br />
		(<a href="#refPublicKeyUncompressed">PublicKey Uncompressed, PublicKeyVersion</a>). Compressed keys only specify the <a href="#refX">x</a> coordinate plus an 1 byte<br />
		flag indicating which side of the symmetrical curve the point is on, which allows y to be derived.<br />
		Uncompressed keys is represented by two coordinates (<a href="#refX">x</a>, <a href="#refY">y</a>) and there is a 1 byte prefix added.<br />
		Bitcoin originally only used uncompressed public keys, but since v0.6 compressed are now used.<br />
		It is recommended to use the compressed public keys (PublicKeyVersionComp) because they are smaller, <br />
		resulting in smaller transactions on the network, saving block chain size for everyone.
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr">
	<td class="css-Data"><a name="refPublicKeyVersionComp"></a>PublicKeyVersionComp = <br /> Prefix || x</td>
	<td>
		<textarea cols="75" rows="2" name="cssxPublicKeyVersionComp" id="cssxPublicKeyVersionComp" readonly="readonly" class="cssxGrey"></textarea>
		<script language="JavaScript" type="text/javascript">jsxShowKeepSecretImage();</script>
	</td>
	<td><input type="text" name="cssxPublicKeyVersionCompLength" id="cssxPublicKeyVersionCompLength" size="4" maxlength="5" readonly="readonly" class="cssxGrey" /> chars</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr"><td colspan="5">&nbsp;</td></tr>

<tr class="cssxHideTr">
	<td class="css-Data">&nbsp;</td>
	<td>
		Hash the <a href="#refPublicKeyVersionComp">PublicKeyVersionComp</a> value using the cryptographic hash function SHA256.<br />
		This Secure Hash Algorithm generates a 256-bit (32-byte) signature which cannot be decrypted back<br />
		to the original value (it is a one-way cryptographic function).<br />
		The HashD1 value is always 32 bytes or 64 characters long.<br />
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr">
	<td class="css-Data"><a name="refHashD1"></a>HashD1 = <br />SHA256(PublicKeyVersionComp)</td>
	<td>
		<input name="cssxHashD1" id="cssxHashD1" size="90" value="" readonly="readonly" class="cssxGrey" />
		<script language="JavaScript" type="text/javascript">jsxShowKeepSecretImage();</script>
	</td>
	<td><input type="text" name="cssxHashD1Length" id="cssxHashD1Length" size="4" maxlength="5" readonly="readonly" class="cssxGrey" /> chars</td>
	<td colspan="2">&nbsp;</td>
</tr>


<tr class="cssxHideTr"><td colspan="5">&nbsp;</td></tr>

<tr class="cssxHideTr">
	<td class="css-Data">&nbsp;</td>
	<td>
 	Hash the <a href="#refHashD1">HashD1</a> value using the cryptographic hash function RIPEMD160.<br />
	The RIPEMD160 (RACE Integrity Primitives Evaluation Message Digest) generates a 160-bit (20-byte) signature<br />
	which cannot be decrypted back to the original value (it is a one-way cryptographic function).<br />
	The HashD2 value is always 20 bytes or 40 characters long.
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr">
	<td class="css-Data"><a name="refHashD2"></a>HashD2 = <br />RIPEMD160(HashD1) </td>
	<td>
		<input name="cssxHashD2" id="cssxHashD2" size="90" value="" readonly="readonly" class="cssxGrey" />
		<script language="JavaScript" type="text/javascript">jsxShowKeepSecretImage();</script>
	</td>
	<td><input type="text" name="cssxHashD2Length" id="cssxHashD2Length" size="4" maxlength="5" readonly="readonly" class="cssxGrey" /> chars</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr"><td colspan="5">&nbsp;</td></tr>

<tr class="cssxHideTr">
	<td class="css-Data">&nbsp;</td>
	<td>
		Each cryptocurrency publicKey has their own prefix version number (Bitcoin= 0x00, Litecoin=0x30, etc).<br />
		Prepend this version number in front of the <a href="#refHashD2">HashD2</a> value.<br />
		The prefix version number is always 1 byte in size and the HashD2 is 20 bytes.<br />
		The PublicKeyVersionHashD value is always (1+20=) 21 bytes or 42 characters long.
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr">
	<td class="css-Data"><a name="refPublicKeyVersionHashD"></a>PublicKeyVersionHashD = <br />Version "<div style="display:inline" id="cssxPublicKeyCompPrefix"></div>" || HashD2 </td>
	<td>
		<input name="cssxPublicKeyVersionHashD" id="cssxPublicKeyVersionHashD" size="90" value="" readonly="readonly" class="cssxGrey" />
		<script language="JavaScript" type="text/javascript">jsxShowKeepSecretImage();</script>
	</td>
	<td><input type="text" name="cssxPublicKeyVersionHashDLength" id="cssxPublicKeyVersionHashDLength" size="4" maxlength="5" readonly="readonly" class="cssxGrey" /> chars</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr"><td colspan="5">&nbsp;</td></tr>

<tr class="cssxHideTr">
	<td class="css-Data">&nbsp;</td>
	<td>
		Hash the <a href="#refPublicKeyVersionHashD">PublicKeyVersionHashD</a> value using the cryptographic hash function SHA256.<br />
		This Secure Hash Algorithm generates a 256-bit (32-byte) signature which cannot be decrypted back<br />
		to the original value (it is a one-way cryptographic function).<br />
		The HashD3 value is always 32 bytes or 64 characters long.
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr">
	<td class="css-Data"><a name="refHashD3"></a>HashD3 = SHA256(PublicKeyVersionHashD)</td>
	<td>
		<input name="cssxHashD3" id="cssxHashD3" type="text" size="90" value="" readonly="readonly" class="cssxGrey"/>
		<script language="JavaScript" type="text/javascript">jsxShowKeepSecretImage();</script>
	</td>
	<td><input type="text" name="cssxHashD3Length" id="cssxHashD3Length" size="4" maxlength="5" readonly="readonly" class="cssxGrey" /> chars</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr"><td colspan="5">&nbsp;</td></tr>

<tr class="cssxHideTr">
	<td class="css-Data">&nbsp;</td>
	<td>
		Hash the <a href="#refHashD3">HashD3</a> value using the cryptographic hash function SHA256.<br />
		This Secure Hash Algorithm generates a 256-bit (32-byte) signature which cannot be decrypted back<br />
		to the original value (it is a one-way cryptographic function).<br />
		The HashD4 value is always 32 bytes or 64 characters long.
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr">
	<td class="css-Data"><a name="refHashD4"></a>HashD4 = SHA256(HashD3)</td>
	<td>
		<input name="cssxHashD4" id="cssxHashD4" type="text" size="90" value="" readonly="readonly" class="cssxGrey"/>
		<script language="JavaScript" type="text/javascript">jsxShowKeepSecretImage();</script>
	</td>
	<td><input type="text" name="cssxHashD4Length" id="cssxHashD4Length" size="4" maxlength="5" readonly="readonly" class="cssxGrey" /> chars</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr"><td colspan="5">&nbsp;</td></tr>

<tr class="cssxHideTr">
	<td class="css-Data">&nbsp;</td>
	<td>
		Get the first 4 bytes (or first 8 characters) of the <a href="#refHashD4">HashD4</a> value.<br />
		These 4 bytes is the checksum value which will be used to validate the address.<br />
		The ChecksumD value is always 4 bytes or 8 characters long.<br />
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr">
	<td class="css-Data"><a name="refChecksumD"></a>ChecksumD (first 4 bytes of HashD4)</td>
	<td>
		<input name="cssxChecksumD" id="cssxChecksumD" type="text" size="90" value="" readonly="readonly" class="cssxGrey"/>
		<script language="JavaScript" type="text/javascript">jsxShowShareImage();</script>
	</td>
	<td><input type="text" name="cssxChecksumDLength" id="cssxChecksumDLength" size="4" maxlength="5" readonly="readonly" class="cssxGrey" /> chars</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr"><td colspan="5">&nbsp;</td></tr>

<tr class="cssxHideTr">
	<td class="css-Data">&nbsp;</td>
	<td>
		Append the <a href="#refChecksumD">ChecksumD</a> value at the end of the PublicKeyVersionHashD value.<br />
		The PublicKeyChecksumD value is always (21+4=) 25 bytes or 50 characters long.
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr">
	<td class="css-Data"><a name="refPublicKeyChecksumD"></a>PublicKeyChecksumD = PublicKeyVersionHashD || ChecksumD</td>
	<td>
		<input name="cssxPublicKeyChecksumD" id="cssxPublicKeyChecksumD" type="text" size="90" value="" readonly="readonly" class="cssxGrey"/>
		<script language="JavaScript" type="text/javascript">jsxShowShareImage();</script>
	</td>
	<td><input type="text" name="cssxPublicKeyChecksumDLength" id="cssxPublicKeyChecksumDLength" size="4" maxlength="5" readonly="readonly" class="cssxGrey" /> chars</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxHideTr"><td colspan="5">&nbsp;</td></tr>

<tr class="cssxHideTr">
	<td class="css-Data">&nbsp;</td>
	<td>
		The Public Address Compressed is the <a href="#refPublicKeyChecksumD">PublicKeyChecksumD</a> value encoded into a<br />
		Base58 value. The PublicKeyCompressed value can be made public and can be converted into <a href="#refQRCodes">QR codes</a><br />
		and can be printed on <a href="#refQRCodes">paper wallets</a>.
		<br /><br />
		If your software uses the <a href="#refPrivateKeyWIFCompressed">PrivateKeyWIFCompressed</a> value, it also means you are the using the<br />
		PublicKeyCompressed.
		<br /><br />
		It is recommended to always to use the compressed public key (<a href="#refPublicKeyCompressed">PublicKeyCompressed</a>) and the compressed<br />
		private key (<a href="#refPrivateKeyWIFCompressed">PrivateKeyWIFCompressed</a>. If your software does not support the compressed keys you can use<br />
		the uncompressed public key (<a href="#refPublicKeyUncompressed">PublicKeyUncompressed</a>) and uncompressed private key<br />
		(<a href="#refPrivateKeyWIFUncompressed">PrivateKeyWIFUncompressed</a>).
		<br /><br />
		To check if a PublicKeyCompressed has a valid checksum enter a new PublicKeyCompressed address <br />
		and press the Validate button.<br />
		This button does not update previous values, for example PublicKeyChecksumD, ChecksumD, etc.
	</td>
	<td>&nbsp;</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxNoPrint">
	<td class="css-Data"><a name="refPublicKeyCompressed"></a>PublicKeyCompressed <div class="cssxHideDiv">= Base58(PublicKeyChecksumD)</div></td>
	<td>
		<input name="cssxPublicKeyCompressed" id="cssxPublicKeyCompressed" type="text" size="90" value="" class="cssxGreen"/>
		<script language="JavaScript" type="text/javascript">jsxShowShareImage();</script>
	</td>
	<td><input type="text" name="cssxPublicKeyCompressedLength" id="cssxPublicKeyCompressedLength" size="4" maxlength="5" readonly="readonly" class="cssxGrey" /> chars</td>
	<td colspan="2">
		<input type="button" class="css-Button" value="Validate" id="cssxPublicKeyCompressedButton" onclick="jsxIsPublicKeyCompressedOrUncompressedValid('cssxPublicKeyCompressed', true);" />
	</td>
</tr>

<tr class="cssxNoPrint">
	<td class="css-Data">&nbsp;</td>
	<td>
		<input type="button" class="css-Button" value="View" onclick="jsxViewOnBlockChain('cssxPublicKeyCompressed');" />
		the <div id="cssxAddressNetwork5"></div> PublicKeyCompressed address on Blockchain.info.
	</td>
	<td colspan="3">
		&nbsp;
	</td>
</tr>

<tr class="cssxNoPrint"><td colspan="5"><hr /></td></tr>

<tr class="cssxNoPrint">
	<td>&nbsp;</td>
	<td class="css-Data" colspan="4"><a name="refVanityPublicKey"></a>Generate <div id="cssxAddressNetwork6"></div> Vanity PublicKey Uncompressed/Compressed</td>
</tr>

<tr class="cssxNoPrint"><td colspan="5">&nbsp;</td></tr>

<tr class="cssxNoPrint">
	<td class="css-Data" rowspan="4">Vanity PublicKey<br /> Uncompressed/Compressed</td>
	<td colspan="2">
		The <div id="cssxAddressNetwork7"></div> publicKey starts with prefix "<div id="cssxAddressPrefix" style="display:inline"></div>"

		<select name="cssxVanityLocation" id="cssxVanityLocation">
		<option value="left" selected="selected">followed by</option>
		<option value="right">ending with</option>
		</select>

		vanity letters <input type="text" name="cssxVanityLetters" id="cssxVanityLetters" size="6" maxlength="5" />
	</td>
	<td colspan="2">
		<input type="button" class="css-Button" value="Generate" name="cssxGenerateVanityAddress" id="cssxGenerateVanityAddress" onclick="jsxStartGenerateVanityAddress()" />
	</td>
</tr>

<tr class="cssxNoPrint">
	<td colspan="2">The publicKey is
		<select name="cssxVanityConversion" id="cssxVanityConversion">
		<option value="compressed" selected="selected">compressed</option>
		<option value="uncompressed">uncompressed</option>
		</select>
		and the vanity letters are
		<input type="checkbox" name="cssxVanityCaseSensitive" id="cssxVanityCaseSensitive" /><div style="display:inline; vertical-align: 2px">case sensitive</div>
	</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxNoPrint">
	<td colspan="2">
		Total iterations <input type="text" name="cssxVanityCombinations" id="cssxVanityCombinations" size="10" maxlength="10" readonly="readonly" class="cssxGrey"  /> <script language="JavaScript" type="text/javascript">jsxShowLoadImage();</script>
	</td>
	<td colspan="2">&nbsp;</td>
</tr>

<tr class="cssxNoPrint">
	<td colspan="2">
		Generated vanity publicKey <input name="cssxVanityPublicKey" id="cssxVanityPublicKey" type="text" class="cssxGrey" size="60" value="" readonly="readonly" />
		<script language="JavaScript" type="text/javascript">jsxShowShareImage();</script>
	</td>
	<td colspan="2">
		<input type="button" class="css-Button" value="Stop" name="cssxStopGenerateVanityAddress" id="cssxStopGenerateVanityAddress" onclick="jsxStopGenerateVanityAddress()" />
	</td>
</tr>

<tr class="cssxNoPrint"><td colspan="5"><hr /></td></tr>

<tr>
	<td class="css-Data">
		<span class="cssxNoPrint">
			<a name="refQRCodes"></a>Public and Private keys QR codes
			<br /><br />
			<a href="javascript:jsxMakePrinterFriendlyPage();">Make printer friendly page to create paper wallet</a>
		</span>
	</td>
	<td colspan="4">

	<table border="0" cellspacing="1" cellpadding="3" class="cssxQRCodeTable">
		<tr>
			<td class="cssxQRTableHeader" width="42%">Public Address Uncompressed - <div id="cssxAddressNetworkQRCode1">BITCOIN</div></td>
			<td class="cssxQRTableHeader" style="text-align:right">Private Key (Wallet Import Format) Uncompressed - <div id="cssxAddressNetworkQRCode2">BITCOIN</div></td>
		</tr>
		<tr>
			<td class="cssxQRTableData">
	  			<div id="cssxQRCodePublicKeyUncompressed"></div>
				Share / Deposit / Verify
			</td>
			<td class="cssxQRTableData" style="text-align:right">
			    <div id="cssxQRCodePrivateKeyWIFUncompressed"></div>
				Secret
			</td>
		</tr>
		<tr>
			<td class="cssxQRTableFooter">
				<div id="cssxQRCodePublicKeyUncompressedValue"></div>
			</td>
			<td class="cssxQRTableFooter" style="text-align:right">
				<div id="cssxQRCodePrivateKeyWIFUncompressedValue"></div>
			</td>
		</tr>
	</table>

	<br />

	<table border="0" cellspacing="1" cellpadding="3" class="cssxQRCodeTable">
		<tr>
			<td class="cssxQRTableHeader" width="42%">Public Address Compressed - <div id="cssxAddressNetworkQRCode3">BITCOIN</div></td>
			<td class="cssxQRTableHeader" style="text-align:right">Private Key (Wallet Import Format) Compressed - <div id="cssxAddressNetworkQRCode4">BITCOIN</div></td>
		</tr>
		<tr>
			<td class="cssxQRTableData">
	  			<div id="cssxQRCodePublicKeyCompressed"></div>
				Share / Deposit / Verify
			</td>
			<td class="cssxQRTableData" style="text-align:right">
			    <div id="cssxQRCodePrivateKeyWIFCompressed"></div>
				Secret
			</td>
		</tr>
		<tr>
			<td class="cssxQRTableFooter">
				<div id="cssxQRCodePublicKeyCompressedValue"></div>
			</td>
			<td class="cssxQRTableFooter" style="text-align:right">
				<div id="cssxQRCodePrivateKeyWIFCompressedValue"></div>
			</td>
		</tr>
	</table>
	</td>
</tr>

<tr class="cssxNoPrint"><td colspan="5"><hr /></td></tr>



<tr class="cssxNoPrint">
<td class="css-Data" colspan="5">
	If you've found this tool useful feel free to send me a tip: BTC 18aiWtmkfVCpoXM7ADj6aRyCfoB6QjsZ3r
	<br /><br />
	<script language="JavaScript" type="text/javascript">jsxShowBitcoinAddressImage();</script>
	<br /><br />
</td>
</tr>


<tr class="cssxNoPrint"><td colspan="5"><hr /></td></tr>

<tr class="cssxNoPrint">
	<td class="css-Data2" colspan="5">
	Disclaimer:
	<br /><br />
	Use this tool at your own risk! All information on this page is provided "as is", without any warranty.<br />
	Mobilefish.com will not be liable for any damages, loss of profits or any other kind of loss you may sustain by using this tool.
	<br /><br />
	</td>
</tr>
</table>
</form>

<script language="JavaScript" type="text/javascript">
	jsxReset();

	// detect escape key press.
	// If esc key is press execute method 2.
	document.onkeydown = function(evt) {
	    evt = evt || window.event;
	    if (evt.keyCode == 27) {
	        jsxClearPassword();
			jsxGenerateRandomNumbers(true);
	    }
	};

</script>
</body>
</html>
